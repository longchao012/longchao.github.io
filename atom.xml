<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://longchao012.github.io/atom.xml" rel="self"/>
  
  <link href="https://longchao012.github.io/"/>
  <updated>2023-09-06T08:28:34.315Z</updated>
  <id>https://longchao012.github.io/</id>
  
  <author>
    <name>龙超小站</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL主从服务的配置及其中可能会遇到的问题</title>
    <link href="https://longchao012.github.io/2022/09/18/MySQL%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E4%B8%AD%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://longchao012.github.io/2022/09/18/MySQL%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E4%B8%AD%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-09-18T06:51:12.000Z</published>
    <updated>2023-09-06T08:28:34.315Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一次数据库的主从配置管理，把其中的主要操作的技术点还有过程中可能会遇到的问题在此记录一下，以备后需。</p><span id="more"></span><p><strong>一、MySQL主从服务概述</strong></p><p>MySQL主从服务是一种常用的数据同步和高可用性解决方案。通过配置主从关系，我们可以实现数据备份、读取分离和故障恢复等功能。本文将详细介绍MySQL主从服务的安装和配置步骤，帮助您顺利搭建主从环境。</p><p><strong>二、安装MySQL主服务</strong></p><p>准备工作：确保操作系统满足MySQL的安装要求，如Windows或Linux等。<br>下载MySQL安装包，根据操作系统选择相应的版本。<br>解压安装包，执行安装程序。在安装过程中，选择自定义安装，并注意勾选“启动为服务”。<br>完成安装后，使用管理员权限登录操作系统。<br>**<br><strong>三、配置MySQL主服务</strong></p><p>打开MySQL配置文件（my.ini），找到[mysqld]部分，进行以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql</span><br><span class="line">server-id=1  # 设置服务器ID  </span><br><span class="line">log_bin=mysql-bin  # 开启二进制日志  </span><br><span class="line">binlog_do_db=your_database_name  # 指定需要同步的数据库名</span><br></pre></td></tr></table></figure><p>重启MySQL服务，使配置生效。<br><strong>四、安装MySQL从服务</strong></p><p>下载与主服务器相同的MySQL版本，并解压安装包。<br>安装过程中，选择自定义安装，并注意勾选“启动为服务”。<br>完成安装后，使用管理员权限登录操作系统。<br><strong>五、配置MySQL从服务</strong></p><p>打开MySQL配置文件（my.ini），找到[mysqld]部分，进行以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql</span><br><span class="line">server-id=2  # 设置服务器ID，从服务器ID必须与主服务器不同</span><br></pre></td></tr></table></figure><p>重启MySQL服务，使配置生效。<br><strong>六、配置主从服务关系</strong></p><p>在主服务器上执行以下命令，创建一个用于复制的用户，并授权该用户对指定数据库进行复制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql</span><br><span class="line">CREATE USER &#x27;replication_user&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;  </span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;replication_user&#x27;@&#x27;%&#x27;;  </span><br><span class="line">GRANT SELECT ON your_database_name.* TO &#x27;replication_user&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>在主服务器上找到MySQL配置文件（my.cnf），找到[mysqld]部分，进行以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">relay_log=mysql-relay-bin  # 设置中继日志文件名</span><br></pre></td></tr></table></figure><p>重启MySQL服务，使配置生效。</p><p>在从服务器上执行以下命令，设置从服务器连接到主服务器并开始复制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql</span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;master_server_ip&#x27;, MASTER_USER=&#x27;replication_user&#x27;, MASTER_PASSWORD=&#x27;password&#x27;, MASTER_LOG_FILE=&#x27;mysql-bin.XXXXXX&#x27;, MASTER_LOG_POS=XXXX;  </span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure><p>将上述命令中的’master_server_ip’、’replication_user’、’password’、’mysql-bin.XXXXXX’和’XXXX’替换为实际值。</p><p>重启从服务器，使配置生效。<br>现在，MySQL主从服务已经配置完成。<br>通过验证从服务器的复制状态，确保主从服务正常工作。<br>本笔记主要是MySQL主从服务的安装与配置过程。正确配置主从服务能够提高数据安全性、读写性能和容灾能力。</p><p><strong>在安装和配置MySQL主从服务时可能遇到的问题及其解决方法：</strong></p><p><strong>问题：</strong>在主服务器上创建复制用户时，无法使用’%’通配符。<br><strong>解决方法：</strong>使用具体的IP地址代替’%’通配符，如‘replication_user‘@’192.168.0.1’。</p><p><strong>问题：</strong>在从服务器上执行CHANGE MASTER TO命令时，无法连接到主服务器。<br><strong>解决方法：</strong>确保主服务器允许从服务器的访问，并检查主服务器的IP地址、用户名和密码是否正确。</p><p><strong>问题：</strong>在从服务器上执行START SLAVE命令后，复制进程无法启动。<br><strong>解决方法：</strong>检查主从服务器的配置文件是否正确，并确保主服务器正在生成新的二进制日志文件。</p><p><strong>问题：</strong>在从服务器上复制进程启动后，出现错误或中断。<br><strong>解决方法：</strong>检查主从服务器的日志文件，查找复制相关的错误信息。可能的原因包括网络问题、配置错误、权限问题等。</p><p><strong>问题：</strong>主从服务器之间的同步出现延迟。<br><strong>解决方法：</strong>增加sync_binlog参数的值，以增加二进制日志文件的同步频率。还可以检查网络延迟和从服务器的处理能力。</p><p>以上是一些常见问题和可能的解决方法。实际操作中还可能遇到其他问题，需要根据具体情况进行排查和解决。</p><p><strong>在MySQL主从服务中设置白名单以限制非授权的访问：</strong></p><p>修改MySQL配置文件：</p><p>打开主服务器的MySQL配置文件（my.cnf或my.ini），根据所使用的操作系统和MySQL版本，找到[mysqld]部分。<br>在该部分中添加或修改以下内容，以允许白名单配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csharp`bind-address = 127.0.0.1  # 限制主服务器只接受本地访问  </span><br><span class="line">skip-networking  # 禁用远程访问`</span><br></pre></td></tr></table></figure><p>同样，打开从服务器的MySQL配置文件，并执行相同的修改。<br>创建授权表：</p><p>在主服务器上执行以下命令，创建一个用于授权访问的用户，并授予该用户对指定数据库的访问权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql`CREATE USER &#x27;white_list_user&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;  </span><br><span class="line">GRANT SELECT, INSERT, UPDATE, DELETE ON your_database_name.* TO &#x27;white_list_user&#x27;@&#x27;%&#x27;;  </span><br><span class="line">FLUSH PRIVILEGES;`</span><br></pre></td></tr></table></figure><p>将’white_list_user’和’password’替换为实际的用户名和密码，将your_database_name替换为要授权访问的数据库名称。</p><p>设置主从复制用户：</p><p>在主服务器上创建一个用于复制的用户，并授权该用户对指定数据库进行复制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql`CREATE USER &#x27;replication_user&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;  </span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;replication_user&#x27;@&#x27;%&#x27;;  </span><br><span class="line">GRANT SELECT ON your_database_name.* TO &#x27;replication_user&#x27;@&#x27;%&#x27;;  </span><br><span class="line">FLUSH PRIVILEGES;`</span><br></pre></td></tr></table></figure><p>请将’replication_user’和’password’替换为实际的用户名和密码，将your_database_name替换为要同步的数据库名称。</p><p>重启主从服务器：</p><p>重启主服务器以使配置更改生效。<br>重启从服务器以使配置更改生效。<br>现在，已经在MySQL主从服务中设置了白名单以限制非授权的访问。<br>只有通过授权的用户才能访问指定的数据库。<br>需要注意，白名单配置将限制所有非授权的远程访问，包括从服务器对主服务器的访问。<br>如果需要从服务器能够访问主服务器进行复制，要确保授权表中包含从服务器的IP地址或主机名。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近做了一次数据库的主从配置管理，把其中的主要操作的技术点还有过程中可能会遇到的问题在此记录一下，以备后需。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="https://longchao012.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>RPA与敏捷开发方法</title>
    <link href="https://longchao012.github.io/2022/09/17/RPA%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/"/>
    <id>https://longchao012.github.io/2022/09/17/RPA%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/</id>
    <published>2022-09-17T09:23:58.000Z</published>
    <updated>2023-09-06T06:51:03.729Z</updated>
    
    <content type="html"><![CDATA[<p>  与传统自动化相比，RPA（Robotic Process Automation）不仅易于使用且实施成本更低，成效明显。据数据显示，RPA可以将运营成本平均降低25-50%。随着RPA与AI、流程挖掘等技术的融合，应用场景不断增多，使得RPA成为企业追捧的自动化技术。然而，RPA存在脆弱性挑战业务流程稳定性的问题。为防止拓展RPA带来的挑战和失败，一些有想法的杰出人士采用敏捷方法来实施和推动自动化计划。实践证明，敏捷方法使RPA在业务中获得更好的治理、更灵活的扩展能力、效率和降低成本，减轻实施风险和返工。因此，敏捷方法实话的RPA成为一种更高效的RPA应用与实施方法结合架构。</p><span id="more"></span><p><strong>从敏捷开发说起</strong><br>在软件开发领域，传统的瀑布模型需要很长时间才能完成整个流程，而且风险高、难以应对变化。于是，2001年17位知名开发人员聚集在一起讨论替代瀑布模型的新方法，最终形成了敏捷宣言和敏捷联盟。</p><p>敏捷开发是一种“轻量级”的迭代模型，强调协作和即时性，增加客户参与度，并将软件开发从面向过程转变为面向对象。它与瀑布模型有着明显的区别。</p><p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。它将一个大项目分为多个相互联系的小项目（冲刺），并在整个项目生命周期中不断评估需求、计划和结果，使变更成为流程的有机组成部分。</p><p>总之，敏捷开发旨在解决瀑布模型存在的问题，用一种轻量、敏捷的方法来改善或替代传统的重型软件开发方法。</p><p>敏捷开发的核心价值观强调个体和互动优于流程和工具，工作的软件高于详尽的文档，客户合作高于合同谈判，响应变化高于遵循计划。这些价值观重视协作和即时性，增加客户参与度，并将软件开发从面向过程转变为面向对象。</p><p>在敏捷开发中，软件项目被切分成多个子项目，每个子项目都经过测试，具备可视、可集成和可运行使用的特征。这意味着一个大项目被分为可独立运行的小项目，并且在整个项目生命周期中不断评估需求、计划和结果，使变更成为流程的有机组成部分。</p><p>与传统的瀑布模型相比，敏捷开发更加灵活和适应变化。它侧重于快速交付有价值的软件，通过持续反馈和迭代改进来满足客户需求。敏捷开发能够更好地应对市场和技术的变化，提高项目的成功率和效率。</p><p>总而言之，敏捷开发是一种注重协作、适应性和客户参与的软件开发方法。它通过迭代和循序渐进的方式，将大型项目分解为小而可行的增量，以提供更快速、高质量且符合客户需求的软件产品。<br><img src="/images/RPA%E4%B8%8E%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95.jpg" alt="docker安装"></p><p><strong>敏捷RPA与敏捷交付</strong><br>虽然很多RPA开发者没有编程基础，但他们也参与了软件开发过程，所以仍然需要遵守一定的开发逻辑。与传统软件开发不同，RPA和技术简化了程序开发过程，因此更加注重交付。由于对自动化和开发平台的理解不同，不同业务线开发的自动化程序在逻辑上会有一些差异，可能会降低稳定性并增加脆弱性。</p><p>大量的业务人员并行开发会导致大量的自动化程序。这些程序能否高质量交付，或者如何保障高效交付，成为自动化程序交付的主要问题。现在敏捷开发已成为主流，受到主流RPA厂商的影响，RPA也在摒弃传统的瀑布式开发模式，向敏捷开发靠拢。这诞生了敏捷RPA（Agile RPA）。</p><p>敏捷RPA不是一个过程，而是一种价值观。它通过一些轻量级流程框架和操作技术的支持，帮助RPA团队将这种价值观付诸实践。执行敏捷开发和成为敏捷组织是有区别的：前者关注过程和技术，后者则由敏捷原则和价值观指导行为。</p><p>敏捷交付是迭代式和增量式交付的组合。为实现某个业务流程的自动化进行的增量交付可能意味着一个接一个地自动化一些流程组件。而迭代交付则意味着以低保真度自动化所有流程组件，然后逐渐提高其自动化保真度，并自动化其他流程组件和下一个版本。</p><p>在敏捷RPA交付中，关键是经常生产“工作机器人”，为利益相关者创造价值的最终自动化业务流程的子集。需要注意的是，在敏捷RPA交付中，没有什么是真正被认为是最终的，因为可以在功能、性能、可靠性、稳定性、安全性、可用性等方面不断拓展自动化。因此，敏捷RPA交付的目标不是要完美，而是要逐渐减少无意义的开发行为。</p><p><strong>为什么RPA需要敏捷方法?</strong></p><p>根据调查数据，78%的实施了RPA的公司预计在未来3年内增加投资。但是只有很少的公司能够将RPA扩展到初始试点之外。维护工作是阻止公司扩展RPA的主要原因之一。导致机器人中断运行并持续投入维护的三个主要原因是自动化本身的问题、应用程序问题和环境问题。<br>在当前的技术环境中，机器人流程自动化（RPA）已经成为了许多企业日常运营的重要部分。然而，有时候我们可能会遇到RPA机器人中断运行并需要持续投入维护的情况。这种情况的出现可能由多种原因引起，以下将详细解析其中的三个主要原因：</p><ul><li><p><strong>1. 自动化本身的问题</strong><br>首先，自动化本身的问题也是导致RPA机器人中断运行的一个重要原因。这可能包括程序设计错误、算法问题、或者是系统内部的错误。例如，如果一个RPA机器人被编程为在特定的条件下执行某个任务，但是这个条件在某些情况下并不满足，那么机器人就可能会中断运行。此外，如果RPA机器人的算法存在缺陷或者设计不合理，也可能导致其无法正常运行。这些问题通常需要开发者对RPA机器人进行详细的检查和修复。</p></li><li><p><strong>2. 应用程序问题</strong><br>其次，应用程序问题也是导致RPA机器人中断运行的一个重要因素。这可能涉及到应用程序的稳定性、兼容性以及与RPA机器人的交互性等问题。例如，如果RPA机器人正在运行的应用程序发生了严重的错误或者崩溃，那么RPA机器人可能也会因此中断运行。此外，如果应用程序与RPA机器人的接口设计不合理，或者存在难以预料的交互问题，也可能使RPA机器人无法正常工作。解决这类问题通常需要对应用程序进行深入的分析和调试。</p></li><li><p><strong>3. 环境问题</strong><br>最后，环境问题也可能是导致RPA机器人中断运行的一个重要原因。这可能包括硬件故障、网络问题、或者是系统资源不足等。例如，如果RPA机器人所在的服务器发生故障，或者网络连接不稳定，那么RPA机器人可能就无法正常运行。此外，如果系统资源（如内存、CPU或磁盘空间）不足，也可能导致RPA机器人无法正常运行。解决这类问题通常需要对环境进行全面的检查和优化。</p></li></ul><p>如果忽视这些问题，RPA项目可能会失败或者无法实现更高的ROI。事实上，已经上线几个月后需要重新设计的RPA项目并不少见，因为不可预见的问题引发了RPA实施的复杂性。如果这些项目在立项之初就能遵循敏捷原则，可以避免很多问题不至于重新设计。</p><p>对于RPA项目而言，敏捷方法有很多好处。首先，敏捷方法要求创建跨职能团队，打破孤岛并促进业务&#x2F;IT协调，这是 RPA 成功的必要条件。其次，RPA相当脆弱，对变化反应不佳。与传统方法不同，敏捷方法为实施后的持续、迭代更改和升级留出了更多空间。第三，敏捷提供了在整个企业中扩展RPA和智能自动化所需的治理框架。在这些场景中，组织可以采用类似工厂的方法来实施由可重用组件、工作流、标准和指南、工具和参考实施组成的 RPA。这种方法不仅成本高、劳动效率高，而且还能带来更高质量和更安全的 RPA 应用程序。</p><p>RPA的目标是通过消除重复的、低价值的任务以增强人类工作体验，因此它必须与最终用户共同实施。这个逻辑，与敏捷方法鼓励的尽早并经常与利益相关者密切合作不谋而合。此外，RPA的开发难度正在降低，使敏捷开发更加可行。</p><p><strong>敏捷开发方法怎样让RPA项目更成功?</strong></p><p>RPA与纯软件和产品开发有很大不同，但是可以借鉴和应用基本的敏捷原则来产生相同的结果：更快地交付价值，同时降低成本和风险。</p><p>流程不是产品，不能与纯软件开发相同的方式开发和部署，因此敏捷RPA不能遵循敏捷Scrum框架（迭代式增量软件开发过程，敏捷方法论中的重要框架之一）里的每一条原则。</p><p>但是，敏捷Scrum方法的各种元素可以为有远见的组织提供更多红利，大家可以借鉴敏捷开发的方法与逻辑，加速规模并建立RPA卓越中心（CoE）以及相似的组织，以保障自动化能够更高效的助力企业提质增效降本。</p><p>敏捷方法，至少可以让组织在RPA实施过程中做到以下几点：</p><ul><li><p><strong>更懂协作的团队。</strong>RPA 的敏捷方法包含一个由不同利益相关者组成的专门团队，他们紧密合作，包括开发人员、测试人员和业务角色。这不仅增强了识别 RPA 机会的有效性，而且还促进了大规模治理，因为专门的团队可以更好地管理和协调影响业务和运营不同部分的自动化流程。</p></li><li><p><strong>更优质的设计和定义。</strong>在机器人流程自动化的敏捷方法中，业务流程在任何开发开始之前就被设计和优化。这使大型组织能够完全标准化和优化端到端、复杂和多层的业务流程，成为真正的自动化投资回报率所在。</p></li></ul><p>它还为他们提供了宝贵的机会来考虑这些流程并将其与更大的业务目标和企业或监管约束、政策和控制联系起来。</p><p>自动化基本的战术流程要简单得多，但从长远来看，其价值回报率也会显着降低。大规模阻碍 RPA 的主要障碍是自动化更复杂的流程并确保透明有效地遵守法规。促进预先定义和设计以确保优化和法规遵从性的方法极大地使有意愿的企业能够克服这一挑战</p><ul><li><strong>更高效的积压维护。</strong>要扩展 RPA，机器人必须变得更大、更复杂。积压工作能够让组织将复杂的端到端流程分割成多个工作项或故事，并将它们作为积压工作独立地确定优先级。</li></ul><p>积压也是有效管理机器人维护的关键。随着许多机器人和不断发生的变化，维护工作可能会消耗积压并扼杀提供价值和创新的新项目。因此，有组织的优先排序方法至关重要。</p><ul><li><strong>冲刺计划和回顾。</strong>与在项目开始时定义的时间表不同，计划短暂的工作突增或冲刺使团队能够在出现需要解决的问题时重新确定工作的优先级。而不是在项目结束时意识到不对劲，导致返工并因此增加成本。</li></ul><p>Sprint回顾还可以使团队能够随着工作的进展吸取经验教训，并将其融入整个 RPA 工作中，进而避免在下游犯下相同的错误并及时实施良好实践。</p><p><strong>后记：因人而异择优而选</strong></p><p>看到这里，大家应该对敏捷RPA有了一定的了解。关于敏捷RPA，很多人看完可能会感觉非常复杂。其实想要实现敏捷RPA也很简单，就是建立RPA卓越中心，然后告诉RPA CoE管理者要引入敏捷方法，并坚定不移的支持其工作就可以了。</p><p>但说起来容易做起来难，因为要改变大型组织固有的IT组织架构及开发逻辑，着实是一个难上加难的问题。</p><p>所以，这篇文章的用意，并不是告诉大家在RPA建设与应用上一定要严格遵守敏捷方法，而是说在RPA引入时可以适当参考敏捷方法，以避免在后面的RPA应用中出现太多问题而导致项目搁浅，同时也为基于自动化获得更高的ROI打下更好的基础。</p><p>同时大家也应该知道，每个组织的信息化程度不同，IT建设情况不同，程序开发的理念也不同，这就决定了不是每个组织都适合采用敏捷方法进行各种项目开发。</p><p>敏捷RPA交付有许多好处，但它也带有敏捷方法固有的某些风险。因此敏捷方法并不适合每个组织，这取决于组织的情况以及如何下定决心克服困难去采用敏捷。如果参与RPA交付的人员不愿意紧密协作，很可能以敏捷的方式工作会成为一场IT与流程变革的灾难。</p><p>所以，在敏捷方法与RPA项目上，不要将敏捷实践和原则强加给那些不愿采用敏捷的人，只需要给人们正确的信息让他们说服自己。</p><p>也不要试图说服别人，只需要告诉并解释敏捷能够带来了什么就可以了。</p><p><strong>剩下的，全部交给决策者。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;  与传统自动化相比，RPA（Robotic Process Automation）不仅易于使用且实施成本更低，成效明显。据数据显示，RPA可以将运营成本平均降低25-50%。随着RPA与AI、流程挖掘等技术的融合，应用场景不断增多，使得RPA成为企业追捧的自动化技术。然而，RPA存在脆弱性挑战业务流程稳定性的问题。为防止拓展RPA带来的挑战和失败，一些有想法的杰出人士采用敏捷方法来实施和推动自动化计划。实践证明，敏捷方法使RPA在业务中获得更好的治理、更灵活的扩展能力、效率和降低成本，减轻实施风险和返工。因此，敏捷方法实话的RPA成为一种更高效的RPA应用与实施方法结合架构。&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA办公自动化" scheme="https://longchao012.github.io/tags/RPA%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>国家电网某超高压变电公司RPA案例分享</title>
    <link href="https://longchao012.github.io/2022/09/11/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%E6%9F%90%E8%B6%85%E9%AB%98%E5%8E%8B%E5%8F%98%E7%94%B5%E5%85%AC%E5%8F%B8RPA%E6%A1%88%E4%BE%8B%E5%88%86%E4%BA%AB/"/>
    <id>https://longchao012.github.io/2022/09/11/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%E6%9F%90%E8%B6%85%E9%AB%98%E5%8E%8B%E5%8F%98%E7%94%B5%E5%85%AC%E5%8F%B8RPA%E6%A1%88%E4%BE%8B%E5%88%86%E4%BA%AB/</id>
    <published>2022-09-11T09:02:31.000Z</published>
    <updated>2023-09-05T09:07:27.029Z</updated>
    
    <content type="html"><![CDATA[<p>“传统人工核对处理1000笔业务需耗时约33小时，而‘机器人员工’仅需2小时即可自动完成付款记录稽核，效率提升了16倍！”国网某超高压变电公司财务负责人，亲眼见证了RPA机器人快速高效完成资金支付配比工作后，给予了RPA项目工作成果极积极的肯定。</p><p>超高压变电公司紧盯公司发展热点、痛点、难点问题，利用RPA机器人着手打造管理现代化，人尽其才、物尽其用，人员分工合理的智能型班组。为推动RPA团队成员迅速成长，该公司组织业务管理部门和生产单位的业务骨干36人集体学习RPA，组成公司RPA兴趣小组，梳理完成关于生产、财务、人资、党建等RPA工作流程12条。</p><p>有了学习做基础，该公司找准日常工作和专项工作需求，结合该公司业务痛点，开发自动化流程工具，自主研发运维、人资、财务等专业RPA机器人。</p><span id="more"></span><p><strong>01薪酬核算 释放双手业务更高效</strong><br>对于人力资源管理专业，工资核算发放是一项固定、重复、繁琐的工作，涉及每一位员工切身利益，需要为每一位员工精准服务。RPA“工资”机器人通过连接本地文件、ERP系统、内网邮箱系统，从工资核算资料收集，到工资系统精准核算，到员工工资，再到财务核对，实现工资核算发放全流程服务，每月仅这一项流程就可以节约至少4个工作日的工作量。因此，RPA机器人的推广应用，将是服务人力资源管理向更高质量发展的重要帮手。</p><p>9月9日，公司人资部在完成9月全员工资核算过账后，薪酬专责感慨道：“原来仅仅是整理资料、上传系统、ERP核算、账务过账等工作就至少需要3—4个工作日才能完成，而且在处理大量数据的时候还容易出现丢失、错漏等问题。现在通过薪酬核算RPA机器人，仅用不到半天的时间就可以完成以上工作，而且还不会出现低级错误。真是薪酬管理的得力助手！”</p><p>目前，财务“机器人虚拟员工”上岗后，在提高工作效率方面表现非常出色。财务人员在处理往来账款清理时，原先每月人工清理账款条目大概是2300条，需要人工16个小时，使用财务“机器人虚拟员工”后只需2个小时，效率提升了8倍。极大地减少了工作量，提升了员工工作体验，释放了劳动力，让有经验的财务人员可以从事更加专业的财务管理工作。</p><p><strong>02数字赋能 巡检业务事半功倍</strong><br>“日比对、周分析、月总结”，是变电站运维中发现隐患、消除问题的重要手段。过去，各类数据繁多，且服务器相互独立，人工执行效率低，数据挖掘深度浅，数字化赋能运维迫在眉睫。</p><p>运维人员通过梳理工作流程，建成RPA“数字化员工”机器人。RPA机器人工作灵活、高效、稳定，运行过程安全无侵入，直接为每座变电站减少3人次&#x2F;站&#x2F;天的劳动力，全年每座变电站可以节约100万元左右的人工成本。</p><p>RPA“数字化员工”机器人，还可以安全高效地打通各级数据服务器通道，并将安全隐患排查和故障分析与AI算法结合，可以快速推进变电站运维数字化转型，为实现真正的无人值守打下基础。</p><p><strong>03精益管理 助力数字财务建设</strong><br>国网山西超高压变电公司为建设智慧财务，全面深入梳理了财务业务存在的问题，挖掘日常工作和专项工作要求，自主研发，成功打造了一名财务“机器人虚拟员工”。通过模拟财务人员与计算机的交互，配置相应的流程化核对执行规则，这位“机器人虚拟员工”就可以替代财务人员完成大批量重复性的工作，全面提升财务工作的效率与质量。</p><p>未来，国网山西超高压变电公司数字化业务骨干，将加速推进已开发业务场景的全面推广，进一步释放数字化赋能信息运行一线效应，促进信息运行RPA技术应用在基层全面落地。以保障信息系统安全稳定运行为基石，发挥数字技术和数据要素的创新驱动作用，促进生产经营“双轮”数字转型。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;“传统人工核对处理1000笔业务需耗时约33小时，而‘机器人员工’仅需2小时即可自动完成付款记录稽核，效率提升了16倍！”国网某超高压变电公司财务负责人，亲眼见证了RPA机器人快速高效完成资金支付配比工作后，给予了RPA项目工作成果极积极的肯定。&lt;/p&gt;
&lt;p&gt;超高压变电公司紧盯公司发展热点、痛点、难点问题，利用RPA机器人着手打造管理现代化，人尽其才、物尽其用，人员分工合理的智能型班组。为推动RPA团队成员迅速成长，该公司组织业务管理部门和生产单位的业务骨干36人集体学习RPA，组成公司RPA兴趣小组，梳理完成关于生产、财务、人资、党建等RPA工作流程12条。&lt;/p&gt;
&lt;p&gt;有了学习做基础，该公司找准日常工作和专项工作需求，结合该公司业务痛点，开发自动化流程工具，自主研发运维、人资、财务等专业RPA机器人。&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA办公自动化" scheme="https://longchao012.github.io/tags/RPA%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>RPA流程如何选择--四个考虑的基本点</title>
    <link href="https://longchao012.github.io/2022/09/10/RPA%E6%B5%81%E7%A8%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9--%E5%9B%9B%E4%B8%AA%E8%80%83%E8%99%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%82%B9/"/>
    <id>https://longchao012.github.io/2022/09/10/RPA%E6%B5%81%E7%A8%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9--%E5%9B%9B%E4%B8%AA%E8%80%83%E8%99%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%82%B9/</id>
    <published>2022-09-10T08:01:57.000Z</published>
    <updated>2023-09-05T08:19:04.405Z</updated>
    
    <content type="html"><![CDATA[<p>RPA 成功的最关键决定因素之一就是是否选择了合适的用例场景。而  RPA 项目的最大挑战是识别适合RPA的业务流程并确定其优先级，因为它们需要业务流程知识和技术专长。CIO、CTO应该用稳定性、可预测性、范围和复杂性参数测试他们的用例，以确定和选择最适合 RPA 的用例。<br>以下是我在给客户做场景分析和业务流程评估时所用到的一些分析角度，以供大家参考。</p><span id="more"></span><p><strong>一、稳定性和可预测性</strong></p><ul><li><p><strong>（一）评估维度：</strong></p><ul><li><p>1、您的备选流程是什么样的？</p><ul><li><p>A、稳定的？</p></li><li><p>B、标准化？</p></li><li><p>C、可预测的？</p></li></ul></li><li><p>2、在明天甚至一个月或一年后，您还会用和现在相同的方式执行任务吗？</p></li><li><p>3、这个流程会不会将要发生任何重大的变化？</p></li><li><p>4、流程是惯例的一部分吗？</p></li><li><p>5、该过程是否涉及主观决策？</p></li><li><p>6、整个流程都有流程图吗？</p></li></ul></li><li><p><strong>（二）用例选择和优先级指南</strong></p><ul><li><p>1、通过优先处理以下流程，您可以优化您的 RPA 构建工作：</p><ul><li><p>A、稳定且有条理  </p></li><li><p>B、所有的场景基本上都能适用  </p></li><li><p>C、基于规则  </p></li><li><p>D、没有重大的主观决策</p></li></ul></li></ul></li></ul><p><strong>二、体量和规模</strong></p><ul><li><p><strong>（一）评估维度：</strong></p><p>  1、需要实现自动化的流程的体量和频率是怎样的？</p><p>  2、自动化是否会直接节约成本、增加收入和规避风险？</p><p>  3、流程是孤立的还是企业流程的一部分？</p></li><li><p><strong>（二）用例选择和优先级指南</strong></p><p>  1、您可以通过选择涉及更多 正式员工的大批量和标准化流程来扩大您对自动化单位成本的收益。</p><p>  2、您可以列出潜在的效益。</p></li></ul><p><strong>三、范围</strong></p><ul><li><p><strong>（一）评估维度：</strong></p><p>  1、您的用例是否足够细化？</p><p>  2、您可以在逻辑上把这个过程分解成不同的部分吗？</p></li><li><p><strong>（二）用例选择和优先级指南</strong></p><p>  1、使您能够有策略地进行进一步的计划。</p><p>  2、作为 RPA 路线图的基础</p></li></ul><p><strong>四、复杂性</strong></p><ul><li><p><strong>（一）评估维度：</strong></p><p>  1、在 1 到 10 的范围内，要自动化的过程有多复杂？更多数量的业务逻辑步骤等同于更高的复杂性，因此首先寻找不太复杂的流程。</p><p>  2、有多少种类型的应用程序需要访问？</p><p>  3、这个流程有多少步骤？</p><p>  4、机器人与它交互多少次，应用平台的UI会发生改变吗？</p><p>  5、机器人会执行图像抓取等复杂任务吗？</p><p>  6、目标环境或涉及到的软件是部署在虚拟机还是实体机上面？</p><p>  7、有充分的测试环境吗？</p></li><li><p><strong>（二）用例选择和优先级指南</strong></p><ul><li><p>1、在理想情况下，对于一个不太复杂的用例，它必须：</p><ul><li><p>A、流程步骤不超过 20 个  </p></li><li><p>B、 涉及机器人将接触的应用平台不超过三个  </p></li><li><p>C、 拥有不经常更改的 Ul 和流程</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;RPA 成功的最关键决定因素之一就是是否选择了合适的用例场景。而  RPA 项目的最大挑战是识别适合RPA的业务流程并确定其优先级，因为它们需要业务流程知识和技术专长。CIO、CTO应该用稳定性、可预测性、范围和复杂性参数测试他们的用例，以确定和选择最适合 RPA 的用例。&lt;br&gt;以下是我在给客户做场景分析和业务流程评估时所用到的一些分析角度，以供大家参考。&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA办公自动化" scheme="https://longchao012.github.io/tags/RPA%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>常见的RPA项目错误及其教训</title>
    <link href="https://longchao012.github.io/2022/09/03/%E5%B8%B8%E8%A7%81%E7%9A%84RPA%E9%A1%B9%E7%9B%AE%E5%A4%B1%E8%B4%A5%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%85%B6%E6%80%BB%E7%BB%93/"/>
    <id>https://longchao012.github.io/2022/09/03/%E5%B8%B8%E8%A7%81%E7%9A%84RPA%E9%A1%B9%E7%9B%AE%E5%A4%B1%E8%B4%A5%E7%BB%8F%E9%AA%8C%E5%8F%8A%E5%85%B6%E6%80%BB%E7%BB%93/</id>
    <published>2022-09-03T06:10:47.000Z</published>
    <updated>2023-09-05T07:57:35.759Z</updated>
    
    <content type="html"><![CDATA[<p>很多公司的领导听说了RPA办公自动化(RPA)的功能与效果之后，就尝试去使用，并以为他们团队肯定能够解决编写与执行过程中遇到的问题。虽然现在看来这种想法是错误的，但确实有人这样做了。<br>RPA通常被说为一种快速、简单和用户友好地利用自动化的方法，即使没有编码经验。从理论上讲，机器人所需要做的就是模拟人的操作过程和步骤的任务。但在实践中，但是给它一个看似简单的流程运行过程中往往在很多方面都出错了。结果就是尝试了使用过RPA，但失败了，然后很自然的将其搁置，然后工作又回到到之前的旧的手动流程。</p><p>下面，让我们来聊聊一些常见的RPA项目经验和其所能带来的增长。</p><span id="more"></span><ul><li><strong>一、没有制定好战略</strong></li></ul><p>RPA听起来好像是个轻松实现自动化的好方法，但是研究发现，80%的公司需要有高级编程能力的人才能推动RPA项目进行。</p><p>有个公司的高级开发人员解释说：“RPA工具被宣传为低代码平台，这让领导们以为业务用户能自己开发出完善的解决方案。其实RPA不需要太多编码，但是得设计算法，而且还需要一个框架。”</p><p>虽然RPA受到了媒体的热捧，但它并不总是最有效的自动化方式。如果你只看到低代码的厂家广告就决定要搞RPA，然后开始布局公司的自动化策略，可能会得到一些不理想的结果。最让人失望的是，对于想要自动化的流程，RPA可能并不是最好的解决方案。在很多情况下，API集成会提供更好的效果，因为它可以从后端连接系统，而不需要训练机器人或故障排除。</p><p>另外，如果没有制定好策略，可能会导致无法获得期望的ROI（投资回报率）。例如，小型团队中的数据输入自动化可以节省时间。但是，当你考虑到购买RPA授权费用、实现自动化和管理工作流程的成本时，它可能就不划算了。</p><p>所以，我们要明白一点：RPA不是可以随便买的东西。实际上，成功实施任何形式的自动化都需要一个清晰的策略、预测和计划。好消息是，RPA非常灵活。虽然它可能不适合最初想要自动化的流程，但在其他业务领域可能非常有用。我们还会发现，通过混合使用不同形式的自动化，可以更好地利用软件机器人。这样不仅可以大大提高公司的ROI，还可以保证自动化的扩展性。</p><ul><li><strong>二、假设任何员工都能建好RPA工作流程</strong></li></ul><p>在这里，RPA的高可用高效率低故障的表现让企业领导相信，任何拥有自动化任务的员工都能成功使用RPA软件机器人提高自己的工作效率。</p><p>就像某公司的CEO说的那样，这种情况很少会发生。“根据我们的经验，当把RPA工具授权交到员工手中，除非有实际的工作任务，不然是不会经常使用的。和任何软件一样，尤其是那些有很多技术细节的软件，RPA需要大量的投入和学习才能熟练使用。”</p><p>我们相信人人都有能力成为开发者。但现实是，要快速有效地开发RPA，需要一定的编程技能（或者至少是编程思维）。而足够的耐心和逻辑思维能力则是RPA成功的关键。业务专家可能会花时间研究流程的技术细节，甚至会被这种“无需编码”的工作方式吸引。这样的高知将能够快速有效地使用RPA工作流程，还能确保其稳定可靠地执行。</p><ul><li><strong>三、没有意识到RPA的局限性</strong></li></ul><p>RPA对于自动化单调的、容易出错的和耗时的任务是一个出色的解决方案。然而，它并不能承担公司数字化转型的全部重量。例如，机器人可以连接系统、读取注册表、填写数据，然后向客户发送邮件。但是，你给机器人的任务越复杂，它需要服务的部门越多，引入的自动化过程中的潜在故障点就会越多。</p><p>虽然软件机器人可能是实现特定过程自动化的理想解决方案，但也必须认识到RPA只是众多强大的团队工作贡献者之一。传统软件升级和采用混合方法实现自动化是成功数字化转型的两个最坚实的基础。</p><ul><li><strong>四、过早放弃RPA</strong></li></ul><p>说到RPA，许多人认为它一旦被构建和训练，它就会在无需监控的情况下自主运行。虽然RPA可以自主工作，但如果认为它们是一种一劳永逸的解决方案，那么当机器人没有达到这一理想状态时，就会让人感到失望。通常，暂时的挫折和永久的失败之间的唯一区别就是您选择停止尝试。</p><p>就像人类一样，机器人也需要训练，但当它们遇到训练中没有涉及的场景时，它们不能像人类那样运用抽象思维或归纳推理来解决问题。相反，它们需要一套新的规则来克服这个业务上的挑战。为了确保公司对RPA的期望不会过高，把每个机器人看作是严格遵守规则的工作者是很有帮助的。</p><p>虽然全面的RPA策略可以帮助企业预测和计划许多潜在的障碍，但公司的新数字员工在达到最高绩效之前可能需要一些额外的关注和调整。如果不能认识到这一点，当机器人只是需要一些额外的帮助时，公司可能会放弃RPA项目。</p><ul><li><strong>五、RPA是战略自动化的强大盟友</strong></li></ul><p>RPA被宣传为一种简单易用、用户友好的自动化形式。虽然在很多方面确实如此，但是对于普通用户来说，往往只有在熟练掌握技术的人员规划和实施了量身定制的自动化策略后才会真正发挥作用。RPA可能是这一战略的核心，但在很多情况下，作为更详尽的混合自动化方法的一部分实现时，它可以带来更好的结果。</p><p>超自动化是一种可扩展的方法，让您先解决最紧迫的问题，同时专注于更大的目标。即使是单独引入自动化解决方案，它也具有与其他流程集成的能力，能够帮助公司在业务中提高效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多公司的领导听说了RPA办公自动化(RPA)的功能与效果之后，就尝试去使用，并以为他们团队肯定能够解决编写与执行过程中遇到的问题。虽然现在看来这种想法是错误的，但确实有人这样做了。&lt;br&gt;RPA通常被说为一种快速、简单和用户友好地利用自动化的方法，即使没有编码经验。从理论上讲，机器人所需要做的就是模拟人的操作过程和步骤的任务。但在实践中，但是给它一个看似简单的流程运行过程中往往在很多方面都出错了。结果就是尝试了使用过RPA，但失败了，然后很自然的将其搁置，然后工作又回到到之前的旧的手动流程。&lt;/p&gt;
&lt;p&gt;下面，让我们来聊聊一些常见的RPA项目经验和其所能带来的增长。&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA办公自动化" scheme="https://longchao012.github.io/tags/RPA%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python入门的19个基础语法</title>
    <link href="https://longchao012.github.io/2022/09/02/Python%E5%85%A5%E9%97%A8%E7%9A%8419%E4%B8%AA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://longchao012.github.io/2022/09/02/Python%E5%85%A5%E9%97%A8%E7%9A%8419%E4%B8%AA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-09-02T03:40:06.000Z</published>
    <updated>2023-09-04T06:51:32.373Z</updated>
    
    <content type="html"><![CDATA[<p>最近堂妹要学Python给她写了些Python基础的语法入门，在此做个总结记录。<br>Python简单易学，但又博大精深。<br>许多人号称精通Python，却不会写Pythonic的代码，对很多常用包的使用也并不熟悉。<br>ps:Pythonic是指代码遵循Python社区的惯例，并以其预期的方式使用该语言。Pythonic的代码不仅仅是语法正确，而是充分利用Python语言的特性来产生清晰、简洁和可维护的代码 。</p><p>学海无涯，我们先来了解一些Python中最基本的内容。</p><span id="more"></span><ul><li><p>Python的特点</p><ul><li><p>解释型语言，无需编译即可运行</p></li><li><p>提供了交互式命令行</p></li><li><p>基于对象的编程思想</p></li><li><p>跨平台和良好的兼容性，在Windows、Mac、Linux上都可运行</p></li><li><p>简单好用而且功能强大</p></li></ul></li><li><h2 id="01-中文编码"><a href="#01-中文编码" class="headerlink" title="01 中文编码"></a>01 中文编码</h2></li></ul><p>很多同学在打开数据时会遇上乱码问题，其原因是字符集的编码问题。Linux和Mac默认的编码集是UTF8，而Windows则是ASCII。如果数据编码的字符集，和你使用Python进行处理时所用的字符集不同，则会出现乱码问题。</p><p>另外，我个人的习惯是在Python代码的头部加入以下内容，其中第二行声明了使用UTF8字符集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding:utf8</span><br></pre></td></tr></table></figure><ul><li><h2 id="02-变量"><a href="#02-变量" class="headerlink" title="02 变量"></a>02 变量</h2></li></ul><p>Python中的变量可以看作是一个个容器，里面存放着我们需要使用到的值。</p><p>Python对变量名的要求和其他语言一样：可以包括英文、数字以及下划线，但不能以数字开头，区分大小写。 当然我推荐，变量名用纯英文就很好，并且取一些有意义的名称，便于自己理解每个变量的作用。</p><p>Python是一门弱类型的语言，在使用变量时无需声明其类型。Python中的变量包括以下几类：数值、字符串、列表、元组、字典。</p><ul><li><h2 id="03-数值"><a href="#03-数值" class="headerlink" title="03 数值"></a>03 数值</h2></li></ul><p>数值包括整型和浮点型，分别对应整数和浮点数，后者精度更高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 整型</span><br><span class="line">a = 1</span><br><span class="line"># 浮点型</span><br><span class="line">b = 2.1</span><br><span class="line">print a, b</span><br></pre></td></tr></table></figure><ul><li><h2 id="04-字符串"><a href="#04-字符串" class="headerlink" title="04 字符串"></a>04 字符串</h2></li></ul><p>字符串也就是我们经常接触到的文本，可以往里面放任意长度的内容，用单引号或双引号括起来。应当注意，中文以及中文符号只能出现在字符串內，如果在下面第三行中使用了中文输入法的逗号 ，Python将报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c =  Hello </span><br><span class="line">d =  你好 </span><br><span class="line">print c, d</span><br></pre></td></tr></table></figure><p>使用 + 可以拼接两个字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print c + d</span><br></pre></td></tr></table></figure><p>使用 len() 可以得到字符串的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print len( Hello World )</span><br></pre></td></tr></table></figure><p>使用切片可以访问字符串中的某个字符或某个片段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 位置下标从0开始</span><br><span class="line">c =  Hello World </span><br><span class="line"># 打印结果为H，下标为0表示第一个字符</span><br><span class="line">print c[0]</span><br><span class="line"># 打印结果为d，下标为负数表示从后往前数</span><br><span class="line"># 所以-1表示倒数第一个字符</span><br><span class="line">print c[-1]</span><br><span class="line"># 使用:返回一个片段，冒号前后分别为开始下标和结束下标</span><br><span class="line"># 包括开始下标，但不包括结束下标</span><br><span class="line"># 因此c[1:5]表示，返回下标从1到4的片段，即第二个到第五个字符</span><br><span class="line">print c[1:5]</span><br><span class="line"># 冒号前后的下标同样可以使用负数</span><br><span class="line"># 或者不提供，表示从最左端开始或一直到最右端</span><br><span class="line">print c[1:-1], c[:5], c[3:]</span><br></pre></td></tr></table></figure><ul><li><h2 id="05-列表"><a href="#05-列表" class="headerlink" title="05 列表"></a>05 列表</h2></li></ul><p>列表好比一条队伍，里面依次存放着多个变量。列表和字符串类似，但字符串中的每个元素都是字符，而列表中的每个元素可以是任意类型的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用[]定义一个空列表，使用append()向列表尾部添加一个元素</span><br><span class="line"># 如果要添加到首部，就用prepend()好了</span><br><span class="line">a = []</span><br><span class="line">a.append(1)</span><br><span class="line">a.append(2.1)</span><br><span class="line">a.append( Hello )</span><br><span class="line">print a</span><br></pre></td></tr></table></figure><p>使用 len() 可以获得列表的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print len(a)</span><br></pre></td></tr></table></figure><p>列表元素的按下标访问和赋值等操作，和字符串都是类似的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print a[1], a[-1]</span><br><span class="line">a[1] = 100</span><br><span class="line">print a</span><br></pre></td></tr></table></figure><p>使用 del 删除列表中的某个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del a[0]print a</span><br></pre></td></tr></table></figure><ul><li><h2 id="06-元组"><a href="#06-元组" class="headerlink" title="06 元组"></a>06 元组</h2></li></ul><p>元组和列表类似，唯一的不同是元组中的元素在初始化之后不能再更改，因此可以理解成一个只读的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 使用()定义一个元组a = (1, 2.1,  Hello )# 尝试修改元组中的元素会报错a[0] = 100</span><br></pre></td></tr></table></figure><ul><li><h2 id="07-字典"><a href="#07-字典" class="headerlink" title="07 字典"></a>07 字典</h2></li></ul><p>字典是一种极为重要的变量类型，使用一个key来访问相应的value，即一种键值对的数据形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 使用&#123;&#125;定义一个字典a = &#123;&#125;# 使用key来赋值valuea[ k1 ] = 1a[ k2 ] = 2.1a[ k3 ] =  Hello</span><br></pre></td></tr></table></figure><p>所以能够总结出字典和列表的不同。列表中的元素是有序对等的，所以是用下标来赋值和访问，而字典中的元素是无序的，所以是用key来操作相应value。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 使用&#123;&#125;定义一个字典a = &#123;&#125;# 使用key来赋值valuea[ k1 ] = 1a[ k2 ] = 2.1a[ k3 ] =  Hello</span><br></pre></td></tr></table></figure><p>使用 has_key() 判断字典中是否有某个key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print di.has_key( k4 )</span><br></pre></td></tr></table></figure><p>如果访问不存在的key，Python将会报错。在赋值的时候，如果key已经存在，则会用新的value覆盖已有的value。</p><ul><li><h2 id="08-注释"><a href="#08-注释" class="headerlink" title="08 注释"></a>08 注释</h2></li></ul><p>被注释的代码将不会运行，可以看作是写给自己和其他程序猿阅读的一些笔记和说明，提高代码可读性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 这里是单行注释   这里是很多行注释</span><br></pre></td></tr></table></figure><p>在Sublime中，选中需要注释的内容，按Ctrl+&#x2F;即可完成注释。</p><ul><li><h2 id="09-保留字符"><a href="#09-保留字符" class="headerlink" title="09 保留字符"></a>09 保留字符</h2></li></ul><p>在Python中，有一些字符串具有某些特定功能，如 import 、 class 等。我们在选择变量名时，应注意避开这些保留字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以下变量赋值将报错</span><br><span class="line">import = 1</span><br></pre></td></tr></table></figure><ul><li><h2 id="10-行和缩进"><a href="#10-行和缩进" class="headerlink" title="10 行和缩进"></a>10 行和缩进</h2></li></ul><p>在Python中，代码块的边界不是通过大括号等符号进行显式划分，而是通过行的缩进实现的。连续相同缩进水平的代码处于同一个代码块，在使用 for、while、if 、try等语法时需要注意每行代码的缩进。</p><ul><li><h2 id="11-运算符"><a href="#11-运算符" class="headerlink" title="11 运算符"></a>11 运算符</h2></li></ul><p>运算符的作用是根据已有的变量生成新的变量，主要有以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">算术运算符：+，-，*，/，%，即加、减、乘、除、取余</span><br><span class="line"></span><br><span class="line">比较运算符：==，!=，&gt;，&lt;，&gt;=，&lt;=，即等于、不等于、大于、小于、大于等于、小于等于</span><br><span class="line"></span><br><span class="line">赋值运算符：=，+=，-=，*=，/=，%=，即赋值、加赋值、减赋值、乘赋值、除赋值、取余赋值</span><br><span class="line"></span><br><span class="line">逻辑运算符：and，or，not，即与、或、非</span><br><span class="line"></span><br><span class="line">a = 1b = 2print a + bprint a == b# 等价于 a = a + 3a += 3print ac = Trued = Falseprint c and d</span><br></pre></td></tr></table></figure><ul><li><h2 id="12-条件"><a href="#12-条件" class="headerlink" title="12 条件"></a>12 条件</h2></li></ul><p>在写代码的时候，往往需要根据某些条件进行判断，并根据判断结果执行不同的分支代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line"># 单个条件</span><br><span class="line">if a == 1:</span><br><span class="line">    print 11111</span><br><span class="line"># 处理条件不成立的分支</span><br><span class="line">if a == 2:</span><br><span class="line">    print 22222</span><br><span class="line">else:</span><br><span class="line">    print 33333</span><br><span class="line"># 多个条件，加多少个都可以</span><br><span class="line">if a == 1:</span><br><span class="line">    print 11111</span><br><span class="line">elif a == 2:</span><br><span class="line">    print 22222</span><br><span class="line">else:    </span><br><span class="line">print 33333</span><br></pre></td></tr></table></figure><p>需要注意的是，但凡出现了 if 和 elif ，就需要加上相应的条件判断，并且注意代码的缩进。在Sublime中输入if会出现相应的提示，可以方便地补全代码，在换行时光标也会自动跳到合适的缩进处。</p><ul><li><h2 id="13-循环"><a href="#13-循环" class="headerlink" title="13 循环"></a>13 循环</h2></li></ul><p>如果需要打印从1到100的100个数，肯定不会傻傻地写100行print代码，而是会用循环来处理类似的重复性工作。</p><ul><li><h2 id="14-while-循环"><a href="#14-while-循环" class="headerlink" title="14 while 循环"></a>14 while 循环</h2></li></ul><p>while 循环的思想是，只要某一条件成立，就不断执行循环体里的代码，直到条件不再成立。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag = 1while flag &lt; 10:</span><br><span class="line">    print flag    </span><br><span class="line"># 一定要记得在循环体里修改条件变量    </span><br><span class="line"># 否则可能导致死循环</span><br><span class="line">    flag += 1</span><br></pre></td></tr></table></figure><ul><li><h2 id="15-for-循环"><a href="#15-for-循环" class="headerlink" title="15 for 循环"></a>15 for 循环</h2></li></ul><p>for 循环的循环次数一般是事先预知的，将一个标志变量从某个起始值迭代到某个终止值后即结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># x从0开始，一直到9结束</span><br><span class="line">for x in xrange(0, 10):</span><br><span class="line">    print x</span><br></pre></td></tr></table></figure><p>可以用 for 循环方便地遍历列表和字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2.1,  Hello ]</span><br><span class="line">dict = &#123; k1 : 1,  k2 : 2.1,  k3 :  Hello &#125;</span><br><span class="line"># 遍历列表，这里的item只是一个临时变量，取别的名称也行</span><br><span class="line">for item in li:</span><br><span class="line">    print item</span><br><span class="line"># 遍历字典的全部key，这里的key也只是一个临时变量，名称不重要</span><br><span class="line">for key in dict.keys():</span><br><span class="line">    print key</span><br><span class="line"># 遍历字典的全部value，这里的value也只是一个临时变量，名称不重要</span><br><span class="line">for value in dict.values():</span><br><span class="line">    print value</span><br><span class="line"># 同时遍历key和value</span><br><span class="line">for key, value in dict.items():</span><br><span class="line">    print key, value</span><br></pre></td></tr></table></figure><ul><li><h2 id="16-循环控制"><a href="#16-循环控制" class="headerlink" title="16 循环控制"></a>16 循环控制</h2></li></ul><p>循环控制主要包括三种：pass 、 continue 、 break 。</p><p>pass 表示什么也不做，只是占一行代码的位置；continue 表示立即退出本轮循环，继续执行后续轮循环；break 表示立即推出循环，后续循环也不再执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for x in xrange(0, 10):</span><br><span class="line">    if x == 5:</span><br><span class="line">pass</span><br><span class="line">    else:</span><br><span class="line">print x</span><br><span class="line">for x in xrange(0, 10):</span><br><span class="line">    if x == 5:</span><br><span class="line">continue</span><br><span class="line">    print x</span><br><span class="line">for x in xrange(0, 10):</span><br><span class="line">    if x == 5:</span><br><span class="line">break</span><br><span class="line">print x</span><br></pre></td></tr></table></figure><ul><li><h2 id="17-时间"><a href="#17-时间" class="headerlink" title="17 时间"></a>17 时间</h2></li></ul><p>在处理数据时，很多地方都会涉及到时间，例如数据产生的时间。先介绍一下时间戳的概念，时间戳指的是从1970年1月1日0时0分0秒开始，到某一时刻所经历的秒数，可以是整数或者小数，后者的精度更高。</p><p>为什么需要时间戳这样的一个概念？因为对于同一个时刻，不同人的描述可能不同，毕竟文本的形式千变万化，而时间戳使得时间的表达得到了统一，每个时刻只能用唯一的整数或浮点数来表示，同时也便于计算时间差这样的处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 来看一下当前时刻的时间戳吧</span><br><span class="line">import timet = time.time()</span><br><span class="line">print t, type(t)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于时间戳，最常用的处理便是时间戳和时间文本之间的转换，例如将 2016年10月1日 10时0分0秒 转为时间戳。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"># 时间文本转时间戳，精确到秒</span><br><span class="line">a =  2016-10-01 10:00:00 </span><br><span class="line">a = int(time.mktime(time.strptime(a, %Y-%m-%d %H:%M:%S )))</span><br><span class="line">print a</span><br><span class="line"># 时间戳转时间文本</span><br><span class="line">b = int(time.time())</span><br><span class="line">b = time.strftime( %Y-%m-%d %H:%M:%S , time.localtime(b))</span><br><span class="line">print b</span><br></pre></td></tr></table></figure><p>其中， %Y 、 %m 等都是时间字段，前者表示四位的年份，后者表示两位的月份。</p><p>文件</p><p>文件操作包括向文件中写内容，以及从文件中读内容，使用 open() 打开一个文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 写文件</span><br><span class="line"># 重新写模式，打开文件时会将文件内容清空</span><br><span class="line">fw = open( data.txt ,  w )</span><br><span class="line"># 追加写模式，打开文件后保留原始内容，继续写入</span><br><span class="line">for x in xrange(0, 10):</span><br><span class="line">    # 将整数转成文本再写入</span><br><span class="line">    fw.write(str(x))</span><br><span class="line">    # 也可以每次写入之后换行，为转义字符，表示换行    </span><br><span class="line"># fw.write(str(x) +   )</span><br><span class="line">fw.close()</span><br><span class="line"># 读文件</span><br><span class="line">fr = open( data.txt ,  r )</span><br><span class="line"># 一行一行地读，line只是个临时变量，取别的名称也行</span><br><span class="line">for line in fr:</span><br><span class="line">    print line</span><br><span class="line">    # 如果每行后面有换行，可以将换行符去掉，使内容更紧凑</span><br><span class="line">    # strip()可以去掉字符串两端的空白字符    </span><br><span class="line"># print line.strip()</span><br><span class="line">fr.close()</span><br></pre></td></tr></table></figure><ul><li><h2 id="18-异常"><a href="#18-异常" class="headerlink" title="18 异常"></a>18 异常</h2></li></ul><p>Python代码中可能会出现一些可以预知的问题，例如字典访问的key不存在。</p><p>如果不加处理，发生问题的时候Python便会报错并退出，可能之前跑了很久又要重头再来。因此，我们需要对可能出现的异常进行捕捉和处理。异常的结构由 try 、except 、 else 、 finally 四部分组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try:    </span><br><span class="line"># 尝试执行这些代码    </span><br><span class="line">print 1 / 0except </span><br><span class="line">Exception, e:    </span><br><span class="line"># 如果出现异常就进行处理    </span><br><span class="line"># e为出现的异常类型    </span><br><span class="line">print eelse:    </span><br><span class="line"># try里的代码没有出错    </span><br><span class="line"># 可以执行后续工作了    </span><br><span class="line">print  没有出错 </span><br><span class="line">finally:    </span><br><span class="line"># 无论是否出错，都会执行的代码    </span><br><span class="line">print &quot;一定会执行&quot;</span><br></pre></td></tr></table></figure><ul><li><h2 id="19-函数"><a href="#19-函数" class="headerlink" title="19 函数"></a>19 函数</h2></li></ul><p>函数的作用是代码模块化，将可重用的代码封装成一个函数，这样在需要使用的时候就只需调用写好的函数即可，而不用重新写一遍代码。</p><p>函数的使用包括两个部分，函数的定义和函数的调用。除此之外，函数可以有一个或多个参数，参数之间以逗号分开，为函数的功能提供更多的灵活性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义函数</span><br><span class="line">def hello(name1, name2):</span><br><span class="line">    print  Hello  + name1 + name2</span><br><span class="line"># 调用函数</span><br><span class="line">hello(Python,JavaScri)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近堂妹要学Python给她写了些Python基础的语法入门，在此做个总结记录。&lt;br&gt;Python简单易学，但又博大精深。&lt;br&gt;许多人号称精通Python，却不会写Pythonic的代码，对很多常用包的使用也并不熟悉。&lt;br&gt;ps:Pythonic是指代码遵循Python社区的惯例，并以其预期的方式使用该语言。Pythonic的代码不仅仅是语法正确，而是充分利用Python语言的特性来产生清晰、简洁和可维护的代码 。&lt;/p&gt;
&lt;p&gt;学海无涯，我们先来了解一些Python中最基本的内容。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://longchao012.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>几个新的常用Python库，旧的可以淘汰了</title>
    <link href="https://longchao012.github.io/2022/08/31/%E5%87%A0%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B8%B8%E7%94%A8Python%E5%BA%93%EF%BC%8C%E6%97%A7%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%B7%98%E6%B1%B0%E4%BA%86/"/>
    <id>https://longchao012.github.io/2022/08/31/%E5%87%A0%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B8%B8%E7%94%A8Python%E5%BA%93%EF%BC%8C%E6%97%A7%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%B7%98%E6%B1%B0%E4%BA%86/</id>
    <published>2022-08-31T02:56:14.000Z</published>
    <updated>2023-09-04T03:03:00.264Z</updated>
    
    <content type="html"><![CDATA[<p>随着每个 Python 版本的发布，都会添加新模块，并引入新的更好的做事方式，虽然我们都习惯了使用好的旧 Python 库和某些做事方式，但现在也时候升级并利用新的和改进的模块及其特性了。</p><span id="more"></span><p><strong>Pathlib 而不是 OS</strong><br>pathlib 绝对是 Python 标准库中最近添加的更大的内容之一， 自 Python 3.4 以来，它一直是标准库的一部分，但很多人仍然使用 os 模块进行文件系统操作。</p><p>然而，pathlib 与旧的 os.path 相比具有许多优点 - 虽然 os 模块以原始字符串格式表示路径，但 pathlib 使用面向对象的样式，这使得它更具可读性和编写自然：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pathlib import Path</span><br><span class="line">import os.path</span><br><span class="line"></span><br><span class="line"># 老方式</span><br><span class="line">two_dirs_up = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"></span><br><span class="line"># 新方式，可读性强</span><br><span class="line">two_dirs_up = Path(__file__).resolve().parent.parent</span><br></pre></td></tr></table></figure><p>路径被视为对象而不是字符串这一事实也使得可以创建一次对象，然后查找其属性或对其进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">readme = Path(&quot;README.md&quot;).resolve()</span><br><span class="line"></span><br><span class="line">print(f&quot;Absolute path: &#123;readme.absolute()&#125;&quot;)</span><br><span class="line"># Absolute path: /home/martin/some/path/README.md</span><br><span class="line">print(f&quot;File name: &#123;readme.name&#125;&quot;)</span><br><span class="line"># File name: README.md</span><br><span class="line">print(f&quot;Path root: &#123;readme.root&#125;&quot;)</span><br><span class="line"># Path root: /</span><br><span class="line">print(f&quot;Parent directory: &#123;readme.parent&#125;&quot;)</span><br><span class="line"># Parent directory: /home/martin/some/path</span><br><span class="line">print(f&quot;File extension: &#123;readme.suffix&#125;&quot;)</span><br><span class="line"># File extension: .md</span><br><span class="line">print(f&quot;Is it absolute: &#123;readme.is_absolute()&#125;&quot;)</span><br><span class="line"># Is it absolute: True</span><br></pre></td></tr></table></figure><p>我最喜欢 pathlib 的一个特性是可以使用 &#x2F;（“除法”）运算符来连接路径：</p><p># Operators:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">etc = Path(&#x27;/etc&#x27;)</span><br><span class="line"></span><br><span class="line">joined = etc / &quot;cron.d&quot; / &quot;anacron&quot;</span><br><span class="line">print(f&quot;Exists? - &#123;joined.exists()&#125;&quot;)</span><br><span class="line"># Exists? - True</span><br></pre></td></tr></table></figure><p>重要的是要注意 pathlib 只是替代 os.path 而不是整个 os 模块， 它还包括 glob 模块的功能，因此如果你习惯于将 os.path 与 glob.glob 结合使用，那么你可以完全用pathlib替代它们。</p><p>在上面的片段中，我们展示了一些方便的路径操作和对象属性，但 pathlib 还包括你习惯于 os.path 的所有方法，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(f&quot;Working directory: &#123;Path.cwd()&#125;&quot;)  # same as os.getcwd()</span><br><span class="line"># Working directory: /home/martin/some/path</span><br><span class="line">Path.mkdir(Path.cwd() / &quot;new_dir&quot;, exist_ok=True)  # same as os.makedirs()</span><br><span class="line">print(Path(&quot;README.md&quot;).resolve())  # same as os.path.abspath()</span><br><span class="line"># /home/martin/some/path/README.md</span><br><span class="line">print(Path.home())  # same as os.path.expanduser()</span><br><span class="line"># /home/martin</span><br></pre></td></tr></table></figure><p>有关 os.path 函数到 pathlib 中新函数的完整映射，请参阅 官方文档。</p><p><strong>Secrets 而不是 OS</strong><br>说到 os 模块，你应该停止使用的另一部分是 os.urandom。相反，你应该使用自 Python 3.6 以来可用的新秘密模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 老方式:</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">length = 64</span><br><span class="line"></span><br><span class="line">value = os.urandom(length)</span><br><span class="line">print(f&quot;Bytes: &#123;value&#125;&quot;)</span><br><span class="line"># Bytes: b&#x27;\xfa\xf3...\xf2\x1b\xf5\xb6&#x27;</span><br><span class="line">print(f&quot;Hex: &#123;value.hex()&#125;&quot;)</span><br><span class="line"># Hex: faf3cc656370e31a938e7...33d9b023c3c24f1bf5</span><br><span class="line"></span><br><span class="line"># 新方式:</span><br><span class="line">import secrets</span><br><span class="line"></span><br><span class="line">value = secrets.token_bytes(length)</span><br><span class="line">print(f&quot;Bytes: &#123;value&#125;&quot;)</span><br><span class="line"># Bytes: b&#x27;U\xe9n\x87...\x85&gt;\x04j:\xb0&#x27;</span><br><span class="line">value = secrets.token_hex(length)</span><br><span class="line">print(f&quot;Hex: &#123;value&#125;&quot;)</span><br><span class="line"># Hex: fb5dd85e7d73f7a08b8e3...4fd9f95beb08d77391</span><br></pre></td></tr></table></figure><p>使用 os.urandom 实际上并不是这里的问题，引入secrets模块的原因是因为人们使用随机模块来生成密码等，即使随机模块不产生密码安全令牌。</p><p>根据文档，随机模块不应用于安全目的， 你应该使用 secrets 或 os.urandom，但 secrets 模块绝对更可取，因为它比较新，并且包含一些用于十六进制令牌的实用程序&#x2F;便利方法以及 URL 安全令牌。</p><p><strong>Zoneinfo 而不是 pytz</strong><br>在 Python 3.9 之前，没有用于时区操作的内置库，所以每个人都在使用 pytz，但现在我们在标准库中有 zoneinfo，所以是时候切换了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">import pytz  # pip install pytz</span><br><span class="line"></span><br><span class="line">dt = datetime(2022, 6, 4)</span><br><span class="line">nyc = pytz.timezone(&quot;America/New_York&quot;)</span><br><span class="line"></span><br><span class="line">localized = nyc.localize(dt)</span><br><span class="line">print(f&quot;Datetime: &#123;localized&#125;, Timezone: &#123;localized.tzname()&#125;, TZ Info: &#123;localized.tzinfo&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 新方式:</span><br><span class="line">from zoneinfo import ZoneInfo</span><br><span class="line"></span><br><span class="line">nyc = ZoneInfo(&quot;America/New_York&quot;)</span><br><span class="line">localized = datetime(2022, 6, 4, tzinfo=nyc)</span><br><span class="line">print(f&quot;Datetime: &#123;localized&#125;, Timezone: &#123;localized.tzname()&#125;, TZ Info: &#123;localized.tzinfo&#125;&quot;)</span><br><span class="line"># Datetime: 2022-06-04 00:00:00-04:00, Timezone: EDT, TZ Info: America/New_York</span><br></pre></td></tr></table></figure><p>datetime 模块将所有时区操作委托给抽象基类 datetime.tzinfo， 这个抽象基类需要一个具体的实现——在引入这个很可能来自 pytz 的模块之前。现在我们在标准库中有 zoneinfo，我们可以使用它。</p><p>然而，使用 zoneinfo 有一个警告——它假定系统上有可用的时区数据，UNIX 系统就是这种情况， 如果你的系统没有时区数据，那么你应该使用 tzdata 包，它是由 CPython 核心开发人员维护的第一方库，其中包含 IANA 时区数据库。</p><p><strong>Dataclasses</strong><br>Python 3.7 的一个重要补充是 dataclasses 包，它是 namedtuple 的替代品。</p><p>你可能想知道为什么需要替换 namedtuple？以下是你应该考虑切换到数据类的一些原因：</p><p>1、它可以是可变的<br>2、默认提供 repr、eq、init、hash 魔术方法，<br>3、允许指定默认值，<br>4、支持继承。此外，数据类还支持 frozen 和 slots（从 3.10 开始）属性以提供与命名元组的特征奇偶校验。<br>切换真的不应该太难，因为你只需要更改定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 老方式:</span><br><span class="line"># from collections import namedtuple</span><br><span class="line">from typing import NamedTuple</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">User = NamedTuple(&quot;User&quot;, [(&quot;name&quot;, str), (&quot;surname&quot;, str), (&quot;password&quot;, bytes)])</span><br><span class="line"></span><br><span class="line">u = User(&quot;John&quot;, &quot;Doe&quot;, b&#x27;tfeL+uD...\xd2&#x27;)</span><br><span class="line">print(f&quot;Size: &#123;sys.getsizeof(u)&#125;&quot;)</span><br><span class="line"># Size: 64</span><br><span class="line"></span><br><span class="line"># 新方式:</span><br><span class="line">from dataclasses import dataclass</span><br><span class="line"></span><br><span class="line">@dataclass()</span><br><span class="line">class User:</span><br><span class="line">   name: str</span><br><span class="line">   surname: str</span><br><span class="line">   password: bytes</span><br><span class="line"></span><br><span class="line">u = User(&quot;John&quot;, &quot;Doe&quot;, b&#x27;tfeL+uD...\xd2&#x27;)</span><br><span class="line"></span><br><span class="line">print(u)</span><br><span class="line"># User(name=&#x27;John&#x27;, surname=&#x27;Doe&#x27;, password=b&#x27;tfeL+uD...\xd2&#x27;)</span><br><span class="line"></span><br><span class="line">print(f&quot;Size: &#123;sys.getsizeof(u)&#125;, &#123;sys.getsizeof(u) + sys.getsizeof(vars(u))&#125;&quot;)</span><br><span class="line"># Size: 48, 152</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们还包含了大小比较，因为这是 namedtuple 和数据类之间的较大差异之一，如上所见，命名元组的大小要小得多，这是由于数据类使用 dict 来表示属性。</p><p>至于速度比较，除非你计划创建数百万个实例，否则属性的访问时间应该基本相同，或者不够重要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line"></span><br><span class="line">setup = &#x27;&#x27;&#x27;</span><br><span class="line">from typing import NamedTuple</span><br><span class="line">User = NamedTuple(&quot;User&quot;, [(&quot;name&quot;, str), (&quot;surname&quot;, str), (&quot;password&quot;, bytes)])</span><br><span class="line">u = User(&quot;John&quot;, &quot;Doe&quot;, b&#x27;&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">print(f&quot;Access speed: &#123;min(timeit.repeat(&#x27;u.name&#x27;, setup=setup, number=10000000))&#125;&quot;)</span><br><span class="line"># Access speed: 0.16838401100540068</span><br><span class="line"></span><br><span class="line">setup = &#x27;&#x27;&#x27;</span><br><span class="line">from dataclasses import dataclass</span><br><span class="line"></span><br><span class="line">@dataclass(slots=True)</span><br><span class="line">class User:</span><br><span class="line">  name: str</span><br><span class="line">  surname: str</span><br><span class="line">  password: bytes</span><br><span class="line"></span><br><span class="line">u = User(&quot;John&quot;, &quot;Doe&quot;, b&#x27;&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">print(f&quot;Access speed: &#123;min(timeit.repeat(&#x27;u.name&#x27;, setup=setup, number=10000000))&#125;&quot;)</span><br><span class="line"># Access speed: 0.17728697300481144</span><br></pre></td></tr></table></figure><p>如果以上内容说服了你打算切换到数据类，请尽快尝试吧</p><p>相反，如果你不想切换并且出于某种原因真的想使用命名元组，那么你至少应该使用键入模块而不是collections中的 NamedTuple：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 不好方式的:</span><br><span class="line">from collections import namedtuple</span><br><span class="line">Point = namedtuple(&quot;Point&quot;, [&quot;x&quot;, &quot;y&quot;])</span><br><span class="line"></span><br><span class="line"># 更好的方式:</span><br><span class="line">from typing import NamedTuple</span><br><span class="line">class Point(NamedTuple):</span><br><span class="line">    x: float</span><br><span class="line">    y: float</span><br></pre></td></tr></table></figure><p>最后，如果你既不使用 namedtuple 也不使用数据类，你可能需要考虑直接使用 Pydantic。</p><p><strong>Proper Logging 而不是 print</strong><br>这不是标准库的最新添加，但值得使用 - 你应该使用正确的日志记录而不是打印语句， 如果你在本地调试问题，则可以使用 print，但对于任何无需用户干预即可运行的生产就绪程序，正确的日志记录是必须的。</p><p>特别是考虑到设置 Python 日志记录非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(</span><br><span class="line">    filename=&#x27;application.log&#x27;,</span><br><span class="line">    level=logging.WARNING,</span><br><span class="line">    format=&#x27;[%(asctime)s] &#123;%(pathname)s:%(lineno)d&#125; %(levelname)s - %(message)s&#x27;,</span><br><span class="line">    datefmt=&#x27;%H:%M:%S&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logging.error(&quot;Some serious error occurred.&quot;)</span><br><span class="line"># [12:52:35] &#123;&lt;stdin&gt;:1&#125; ERROR - Some serious error occurred.</span><br><span class="line">logging.warning(&#x27;Some warning.&#x27;)</span><br><span class="line"># [12:52:35] &#123;&lt;stdin&gt;:1&#125; WARNING - Some warning.</span><br></pre></td></tr></table></figure><p>与打印语句相比，上面的简单配置将为你提供卓越的调试体验， 最重要的是，你可以进一步自定义日志库以记录到不同的位置、更改日志级别、自动轮换日志等。</p><p><strong>f-strings 而不是 format</strong><br>Python 包含很多格式化字符串的方法，包括 C 样式格式化、f 字符串、模板字符串或 .format 函数， 不过，其中之一 - f-strings - 格式化的字符串文字 ， 它们写起来更自然，可读性更强，并且是前面提到的选项中最快的。</p><p>因此，我认为没有必要争论或解释为什么要使用它们，然而，在某些情况下不能使用 f 字符串：</p><p>使用 % 格式的唯一原因是用于记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">things = &quot;something happened...&quot;</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.error(&quot;Message: %s&quot;, things)  # 评估内部记录器方法</span><br><span class="line">logger.error(f&quot;Message: &#123;things&#125;&quot;)  # 立即评估</span><br></pre></td></tr></table></figure><p>在上面的示例中，如果你使用 f 字符串，则表达式将立即计算，而使用 C 样式格式，替换将被推迟到实际需要时，这对于消息分组很重要，其中具有相同模板的所有消息都可以记录为一个， 这不适用于 f 字符串，因为模板在传递给记录器之前填充了数据。</p><p>此外，有些事情是 f-strings 根本无法做到的， 例如在运行时填充模板 - 即动态格式 - 这就是 f-strings 被称为文字字符串格式的原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 动态设置模板及其参数</span><br><span class="line">def func(tpl: str, param1: str, param2: str) -&gt; str:</span><br><span class="line">    return tpl.format(param=param1, param2=param2)</span><br><span class="line"></span><br><span class="line">some_template = &quot;First template: &#123;param1&#125;, &#123;param2&#125;&quot;</span><br><span class="line">another_template = &quot;Other template: &#123;param1&#125; and &#123;param2&#125;&quot;</span><br><span class="line">print(func(some_template, &quot;Hello&quot;, &quot;World&quot;))</span><br><span class="line">print(func(another_template, &quot;Hello&quot;, &quot;Python&quot;))</span><br><span class="line"></span><br><span class="line"># 动态重用具有不同参数的相同模板.</span><br><span class="line">inputs = [&quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;]</span><br><span class="line">template = &quot;Here&#x27;s some dynamic value: &#123;value&#125;&quot;</span><br><span class="line"></span><br><span class="line">for value in inputs:</span><br><span class="line">    print(template.format(value=value))</span><br></pre></td></tr></table></figure><p>最重要的是，尽可能使用 f 字符串，因为它们更具可读性和更高性能，但请注意，在某些情况下仍然首选和&#x2F;或需要其他格式样式。</p><p><strong>Tomllib 而不是 tomli</strong><br>TOML 是一种广泛使用的配置格式，对于 Python 的工具和生态系统尤其重要，因为它用于 pyproject.toml 配置文件， 到目前为止，你必须使用外部库来管理 TOML 文件，但是从 Python 3.11 开始，将有一个名为 tomllib 的内置库，它基于 toml 包。</p><p>所以，一旦你切换到 Python 3.11，你应该养成使用 import tomllib 而不是 import tomli 的习惯。少了一种需要担心的依赖！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># import tomli as tomllib</span><br><span class="line">import tomllib</span><br><span class="line"></span><br><span class="line">with open(&quot;pyproject.toml&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    config = tomllib.load(f)</span><br><span class="line">    print(config)</span><br><span class="line">    # &#123;&#x27;project&#x27;: &#123;&#x27;authors&#x27;: [&#123;&#x27;email&#x27;: &#x27;contact@martinheinz.dev&#x27;,</span><br><span class="line">    #                           &#x27;name&#x27;: &#x27;Martin Heinz&#x27;&#125;],</span><br><span class="line">    #              &#x27;dependencies&#x27;: [&#x27;flask&#x27;, &#x27;requests&#x27;],</span><br><span class="line">    #              &#x27;description&#x27;: &#x27;Example Package&#x27;,</span><br><span class="line">    #              &#x27;name&#x27;: &#x27;some-app&#x27;,</span><br><span class="line">    #              &#x27;version&#x27;: &#x27;0.1.0&#x27;&#125;&#125;</span><br><span class="line"></span><br><span class="line">toml_string = &quot;&quot;&quot;</span><br><span class="line">[project]</span><br><span class="line">name = &quot;another-app&quot;</span><br><span class="line">description = &quot;Example Package&quot;</span><br><span class="line">version = &quot;0.1.1&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">config = tomllib.loads(toml_string)</span><br><span class="line">print(config)</span><br><span class="line"># &#123;&#x27;project&#x27;: &#123;&#x27;name&#x27;: &#x27;another-app&#x27;, &#x27;description&#x27;: &#x27;Example Package&#x27;, &#x27;version&#x27;: &#x27;0.1.1&#x27;&#125;&#125;</span><br><span class="line">Setuptools 而不是  distutils</span><br></pre></td></tr></table></figure><p>最后一个更像是弃用通知：</p><p>由于 Distutils 已弃用，因此同样不鼓励使用任何来自 distutils 的函数或对象，Setuptools 旨在替换或弃用所有此类用途。</p><p>是时候告别 distutils 包并切换到 setuptools 了，setuptools 文档提供了有关如何替换 distutils 用法的指导， 除此之外，PEP 632 还为 setuptools 未涵盖的部分 distutils 提供迁移建议。</p><p><strong>总结</strong><br>每个新的 Python 版本都会带来新的特性，因此我建议你查看 Python 发行说明中的“新模块”、“不推荐使用的模块”和“已删除的模块”部分，这是了解 Python 标准重大变化的好方法 ， 通过这种方式，你可以不断地将新功能和最佳实践整合到你的项目中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着每个 Python 版本的发布，都会添加新模块，并引入新的更好的做事方式，虽然我们都习惯了使用好的旧 Python 库和某些做事方式，但现在也时候升级并利用新的和改进的模块及其特性了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://longchao012.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python中常用的 pip 命令</title>
    <link href="https://longchao012.github.io/2022/08/28/Python%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%20pip%20%E5%91%BD%E4%BB%A4/"/>
    <id>https://longchao012.github.io/2022/08/28/Python%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%20pip%20%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-28T02:30:39.000Z</published>
    <updated>2023-09-04T02:54:40.888Z</updated>
    
    <content type="html"><![CDATA[<p>相信对于大多数熟悉Python的人来说，一定都听说并且使用过pip这个工具，但是对它的了解可能还不一定是非常的透彻，今天就来为大家介绍几个使用pip的小技巧，相信对大家以后管理和使用Python当中的标准库会有帮助。</p><span id="more"></span><p><strong><center> 安装 </center></strong><br>当然在Python 3.4版本之后以及Python 2.7.9版本之后，官网的安装包当中就已经自带了pip，用户直接在安装完Python之后就可以直接使用，要是使用由virtualenv或者pyvenv创建的虚拟环境，那么pip也是被默认安装的</p><p>如果是需要自己另外安装pip包的，在已经配置好Python的环境当中运行下面这个命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py -m ensurepip --upgrade </span><br></pre></td></tr></table></figure><p>另外一种方式是从官网上(<a href="https://bootstrap.pypa.io/get-pip.py)%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BDget-pip.py%E8%84%9A%E6%9C%AC%EF%BC%8C%E7%84%B6%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8Cpython">https://bootstrap.pypa.io/get-pip.py)直接下载get-pip.py脚本，然后直接运行python</a> get-pip.py脚本即可</p><p>如何使用<br>安装后，在命令行中输入pip，然后按下回车，就会出现下图所示的使用说明：</p><p><img src="/images/pip1.png" alt="pip1"><br>升级<br>要是你觉得自己的pip版本有点低，想要升级一下的话，在命令行中输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pip</span><br></pre></td></tr></table></figure><p>安装某个版本的包<br>如果打算用pip来安装第三方的包，用的是以下的命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package-name</span><br></pre></td></tr></table></figure><p>例如我们想要安装指定版本的第三方的包，例如安装3.4.1版本的matplotlib，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib==3.4.1</span><br></pre></td></tr></table></figure><p>卸载或者是更新包<br>要是你打算想要卸载某个包，该要输入的命令行是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall package_name</span><br></pre></td></tr></table></figure><p>而如果打算更新某个包，对应的命令行是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade package_name</span><br></pre></td></tr></table></figure><p># 或者是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U package_name</span><br></pre></td></tr></table></figure><p>查看某个包的信息<br>可以通过以下的这个命令行来查看指定包的信息，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show -f requests</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Name: requests</span><br><span class="line">Version: 2.24.0</span><br><span class="line">Summary: Python HTTP for Humans.</span><br><span class="line">Home-page: https://requests.readthedocs.io</span><br><span class="line">Author: Kenneth Reitz</span><br><span class="line">Author-email: me@kennethreitz.org</span><br><span class="line">License: Apache 2.0</span><br><span class="line">Location: c:\users\pc120\pycharmprojects\pythonproject1\venv\lib\site-packages</span><br><span class="line">Requires: certifi, chardet, idna, urllib3</span><br><span class="line">Required-by: etelemetry, gTTS, pandas-datareader, pandas-profiling, pyler, pywhatkit, pyxnat, streamlit, tushare, wikipedia, yfinance</span><br><span class="line">Files:</span><br><span class="line">  requests-2.24.0.dist-info\DESCRIPTION.rst</span><br><span class="line">  requests-2.24.0.dist-info\INSTALLER</span><br><span class="line">  .......</span><br></pre></td></tr></table></figure><p>查看需要被升级的包<br>我们需要查看一下现有的这些包中，哪些是需要是被升级的，可以用下面这行命令行来查看，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list -o</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Package    Version Latest Type</span><br><span class="line">---------- ------- ------ -----</span><br><span class="line">docutils   0.15.2  0.18.1 wheel</span><br><span class="line">PyYAML     5.4.1   6.0    wheel</span><br><span class="line">rsa        4.7.2   4.8    wheel</span><br><span class="line">setuptools 56.0.0  62.1.0 wheel</span><br></pre></td></tr></table></figure><p>查看兼容问题<br>在下载安装一些标准库的时候，需要考虑到兼容问题，一些标准库的安装可能需要依赖其他的标准库，会存在版本相冲突等问题，我们先用下面这条命令行来检查一下是否会有冲突的问题存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip check package_name</span><br></pre></td></tr></table></figure><p>当然要是我们不指定是哪个标准库的话，会检查现在已经安装的所有包中的是否存在版本冲突等问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip check</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yfinance 0.1.70 has requirement requests&gt;=2.26, but you have requests 2.24.0.</span><br><span class="line">selenium 4.1.0 has requirement urllib3[secure]~=1.26, but you have urllib3 1.25.11.</span><br></pre></td></tr></table></figure><p>指定国内源来安装<br>我们要是感觉到安装的速度有点慢，可以指定国内的源来安装某个包，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.douban.com/simple/ package_name</span><br></pre></td></tr></table></figure><p>国内源有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">华中理工大学：http://pypi.hustunique.com/</span><br><span class="line">山东理工大学：http://pypi.sdutlinux.org/ </span><br><span class="line">豆瓣：http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure><p>下载包但是不安装<br>要是我们想要下载某个包到指定的路径下，命令行如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip download package_name -d &quot;某个路径&quot;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip download requests -d &quot;.&quot;</span><br></pre></td></tr></table></figure><p>就是在当前的目录下下载requests模块以及其他所要依赖的模块</p><p>批量安装软件包<br>我们一般在看到别人的项目时，都会包含一个requirements.txt文件，里面包含了一些Python项目当中需要用到的第三方库</p><p><img src="/images/pip2.png" alt="pip2"><br>要生成这种txt文件，需要这么来做</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p>而如果我们需要来批量安装第三方库，在命令行中输入以下这个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;相信对于大多数熟悉Python的人来说，一定都听说并且使用过pip这个工具，但是对它的了解可能还不一定是非常的透彻，今天就来为大家介绍几个使用pip的小技巧，相信对大家以后管理和使用Python当中的标准库会有帮助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://longchao012.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>几种好用的数据迁移工具</title>
    <link href="https://longchao012.github.io/2022/08/26/%E5%87%A0%E7%A7%8D%E5%A5%BD%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%B7%A5%E5%85%B7/"/>
    <id>https://longchao012.github.io/2022/08/26/%E5%87%A0%E7%A7%8D%E5%A5%BD%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%B7%A5%E5%85%B7/</id>
    <published>2022-08-26T01:15:01.000Z</published>
    <updated>2023-09-04T06:17:47.280Z</updated>
    
    <content type="html"><![CDATA[<p>市面上有那么多的ETL数据迁移工具，我们可以用哪些？</p><p>ETL(是Extract-Transform-Load的缩写，即数据抽取、转换、装载的过程)，对于企业应用来说，我们经常会遇到各种数据的处理、转换、迁移的场景。</p><p>今天特地给大家汇总了一些目前市面上比较常用的ETL数据迁移工具，希望对大家有所帮助。</p><span id="more"></span><h2 id="1-Kettle"><a href="#1-Kettle" class="headerlink" title="1.Kettle"></a>1.Kettle</h2><p><strong>Kettle</strong>是一款国外开源的<strong>ETL</strong>工具，纯<strong>Java</strong>编写，绿色无需安装，数据抽取高效稳定(数据迁移工具)。</p><p>Kettle 中有两种脚本文件，transformation 和 job，transformation 完成针对数据的基础转换，job 则完成整个工作流的控制。</p><p>Kettle 中文名称叫水壶，该项目的主程序员 MATT 希望把各种数据放到一个壶里，然后以一种指定的格式流出。<br><img src="/images/ETL1.png" alt="ETL1"></p><p>Kettle 这个 ETL 工具集，它允许你管理来自不同数据库的数据，通过提供一个图形化的用户环境来描述你想做什么，而不是你想怎么做。</p><p><img src="/images/ETL2.png" alt="ETL2"></p><ul><li><p>Kettle 家族目前包括 4 个产品：Spoon、Pan、CHEF、Kitchen。</p><ul><li>SPOON：允许你通过图形界面来设计 ETL 转换过程（Transformation）。</li><li>PAN：允许你批量运行由 Spoon 设计的 ETL 转换 (例如使用一个时间调度器)。Pan 是一个后台执行的程序，没有图形界面。</li><li>CHEF：允许你创建任务（Job）。任务通过允许每个转换，任务，脚本等等，更有利于自动化更新数据仓库的复杂工作。任务通过允许每个转换，任务，脚本等等。任务将会被检查，看看是否正确地运行了。</li><li>KITCHEN：允许你批量使用由 Chef 设计的任务 (例如使用一个时间调度器)。KITCHEN 也是一个后台运行的程序。</li></ul></li></ul><h2 id="2-Datax"><a href="#2-Datax" class="headerlink" title="2.Datax"></a>2.Datax</h2><p><strong>DataX</strong>是阿里云 DataWorks数据集成的开源版本，在阿里巴巴集团内被广泛使用的离线数据同步工具&#x2F;平台。</p><p>DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能。</p><p><img src="/images/ETL3.png" alt="ETL3"><br>设计理念：为了解决异构数据源同步问题，DataX将复杂的网状的同步链路变成了星型数据链路，DataX作为中间传输载体负责连接各种数据源。当需要接入一个新的数据源的时候，只需要将此数据源对接到DataX，便能跟已有的数据源做到无缝数据同步。</p><p>当前使用现状：DataX在阿里巴巴集团内被广泛使用，承担了所有大数据的离线同步业务，并已持续稳定运行了6年之久。目前每天完成同步8w多道作业，每日传输数据量超过300TB。</p><p>DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader&#x2F;Writer插件，纳入到整个同步框架中。</p><p><img src="/images/ETL4.png" alt="ETL4"><br>DataX 3.0 开源版本支持单机多线程模式完成同步作业运行，本小节按一个DataX作业生命周期的时序图，从整体架构设计非常简要说明DataX各个模块相互关系。<br><img src="/images/ETL5.png" alt="ETL5"></p><ul><li>DataX 3.0六大核心优势：<ul><li>可靠的数据质量监控</li><li>丰富的数据转换功能</li><li>精准的速度控制</li><li>强劲的同步性能</li><li>健壮的容错机制</li><li>极简的使用体验</li></ul></li></ul><h2 id="3-DataPipeline"><a href="#3-DataPipeline" class="headerlink" title="3.DataPipeline"></a>3.DataPipeline</h2><p><strong>DataPipeline</strong>采用基于日志的增量数据获取技术（Log-based Change Data Capture），支持异构数据之间丰富、自动化、准确的语义映射构建，同时满足实时与批量的数据处理。</p><p>可实现 Oracle、IBM DB2、MySQL、MS SQL Server、PostgreSQL、GoldenDB、TDSQL、OceanBase 等数据库准确的增量数据获取。</p><p>平台具备“数据全、传输快、强协同、更敏捷、极稳定、易维护”六大特性。</p><p>在支持传统关系型数据库的基础上，对大数据平台、国产数据库、云原生数据库、API 及对象存储也提供广泛的支持，并在不断扩展。</p><p>DataPipeline 数据融合产品致力于为用户提供企业级数据融合解决方案，为用户提供统一平台同时管理异构数据节点实时同步与批量数据处理任务，在未来还将提供对实时流计算的支持。</p><p>采用分布式集群化部署方式，可水平垂直线性扩展的，保证数据流转稳定高效，让客户专注数据价值释放。</p><p><img src="/images/ETL6.png" alt="ETL6"></p><ul><li><p><strong>产品特点：</strong></p><ul><li><strong>全面的数据节点支持</strong>：支持关系型数据库、NoSQL数据库、国产数据库、数据仓库、大数据平台、云存储、API等多种数据节点类型，可自定义数据节点。</li><li><strong>高性能实时处理</strong>：针对不同数据节点类型提供TB级吞吐量、秒级低延迟的增量数据处理能力，加速企业各类场景的数据流转。</li><li><strong>分层管理降本增效</strong>：采用“数据节点注册、数据链路配置、数据任务构建、系统资源分配”的分层管理模式，企业级平台的建设周期从三到六个月减少为一周。</li><li><strong>无代码敏捷管理</strong>：提供限制配置与策略配置两大类十余种高级配置，包括灵活的数据对象映射关系，数据融合任务的研发交付时间从2周减少为5分钟。</li><li><strong>极稳定高可靠</strong>：采用分布式架构，所有组件均支持高可用，提供丰富容错策略，应对上下游的结构变化、数据错误、网络故障等突发情况，可以保证系统业务连续性要求。</li><li><strong>全链路数据可观测</strong>：配备容器、应用、线程、业务四级监控体系，全景驾驶舱守护任务稳定运行。自动化运维体系，灵活扩缩容，合理管理和分配系统资源。</li></ul></li></ul><h2 id="4-Talend"><a href="#4-Talend" class="headerlink" title="4.Talend"></a>4.Talend</h2><p>Talend (踏蓝) 是第一家针对的数据集成工具市场的 ETL (数据的提取 Extract、传输 Transform、载入 Load) 开源软件供应商。</p><p><img src="/images/ETL7.png" alt="ETL7"><br>Talend 以它的技术和商业双重模式为 ETL 服务提供了一个全新的远景。它打破了传统的独有封闭服务，提供了一个针对所有规模的公司的公开的，创新的，强大的灵活的软件解决方案。</p><h2 id="5-DataStage"><a href="#5-DataStage" class="headerlink" title="5.DataStage"></a>5.DataStage</h2><p>DataStage，即IBM WebSphere DataStage，是一套专门对多种操作数据源的数据抽取、转换和维护过程进行简化和自动化，并将其输入数据集市或数据仓库目标数据库的集成工具，可以从多个不同的业务系统中，从多个平台的数据源中抽取数据，完成转换和清洗，装载到各种系统里面。</p><p>其中每步都可以在图形化工具里完成，同样可以灵活地被外部系统调度，提供专门的设计工具来设计转换规则和清洗规则等，实现了增量抽取、任务调度等多种复杂而实用的功能。其中简单的数据转换可以通过在界面上拖拉操作和调用一些 DataStage 预定义转换函数来实现，复杂转换可以通过编写脚本或结合其他语言的扩展来实现，并且 DataStage 提供调试环境，可以极大提高开发和调试抽取、转换程序的效率。</p><ul><li><p><strong>Datastage 操作界面</strong><br><img src="/images/ETL8.png" alt="ETL8"></p><ul><li>对元数据的支持：Datastage 是自己管理 Metadata，不依赖任何数据库。</li><li>参数控制：Datastage 可以对每个 job 设定参数，并且可以 job 内部引用这个参数名。</li><li>数据质量：Datastage 有配套用的 ProfileStage 和 QualityStage 保证数据质量。</li><li>定制开发：提供抽取、转换插件的定制，Datastage 内嵌一种类 BASIC 语言，可以写一段批处理程序来增加灵活性。</li><li>修改维护：提供图形化界面。这样的好处是直观、傻瓜式的；不好的地方就是改动还是比较费事（特别是批量化的修改）。</li></ul></li><li><p>Datastage 包含四大部件：</p><ul><li>Administrator：新建或者删除项目，设置项目的公共属性，比如权限。</li><li>Designer：连接到指定的项目上进行 Job 的设计；</li><li>Director：负责 Job 的运行，监控等。例如设置设计好的 Job 的调度时间。</li><li>Manager：进行 Job 的备份等 Job 的管理工作。</li></ul></li></ul><h2 id="6-Sqoop"><a href="#6-Sqoop" class="headerlink" title="6.Sqoop"></a>6.Sqoop</h2><p>Sqoop 是 Cloudera 公司创造的一个数据同步工具，现在已经完全开源了。</p><p>目前已经是 hadoop 生态环境中数据迁移的首选 Sqoop 是一个用来将 Hadoop 和关系型数据库中的数据相互转移的工具，可以将一个关系型数据库（例如 ：MySQL ,Oracle ,Postgres 等）中的数据导入到 Hadoop 的 HDFS 中，也可以将 HDFS 的数据导入到关系型数据库中。</p><p><img src="/images/ETL9.png" alt="ETL9"><br>他将我们传统的关系型数据库 | 文件型数据库 | 企业数据仓库 同步到我们的 hadoop 生态集群中。</p><p>同时也可以将 hadoop 生态集群中的数据导回到传统的关系型数据库 | 文件型数据库 | 企业数据仓库中。</p><p>那么 Sqoop 如何抽取数据呢?<br><img src="/images/ETL10.png" alt="ETL10"></p><p>1.首先 Sqoop 去 rdbms 抽取元数据。<br>2.当拿到元数据之后将任务切成多个任务分给多个 map。<br>3.然后再由每个 map 将自己的任务完成之后输出到文件。</p><h2 id="7-FineDataLink"><a href="#7-FineDataLink" class="headerlink" title="7.FineDataLink"></a>7.FineDataLink</h2><p>FineDataLink是国内做的比较好的ETL工具，FineDataLink是一站式的数据处理平台，具备高效的数据同步功能，可以实现实时数据传输、数据调度、数据治理等各类复杂组合场景的能力，提供数据汇聚、研发、治理等功能。</p><p>FDL拥有低代码优势，通过简单的拖拽交互就能实现ETL全流程。<br><img src="/images/ETL11.png" alt="ETL11"><br>FineDataLink——中国领先的低代码&#x2F;高时效数据集成产品，能过为企业提供一站式的数据服务，通过快速连接、高时效融合多种数据，提供低代码Data API敏捷发布平台，帮助企业解决数据孤岛难题，有效提升企业数据价值。</p><h2 id="8-canal"><a href="#8-canal" class="headerlink" title="8.canal"></a>8.canal</h2><p>canal [kə’næl]，译意为水道&#x2F;管道&#x2F;沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。<br><img src="/images/ETL12.png" alt="ETL12"><br>早期阿里巴巴因为杭州和美国双机房部署，存在跨机房同步的业务需求，实现方式主要是基于业务 trigger 获取增量变更。从 2010 年开始，业务逐步尝试数据库日志解析获取增量变更进行同步，由此衍生出了大量的数据库增量订阅和消费业务。</p><ul><li><p><strong>基于日志增量订阅和消费的业务包括：</strong></p><ul><li>数据库镜像</li><li>数据库实时备份</li><li>索引构建和实时维护(拆分异构索引、倒排索引等)</li><li>业务 cache 刷新</li><li>带业务逻辑的增量数据处理</li></ul></li><li><p><strong>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x。</strong></p></li></ul><p><img src="/images/ETL13.png" alt="ETL13"><br>    + MySQL master 将数据变更写入二进制日志( binary log, 其中记录叫做二进制日志事件binary log events，可以通过 show binlog events 进行查看)。<br>    + MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)。<br>    + MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据。</p><ul><li><p><strong>canal 工作原理：</strong></p><ul><li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</li><li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</li><li>canal 解析 binary log 对象(原始为 byte 流)</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;市面上有那么多的ETL数据迁移工具，我们可以用哪些？&lt;/p&gt;
&lt;p&gt;ETL(是Extract-Transform-Load的缩写，即数据抽取、转换、装载的过程)，对于企业应用来说，我们经常会遇到各种数据的处理、转换、迁移的场景。&lt;/p&gt;
&lt;p&gt;今天特地给大家汇总了一些目前市面上比较常用的ETL数据迁移工具，希望对大家有所帮助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据迁移" scheme="https://longchao012.github.io/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>小案例：制作《数据流图》与《业务流程图》</title>
    <link href="https://longchao012.github.io/2022/08/24/%E5%B0%8F%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%B6%E4%BD%9C%E3%80%8A%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E3%80%8B%E4%B8%8E%E3%80%8A%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%8B/"/>
    <id>https://longchao012.github.io/2022/08/24/%E5%B0%8F%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%B6%E4%BD%9C%E3%80%8A%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E3%80%8B%E4%B8%8E%E3%80%8A%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%8B/</id>
    <published>2022-08-24T03:53:12.000Z</published>
    <updated>2023-08-24T03:54:36.897Z</updated>
    
    <content type="html"><![CDATA[<p>数据流图（Data Flow Diagram, DFD）是一种便于用户理解和分析系统数据流程的图形工具，他摆脱了系统和具体内容，精确的在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。</p><span id="more"></span><h2 id="一、数据流图组成部分"><a href="#一、数据流图组成部分" class="headerlink" title="一、数据流图组成部分"></a>一、数据流图组成部分</h2><p><strong>数据流：</strong>是由一组固定成分的数据组成，表示数据的流向，除了流向数据存储或从数据存储流出的数据不必命名外，每个数据流必须要有一个合适的名字，以反映该数据流的含义</p><p><strong>加工：</strong>加工描述了输入数据流到输出数据之间的变换，也就是输入数据流经过什么处理后变成了输出数据</p><p><strong>数据存储：</strong>数据存储表示暂时存储的数据,每个数据存储都有一个名字</p><p><strong>外部实体：</strong>外部实体是存在于软件系统之外的人员或组织</p><h2 id="二、基本图形符号（重点）"><a href="#二、基本图形符号（重点）" class="headerlink" title="二、基本图形符号（重点）"></a>二、基本图形符号（重点）</h2><p>方框：表示数据的源点或终点</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE1.png" alt="数据流图1"><br>圆或椭圆：表示加工</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE2.png" alt="数据流图2"><br>箭头：表示数据流</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE3.png" alt="数据流图3"><br>双杠：表示数据存储</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE4.png" alt="数据流图4"></p><h2 id="三、实战案列"><a href="#三、实战案列" class="headerlink" title="三、实战案列"></a>三、实战案列</h2><p>题目：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE5.png" alt="数据流图5"><br>大家可以看见这个是一个机票预订系统「：黑色的字体都是关键字」，现在让我们试试画出这个数据流图。</p><p><em>航空公司 会根据 航班信息来 安排航班</em></p><p>可以看的出航空公司是一个实体，航班信息是种数据，安排航班是处理这个数据，所以我们得到以下的图。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE6.png" alt="数据流图6"></p><p><em>并将航班信息存储在订票信息中</em></p><p>上面的话可以看见将航班信息存储在订票信息中，得到下图：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE7.png" alt="数据流图7"></p><p><em>旅客订票时，旅客将旅客信息输入该系统</em></p><p>上面的话可以看出有操作了，实体是旅客，操作数据是订票行为，将信息输入该系统（订票）下图：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE8.png" alt="数据流图8"></p><p><em>系统通过旅客信息，在订票信息中查询合适的航班，并返回机票信息</em></p><p>通过上面的看见发现是系统查询并返回系统（注意：订票信息只是把名字放上面去了，没有更改图）</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE9.png" alt="数据流图9"></p><p><em>然后系统根据机票信息，打印机票</em></p><p>上面又有操作，根据机票信息这个数据流来打印机票（操作数据）得下图：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE10.png" alt="数据流图10"></p><p><em>最后将机票信息返回给旅客</em></p><p>这步就是结束了：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE11.png" alt="数据流图11"><br>好了以上就是数据流图的一个小实战，其实画图简单，只要搞清楚了实体的关系联系，基本上都是换汤不换药，轻轻松松~~~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据流图（Data Flow Diagram, DFD）是一种便于用户理解和分析系统数据流程的图形工具，他摆脱了系统和具体内容，精确的在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UML" scheme="https://longchao012.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>基于UiBot的滑动验证码检测实例</title>
    <link href="https://longchao012.github.io/2022/08/23/%E5%9F%BA%E4%BA%8EUiBot%E7%9A%84%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A3%80%E6%B5%8B%E5%AE%9E%E4%BE%8B/"/>
    <id>https://longchao012.github.io/2022/08/23/%E5%9F%BA%E4%BA%8EUiBot%E7%9A%84%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A3%80%E6%B5%8B%E5%AE%9E%E4%BE%8B/</id>
    <published>2022-08-23T09:59:20.000Z</published>
    <updated>2023-09-04T06:18:12.783Z</updated>
    
    <content type="html"><![CDATA[<p>我们在做一些自动化登录的过程中，经常会遇到各种各样的图灵检测。<br><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%811.png" alt="滑块验证1"><br>因为验证码样式多变，而且需要较多命令组合才能完成验证，所以UiBot暂时没有将验证码做为一个命令组件进行预制。难到这样就没办法了吗？</p><span id="more"></span><p>难到这样就没办法了吗？显然不是，我们可以利用RPA连接外部的特性，使用部分coding来解决此问题（使用coding也算一种连接嘛）</p><p>回到上例，一般来说这样的验证码验证有如下流程，我们把他拆分一下可得：</p><p>1、展示完整原图，说明验证方式</p><p>2、鼠标按住滑块，展现出缺陷图</p><p>3、滑动滑块到缺陷部分</p><p>其中，1、2两部我们用眼睛识别，用来测算距离，第3步用鼠标移动用来填补距离，基于这个逻辑，我们同样把整个验证的实现拆分成2个大步，那么第一步是算滑动距离，第二步就是根据滑动距离进行滑动了，下面我们根据实例来一步步进行分解实现。</p><p>实例地址：<a href="https://www.chinapay.com/index.jsp%EF%BC%88%E9%93%B6%E8%81%94%E7%9A%84%E7%99%BB%E5%BD%95%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%9A%8F%E4%BE%BF%E8%BE%93%E5%85%A5%E5%8F%AF%E8%A7%A6%E5%8F%91%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%EF%BC%89">https://www.chinapay.com/index.jsp（银联的登录地址，用户名密码随便输入可触发滑动验证）</a></p><p>要得到完整距离，首先我们要得到无缺口图和有缺口图2张图片，其中有缺口的图片需要将鼠标移到滑块上并按住才会出现，当然这也很好解决，我们可以直接使用UiBot获取这两张图，获取的方式如下：</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%812.png" alt="滑块验证2"></p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;1.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br><span class="line">Mouse.Hover(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;isleaf&quot;:&quot;1&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:3&#125;&#125;,10000,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:0,&quot;iDelayBefore&quot;:0,&quot;bSetForeground&quot;:true,&quot;sCursorPosition&quot;:&quot;Center&quot;,&quot;iCursorOffsetX&quot;:0,&quot;iCursorOffsetY&quot;:0,&quot;sKeyModifiers&quot;:[],&quot;sSimulate&quot;:&quot;simulate&quot;&#125;)</span><br><span class="line">Mouse.Click(&quot;left&quot;, &quot;down&quot;, [])</span><br><span class="line">Delay(600)</span><br><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;2.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%813.png" alt="滑块验证3"></p><p>得到两张图后我们需要测算滑动距离，如何测算呢？我们可以比对上图，发现除了缺口以外其他部分基本和原图一致（有部分干扰块，但是问题不大，因为色深不够而且水平距离不一致，我们可以通过后面的算法把他滤过），所以实际上我们只需要抓住起始点和缺陷部分的特征既可算出两者直接的距离，这里我们可以通过python进行图像处理实现，具体实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image  </span><br><span class="line">import PIL.ImageChops as imagechops</span><br><span class="line">from PIL import Image, ImageDraw,ImageFont</span><br><span class="line">import random</span><br><span class="line">def CalcDistance(srcImg,distImg):</span><br><span class="line">    im1 = Image.open(srcImg)</span><br><span class="line">    im2 = Image.open(distImg)</span><br><span class="line">    #得出两图不一致的地方</span><br><span class="line">    diff=imagechops.difference(im1, im2)</span><br><span class="line">    draw =ImageDraw.Draw(diff)</span><br><span class="line">    #通过颜色处理清除干扰块</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor[0]&gt;=100 or pixelColor[1]&gt;=100 or pixelColor[2]&gt;=100:</span><br><span class="line">                draw.line((x, y, x, y),(255,255,255,255))</span><br><span class="line">            else:</span><br><span class="line">                draw.line((x, y, x, y),(0,0,0,0))</span><br><span class="line">    # #清理完可以show一下，查看清理完之后的黑白化效果</span><br><span class="line">    # diff.show()</span><br><span class="line">    #找第一个块中的参照点</span><br><span class="line">    firsetPoint=[0,0]</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                firsetPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if firsetPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # 往后跳50找第二个块中的参照点，50是矩形宽度</span><br><span class="line">    secondPoint=[0,0]</span><br><span class="line">    for x in range(firsetPoint[0]+50,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                secondPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if secondPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # #画两条线看看位置是否标注正确，仅用于调试</span><br><span class="line">    # draw.line((firsetPoint[0], firsetPoint[1], firsetPoint[0]+20, firsetPoint[1]),(6,255,9,0))</span><br><span class="line">    # draw.line((secondPoint[0], secondPoint[1], secondPoint[0]+20, secondPoint[1]),(9,8,255,0))</span><br><span class="line">    # diff.show()</span><br><span class="line">    diffPixel=secondPoint[0]-firsetPoint[0]</span><br><span class="line">    print(diffPixel)</span><br></pre></td></tr></table></figure><p>经过上述处理后，前文的图会被处理为下图的样子，并算出两块直接的一个距离</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%814.png" alt="滑块验证4"></p><p>得到距离，接下来我们需要驱动鼠标进行滑动，这些在UiBot里面都有相应的命令可以直接使用，在第一次处理这个验证码时，我天真的以为到算出距离就已经结束，没想到实际上滑动验证码的难点恰恰是滑动轨迹的模拟。滑动验证码在滑动轨迹上同样加入了人机测验，就算本例的解决方式也只有60%的成功率(两块相隔距离较长的情况下成功率更高)。话不多说，下面直接放轨迹的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def GetStacks(distance):</span><br><span class="line">    distance += 20</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    匀加速\减速运行</span><br><span class="line">        v = v0 + a * t</span><br><span class="line">    位移:</span><br><span class="line">    s = v * t + 0.5 * a * (t**2)</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 初速度</span><br><span class="line">    v0 = 0</span><br><span class="line">    # 加减速度列表</span><br><span class="line">    a_list = [3, 4, 5]</span><br><span class="line">    # 时间</span><br><span class="line">    t = 0.2</span><br><span class="line">    # 初始位置</span><br><span class="line">    s = 0</span><br><span class="line">    # 向前滑动轨迹</span><br><span class="line">    forward_stacks = []</span><br><span class="line">    mid = distance * 3 / 5</span><br><span class="line">    while s &lt; distance:</span><br><span class="line">        if s &lt; mid:</span><br><span class="line">            a = a_list[random.randint(0, 2)]</span><br><span class="line">        else:</span><br><span class="line">            a = -a_list[random.randint(0, 2)]</span><br><span class="line">        v = v0</span><br><span class="line">        stack = v * t + 0.5 * a * (t ** 2)</span><br><span class="line">        # 每次拿到的位移</span><br><span class="line">        stack = round(stack)</span><br><span class="line">        s += stack</span><br><span class="line">        v0 = v + a * t</span><br><span class="line">        forward_stacks.append(stack)</span><br><span class="line">    back_stacks = [-1, -1, -2, -3, -2, -3, -2, -2, -3, -1]</span><br><span class="line">    return &#123;&#x27;forward_stacks&#x27;: forward_stacks, &#x27;back_stacks&#x27;: back_stacks</span><br></pre></td></tr></table></figure><p>上述轨迹实现，逻辑是模拟人以加速度的形式进行增速滑动，为了骗过人机检测，特意还有个回滑的操作，而后将轨迹以相对位移数组的形式进行返回，结合我们之前距离的测算，可以得到一个完整的python文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image  </span><br><span class="line">import PIL.ImageChops as imagechops</span><br><span class="line">from PIL import Image, ImageDraw,ImageFont</span><br><span class="line">import random</span><br><span class="line">def CalcDistance(srcImg,distImg):</span><br><span class="line">    im1 = Image.open(srcImg)</span><br><span class="line">    im2 = Image.open(distImg)</span><br><span class="line">    #得出两图不一致的地方</span><br><span class="line">    diff=imagechops.difference(im1, im2)</span><br><span class="line">    draw =ImageDraw.Draw(diff)</span><br><span class="line">    #通过颜色处理清除干扰块</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor[0]&gt;=100 or pixelColor[1]&gt;=100 or pixelColor[2]&gt;=100:</span><br><span class="line">                draw.line((x, y, x, y),(255,255,255,255))</span><br><span class="line">            else:</span><br><span class="line">                draw.line((x, y, x, y),(0,0,0,0))</span><br><span class="line">    # #清理完可以show一下，查看清理完之后的黑白化效果</span><br><span class="line">    # diff.show()</span><br><span class="line">    #找第一个块中的参照点</span><br><span class="line">    firsetPoint=[0,0]</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                firsetPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if firsetPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # 往后跳50找第二个块中的参照点，50是矩形宽度</span><br><span class="line">    secondPoint=[0,0]</span><br><span class="line">    for x in range(firsetPoint[0]+50,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                secondPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if secondPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # #画两条线看看位置是否标注正确，仅用于调试</span><br><span class="line">    # draw.line((firsetPoint[0], firsetPoint[1], firsetPoint[0]+20, firsetPoint[1]),(6,255,9,0))</span><br><span class="line">    # draw.line((secondPoint[0], secondPoint[1], secondPoint[0]+20, secondPoint[1]),(9,8,255,0))</span><br><span class="line">    # diff.show()</span><br><span class="line">    diffPixel=secondPoint[0]-firsetPoint[0]</span><br><span class="line">    return GetStacks(diffPixel)</span><br><span class="line">    </span><br><span class="line">def GetStacks(distance):</span><br><span class="line">    distance += 20</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    匀加速\减速运行</span><br><span class="line">        v = v0 + a * t</span><br><span class="line">    位移:</span><br><span class="line">    s = v * t + 0.5 * a * (t**2)</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 初速度</span><br><span class="line">    v0 = 0</span><br><span class="line">    # 加减速度列表</span><br><span class="line">    a_list = [3, 4, 5]</span><br><span class="line">    # 时间</span><br><span class="line">    t = 0.2</span><br><span class="line">    # 初始位置</span><br><span class="line">    s = 0</span><br><span class="line">    # 向前滑动轨迹</span><br><span class="line">    forward_stacks = []</span><br><span class="line">    mid = distance * 3 / 5</span><br><span class="line">    while s &lt; distance:</span><br><span class="line">        if s &lt; mid:</span><br><span class="line">            a = a_list[random.randint(0, 2)]</span><br><span class="line">        else:</span><br><span class="line">            a = -a_list[random.randint(0, 2)]</span><br><span class="line">        v = v0</span><br><span class="line">        stack = v * t + 0.5 * a * (t ** 2)</span><br><span class="line">        # 每次拿到的位移</span><br><span class="line">        stack = round(stack)</span><br><span class="line">        s += stack</span><br><span class="line">        v0 = v + a * t</span><br><span class="line">        forward_stacks.append(stack)</span><br><span class="line">    back_stacks = [-1, -1, -2, -3, -2, -3, -2, -2, -3, -1]</span><br><span class="line">    return &#123;&#x27;forward_stacks&#x27;: forward_stacks, &#x27;back_stacks&#x27;: back_stacks&#125;</span><br></pre></td></tr></table></figure><p>现在剩下的工作是将这个文件给UiBot进行使用。我们将上面的文件保存成CrackGEE.py，放到UiBot Creator的安装目录下的 extend\python下面（可参考：<a href="https://forum.uibot.com.cn/thread-51.htm%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8UiBot%E9%87%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%9A">https://forum.uibot.com.cn/thread-51.htm），然后在UiBot里面添加如下代码：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Import CrackGEE</span><br><span class="line">#icon(&quot;@res:dp3vobi1-353k-q9mp-q5oh-nicth66fv4ag.png&quot;)</span><br><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;1.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br><span class="line">#icon(&quot;@res:sod4iqf0-l79e-a7hu-n4rm-hom2l8pgvv4k.png&quot;)</span><br><span class="line">Mouse.Hover(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;isleaf&quot;:&quot;1&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:3&#125;&#125;,10000,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:0,&quot;iDelayBefore&quot;:0,&quot;bSetForeground&quot;:true,&quot;sCursorPosition&quot;:&quot;Center&quot;,&quot;iCursorOffsetX&quot;:0,&quot;iCursorOffsetY&quot;:0,&quot;sKeyModifiers&quot;:[],&quot;sSimulate&quot;:&quot;simulate&quot;&#125;)</span><br><span class="line">Mouse.Click(&quot;left&quot;, &quot;down&quot;, [])</span><br><span class="line">Delay(600)</span><br><span class="line">#icon(&quot;@res:dp3vobi1-353k-q9mp-q5oh-nicth66fv4ag.png&quot;)</span><br><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;2.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br><span class="line">dim 点列表=[]</span><br><span class="line">点列表=CrackGEE.CalcDistance(&quot;1.png&quot;,&quot;2.png&quot;)</span><br><span class="line">TracePrint(点列表)</span><br><span class="line">Dim 正向移动=点列表[&quot;forward_stacks&quot;]</span><br><span class="line">Dim 回移=点列表[&quot;back_stacks&quot;]</span><br><span class="line">For Each value In 正向移动</span><br><span class="line"> Mouse.Move(value, 0, true)</span><br><span class="line">Delay(12)</span><br><span class="line">Next</span><br><span class="line">For Each value In 回移</span><br><span class="line"> Mouse.Move(value, 0, true)</span><br><span class="line">Delay(34)</span><br><span class="line">Next</span><br><span class="line">Delay(200)</span><br><span class="line">Mouse.Click(&quot;left&quot;, &quot;up&quot;, [])</span><br></pre></td></tr></table></figure><p>视图:</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%815.png" alt="滑块验证5"></p><p>在使用chrome打开银联网站,随便输入用户名密码，呼出验证，停留在如下图所示地方：</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%816.png" alt="滑块验证6"></p><p>点击UiBot Creator的运行，即可看到效果。<br><video src="/images/滑块验证7.mp4" controls="controls">您的浏览器不支持播放该视频！</video></p><p>本例权当抛砖引玉，实际上在短距离的比对计算还有滑动轨迹上面还有不小的提升空间，有兴趣的大神可以进一步进行扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在做一些自动化登录的过程中，经常会遇到各种各样的图灵检测。&lt;br&gt;&lt;img src=&quot;/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%811.png&quot; alt=&quot;滑块验证1&quot;&gt;&lt;br&gt;因为验证码样式多变，而且需要较多命令组合才能完成验证，所以UiBot暂时没有将验证码做为一个命令组件进行预制。难到这样就没办法了吗？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA办公自动化" scheme="https://longchao012.github.io/tags/RPA%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>基于Java的单表100万数据，写入、更新、读取、删除速度的测试验证！</title>
    <link href="https://longchao012.github.io/2022/08/21/%E5%8D%95%E8%A1%A8100%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%86%99%E5%85%A5%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E8%AF%BB%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E9%80%9F%E5%BA%A6%E7%9A%84%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%EF%BC%81/"/>
    <id>https://longchao012.github.io/2022/08/21/%E5%8D%95%E8%A1%A8100%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%86%99%E5%85%A5%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E8%AF%BB%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E9%80%9F%E5%BA%A6%E7%9A%84%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%EF%BC%81/</id>
    <published>2022-08-21T06:39:15.000Z</published>
    <updated>2023-09-04T06:18:21.335Z</updated>
    
    <content type="html"><![CDATA[<p>本文将通过简单干净的实践方式，向读者展示在使用不同连接池以及不使用连接池的情况下，SpringBoot应用程序对接MySQL进行增删改查的性能对比。同时，还将探讨更新和查询时索引字段的关键性。</p><p>在开始之前，让我们先来思考一个问题：一张拥有21个字段的表，存放着100万条数据，会占用多少空间容量？如果这100万条数据在不使用连接池的方式下，以10个并发每条一条插入，需要多长时间？</p><p>根据经验，问题1大约需要350MB左右的空间容量，而问题2可能需要2到3小时的时间。尽管这些数字可能因机器配置而异，但重要的是你可以亲自验证它们。本文将使用ApacheBench对MySQL连接池进行压测，帮助读者更好地了解相关知识。</p><p>通过这个实践，我们可以得出结论：在使用连接池的情况下，SpringBoot应用程序对接MySQL的性能明显优于不使用连接池的情况。无论是插入、删除、更新还是查询操作，连接池都能够显著减少等待时间和资源消耗。</p><p>此外，索引字段在更新和查询时起着关键的作用。合适的索引可以提高查询效率并减少扫描的数据量。因此，在设计数据库结构时，我们应该仔细考虑如何合理地使用索引。</p><p>希望本文能够帮助读者更好地理解SpringBoot应用程序对接MySQL时连接池的重要性以及性能优化的方法。通过实践和实验，我们可以更加深入地了解并应用这些知识。</p><span id="more"></span><p>本文涉及的工程：</p><p>xfg-dev-tech-connection-pool：<a href="https://gitcode.net/KnowledgePlanet/road-map/xfg-dev-tech-connection-pool">https://gitcode.net/KnowledgePlanet/road-map/xfg-dev-tech-connection-pool</a> - 工程内含有环境的安装脚本；mysql-docker-compose.yml、apachebench-docker-compose.yml、road_map_8.0.sql</p><h2 id="一、案例背景"><a href="#一、案例背景" class="headerlink" title="一、案例背景"></a>一、案例背景</h2><p><strong>拿100万订单数据，压到数据库中！</strong></p><p>初始化一个空的数据库表，并向数据库表中写入100万数据。之后在分别不使用连接池和使用不同的连接池(c3p0、dbcp、druid、hikari)写入数据，测试各个连接池的性能。这也能让大家知道，日常我们应该选择哪个连接池。</p><h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><p>因为本章节很偏实操，所以需要大家做下提前安装好 Docker 环境，以便于执行本章节工程中的脚本和代码。可参考别的教程里面 Docker、Portainer 学习安装和使用。<br><img src="/images/MySQL_docker.png" alt="docker安装"><br>1.在 IntelliJ IDEA 打开 xfg-dev-tech-connection-pool 分别点开 mysql-docker-compose、apachebench-docker-compose，之后点击安装即可。<br>2.执行完脚本，你可以得到一份安装好的 MySQL 8.0 并安装了数据库表。另外一份是用于压测使用的 ApacheBench<br>3.连接 MySQL 的工具，推荐使用开源免费的 Sequel Ace</p><h2 id="三、工程说明"><a href="#三、工程说明" class="headerlink" title="三、工程说明"></a>三、工程说明</h2><p>在 xfg-dev-tech-connection-pool 工程中提供了不同连接池的配置和一些非常常用的 SQL 操作，以及提供了对应的接口进行压测使用；</p><table><thead><tr><th>序号</th><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a></td><td>用于缓存数据的接口，拿缓存好的数据压测更新、查询</td></tr><tr><td>2</td><td><a href="http://127.0.0.1:8091/api/mysql/insert">http://127.0.0.1:8091/api/mysql/insert</a></td><td>插入数据接口</td></tr><tr><td>3</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId">http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId</a></td><td>使用索引字段 userId 更新订单状态</td></tr><tr><td>4</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile">http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile</a></td><td>使用无索引字段 userMobile 更新订单状态</td></tr><tr><td>5</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId">http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId</a></td><td>使用索引字段 orderId 更新订单状态</td></tr><tr><td>6</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserId">http://127.0.0.1:8091/api/mysql/selectByUserId</a></td><td>使用索引字段 userId 查询订单</td></tr><tr><td>7</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserMobile">http://127.0.0.1:8091/api/mysql/selectByUserMobile</a></td><td>使用无索引字段 userMobile 查询订单，测试中添加索引</td></tr><tr><td>8</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByOrderId">http://127.0.0.1:8091/api/mysql/selectByOrderId</a></td><td>使用有索引字段 orderId 查询订单</td></tr><tr><td>9</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId">http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId</a></td><td>区分度高的索引字段在前，区分度低的索引字段在后</td></tr><tr><td>10</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId">http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId</a></td><td>区分度低的索引字段在前，区分度高的索引字段在后</td></tr></tbody></table><p>具体代码实现可以直接对照工程来看，以及按需添加SQL语句进行性能压测验证。</p><h2 id="四、库表语句"><a href="#四、库表语句" class="headerlink" title="四、库表语句"></a>四、库表语句</h2><p>SQL：xfg-dev-tech-connection-pool&#x2F;docs&#x2F;sql&#x2F;road_map_8.0.sql<br><img src="/images/MySQL_User_order.png" alt="User表结构"><br>这是本节所需要测试的一个订单表和测试前所建的索引字段。以及初始化了100万数据，占用350M空间。<br>接下来，我们就可以做测试验证了。</p><h2 id="五、压测指令"><a href="#五、压测指令" class="headerlink" title="五、压测指令"></a>五、压测指令</h2><p>ApacheBench 官网教程：<a href="https://httpd.apache.org/docs/2.4/programs/ab.html">https://httpd.apache.org/docs/2.4/programs/ab.html</a><br><img src="/images/ApacheBench%E5%AE%98%E7%BD%91%E6%95%99%E7%A8%8B.png" alt="ApacheBench官网教程"><br>常用的如：<br><code>ab -c 20 -n 1000</code><br><a href="http://127.0.0.1:8091/hi">http://127.0.0.1:8091/hi</a> - 20个并发1000次</p><h2 id="六、压测验证"><a href="#六、压测验证" class="headerlink" title="六、压测验证"></a>六、压测验证</h2><p>首先在测试前，正式测试前，你大概需要花费几十分钟来初始化100万数据。<br>执行脚本；<br><code>ab -c 20 -n 1000000</code><br><a href="http://127.0.0.1:8091/api/mysql/insert">http://127.0.0.1:8091/api/mysql/insert</a> - 如果你在工程中配置了 no-pool 大概要花费几个小时才能跑完，这就使用和不使用连接池的差距。</p><ol><li>连接池比对<br>条件；</li></ol><p>插入1万条数据<br>连接池配置 initialPoolSize&#x3D;5、minPoolSize&#x3D;5、maxPoolSize&#x3D;20<br>此时数据库已经有100万数据，分别用几个链接方式插入数据。hikari 放到最后，它是 SpringBoot 的默认连接池。<br>脚本；<br><code>ab -c 20 -n 10000 http://127.0.0.1:8091/api/mysql/insert</code></p><table><thead><tr><th></th><th>no-pool</th><th>c3p0</th><th>dbcp</th><th>druid</th><th>hikari</th></tr></thead><tbody><tr><td>耗时</td><td>88.990 seconds</td><td>24.228 seconds</td><td>33.656 seconds</td><td>25.971 seconds</td><td>25.002 seconds</td></tr><tr><td>50%</td><td>155ms</td><td>39ms</td><td>60ms</td><td>45ms</td><td>43ms</td></tr><tr><td>80%</td><td>223ms</td><td>61ms</td><td>86ms</td><td>64ms</td><td>64ms</td></tr><tr><td>90%</td><td>291ms</td><td>75ms</td><td>103ms</td><td>75ms</td><td>76ms</td></tr></tbody></table><p>通过对比可以发现，如果不使用连接池，会比使用连接池，要占用更多的时间连接数据库使用数据库。<br>c3p0、hikari 的性能还是非常不错的，dbcp 相对是弱一些的。所以这可以给你在使用连接池时有一个参考。也可以结合你的机器再次进行压测验证。<br>2. 更新对比<br>条件；</p><p>使用接口，向内存加入600条数据。每个测试方式，分别消耗200条。ab -c 10 -n 600 <a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a><br>之后使用无索引字段、有索引但区分度不高的字段以及使用有索引区分度非常好的字段来更新。<br>脚本；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile</span><br><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId</span><br><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>无索引</th><th>有索引-区分度不高</th><th>有索引-区分度很高</th></tr></thead><tbody><tr><td>耗时</td><td>24小时+</td><td>24小时+</td><td>0.432 seconds</td></tr><tr><td>50%</td><td>24小时+</td><td>24小时+</td><td>35ms</td></tr><tr><td>80%</td><td>24小时+</td><td>24小时+</td><td>48ms</td></tr><tr><td></td><td>90%</td><td>24小时+</td><td>24小时+</td></tr></tbody></table><p>无索引的时候；会把整个表的这个记录，全部锁上。那么越执行越慢，最后拖垮数据库。甚至可能1天都执行不完。<br>有索引-区分度不高；几乎是一样的，如果你批量的对一个用户的所有数据都更新，也会锁很多记录。<br>有索引-区分度很高；只要你锁的是自己的一条记录，就与别人没有影响。效率也会非常高。<br>3. 查询对比<br>条件；</p><p>查询100万加的数据库表记录，每次缓存记录5000条数据id；ab -c 10 -n 5000 <a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a><br>userId 有索引、orderId 有索引、userMobie 无索引。<br>每次查询的时候，都要关闭服务重启，避免有缓存干扰结果。<br>脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserMobile</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByOrderId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>无索引</th><th>有索引-区分度不高</th><th>有索引区分度高</th><th>高在前</th><th>低在前</th></tr></thead><tbody><tr><td>耗时</td><td>6小时+</td><td>8.343 seconds</td><td>2.051 seconds</td><td>2.168 seconds</td><td>3.279 seconds</td></tr><tr><td>50%</td><td>7s</td><td>13ms</td><td>7ms</td><td>7ms</td><td>11ms</td></tr><tr><td>80%</td><td>9s</td><td>20ms</td><td>10ms</td><td>11ms</td><td>17ms</td></tr><tr><td>90%</td><td>15s</td><td>26ms</td><td>13ms</td><td>13ms</td><td>22ms</td></tr></tbody></table><p>无索引，还是查询字段的。非常危险。<br>不要在一些区分度不高的字段建索引。当然本案例中，userId 最多也就1000来个用户所产生的1百万数据，这样的情况更适合分库分表。<br>区分度很高的字段，查询效率会非常好。<br>把高区分度的索引字段放在前面，更有利于查询。—— 注意不要测试完上一个，直接测试下一个。有缓存的情况下，会影响对比结果。<br>这就是整个数据库表的压测过程了。如果你有使用的诉求，需要做技术调研，那么一定要做一些这样的压测处理。这样有真实数据才好讲道理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将通过简单干净的实践方式，向读者展示在使用不同连接池以及不使用连接池的情况下，SpringBoot应用程序对接MySQL进行增删改查的性能对比。同时，还将探讨更新和查询时索引字段的关键性。&lt;/p&gt;
&lt;p&gt;在开始之前，让我们先来思考一个问题：一张拥有21个字段的表，存放着100万条数据，会占用多少空间容量？如果这100万条数据在不使用连接池的方式下，以10个并发每条一条插入，需要多长时间？&lt;/p&gt;
&lt;p&gt;根据经验，问题1大约需要350MB左右的空间容量，而问题2可能需要2到3小时的时间。尽管这些数字可能因机器配置而异，但重要的是你可以亲自验证它们。本文将使用ApacheBench对MySQL连接池进行压测，帮助读者更好地了解相关知识。&lt;/p&gt;
&lt;p&gt;通过这个实践，我们可以得出结论：在使用连接池的情况下，SpringBoot应用程序对接MySQL的性能明显优于不使用连接池的情况。无论是插入、删除、更新还是查询操作，连接池都能够显著减少等待时间和资源消耗。&lt;/p&gt;
&lt;p&gt;此外，索引字段在更新和查询时起着关键的作用。合适的索引可以提高查询效率并减少扫描的数据量。因此，在设计数据库结构时，我们应该仔细考虑如何合理地使用索引。&lt;/p&gt;
&lt;p&gt;希望本文能够帮助读者更好地理解SpringBoot应用程序对接MySQL时连接池的重要性以及性能优化的方法。通过实践和实验，我们可以更加深入地了解并应用这些知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="https://longchao012.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>基于UiBot开发的RPA项目各类银行操作流程(银行流水下载、自动填写付款单等)</title>
    <link href="https://longchao012.github.io/2022/08/16/%E5%9F%BA%E4%BA%8EUiBot%E5%BC%80%E5%8F%91%E7%9A%84RPA%E9%A1%B9%E7%9B%AE%E9%93%B6%E8%A1%8C%E6%B5%81%E6%B0%B4%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
    <id>https://longchao012.github.io/2022/08/16/%E5%9F%BA%E4%BA%8EUiBot%E5%BC%80%E5%8F%91%E7%9A%84RPA%E9%A1%B9%E7%9B%AE%E9%93%B6%E8%A1%8C%E6%B5%81%E6%B0%B4%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B/</id>
    <published>2022-08-16T02:10:22.000Z</published>
    <updated>2023-09-04T06:18:01.631Z</updated>
    
    <content type="html"><![CDATA[<p>基于UiBot开发的RPA项目银行流水下载流程<br>做过很多关于银行相关的RPA项目，本次主要以UIBot这个工具来实施的银行相关RPA项目。使用的UiBot Creator 5.6的版本，后续更新为6.0版本。涉及的银行有中国银行，工商银行，民生银行，光大银行，农业银行等多少银行。有通过C&#x2F;S访问的，也有通过B&#x2F;S访问的。客户方面都没有做太多的限制，能满足业务需要即可。开发的周期，看业务需求的范围与数据结构的复杂度。如果有对账，数据转换等需求的项目可能时间会相对长一点，如果只是单纯的下载流水或填写付款单等待，那基本会很快，时间可以控制在一到两周以内。<br>目前为止。接受到的需求主要有以下几种：<br>1.流水查询(一般会跟着有有自动对账需求)<br>2.付款单填写<br>总体来说，就是资金的借与贷的变化。除此无它！</p><p>那么我们开发的过程中可能会遇到什么问题呢？</p><span id="more"></span><h2 id="开发过程中可能会遇到的问题"><a href="#开发过程中可能会遇到的问题" class="headerlink" title="开发过程中可能会遇到的问题"></a>开发过程中可能会遇到的问题</h2><h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>做银行相关的项目，其中最重要的也是客户最关心的就是安全性问题，就以目前的项目来说，安全性其它不太用顾虑。因为如果是查流水，没有太多的资金的上担忧，只是简单的查。而且数据也不是那么容易泄漏的，主要是有三个方面的防护<br>1.物理性的防护，通过保护电脑与主机还有Ukey(主要)，在使用的时候才插入Ukey即可。<br>2.登录密码的防护，可以把密码写入到Window的凭证中，通过UiBot内置的组件来读取，开发人员也不知道这个密码是什么。<br>3.严密的保存交易密码。RPA流程不会涉及到交易密码，也不建议把交易密码暴露出来让RPA机器人使用。</p><h3 id="需求中的问题"><a href="#需求中的问题" class="headerlink" title="需求中的问题"></a>需求中的问题</h3><p>主要是个别客户的对账的过程复杂，需要考虑的因素特别多，对账时候的数据非标准数据，需要很多的数据转换。这其中的过程遇到很多的困难。<br>同时，有时候客户自身对需求的细节也会判定不足，导致开发过程中进行不下去，项目周末延长。</p><h3 id="银行系统的限制问题"><a href="#银行系统的限制问题" class="headerlink" title="银行系统的限制问题"></a>银行系统的限制问题</h3><p>银行系统会监测你的行为还有不允许有远程之类的操作。不能让远程控制输入密码。可以调用驱动级的键盘输入解决问题。部分银行的系统的C&#x2F;S端元素的布局是比较混乱的，元素明明在A点，坐标却是偏到了天边的B点，而很多的控件或元素都是无法获取到对应的元素坐标。不知道是出于安全还是其它方面的考虑。这个没有太好的解决办法，只能一点点的适配与调节。而相比B&#x2F;S端这种情况就会好很多，但是很多客户的电脑配置都不太好，而且银行对浏览器的支持也是强差人意。只能根据每个客户做相对应的调整与配置。</p><h3 id="现场运行环境问题"><a href="#现场运行环境问题" class="headerlink" title="现场运行环境问题"></a>现场运行环境问题</h3><p>环境问题大部分是性能问题，有的客户的电脑是很破旧的电脑，有的客户的电脑还运行着Windows7或Windows XP。实在是太难啦。这个没什么解决的办法，只能尽量的沟通协调，不行就让RPA流程慢下来，通过不断的试错慢慢的适配比较差的电脑环境。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于UiBot开发的RPA项目银行流水下载流程&lt;br&gt;做过很多关于银行相关的RPA项目，本次主要以UIBot这个工具来实施的银行相关RPA项目。使用的UiBot Creator 5.6的版本，后续更新为6.0版本。涉及的银行有中国银行，工商银行，民生银行，光大银行，农业银行等多少银行。有通过C&amp;#x2F;S访问的，也有通过B&amp;#x2F;S访问的。客户方面都没有做太多的限制，能满足业务需要即可。开发的周期，看业务需求的范围与数据结构的复杂度。如果有对账，数据转换等需求的项目可能时间会相对长一点，如果只是单纯的下载流水或填写付款单等待，那基本会很快，时间可以控制在一到两周以内。&lt;br&gt;目前为止。接受到的需求主要有以下几种：&lt;br&gt;1.流水查询(一般会跟着有有自动对账需求)&lt;br&gt;2.付款单填写&lt;br&gt;总体来说，就是资金的借与贷的变化。除此无它！&lt;/p&gt;
&lt;p&gt;那么我们开发的过程中可能会遇到什么问题呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA办公自动化" scheme="https://longchao012.github.io/tags/RPA%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>我们应该从哪些方面思考公司场景是否适合RPA流程自动化</title>
    <link href="https://longchao012.github.io/2022/07/16/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%80%9D%E8%80%83%E5%85%AC%E5%8F%B8%E5%9C%BA%E6%99%AF%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88RPA%E6%B5%81%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>https://longchao012.github.io/2022/07/16/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%80%9D%E8%80%83%E5%85%AC%E5%8F%B8%E5%9C%BA%E6%99%AF%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88RPA%E6%B5%81%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96/</id>
    <published>2022-07-16T07:23:41.000Z</published>
    <updated>2023-09-04T06:17:56.847Z</updated>
    
    <content type="html"><![CDATA[<p>随着科技的发展，RPA（Robotic Process Automation）流程自动化已经成为企业提升效率，降低成本的重要工具。我们需要理解RPA的基本概念和特性。RPA是一种可以模拟和复制人类在应用程序中执行的重复任务的技术，它可以24&#x2F;7不间断工作，不需要休息，也不需要假期。这种特性使得RPA非常适合处理大量的、重复的、规则化的任务。<br>那么那些场景或需求合适使用自动化呢？</p><span id="more"></span><h2 id="流程适合性"><a href="#流程适合性" class="headerlink" title="流程适合性"></a>流程适合性</h2><p>您可以使用以下标准评估流程是否适合自动化：</p><h3 id="基于规则"><a href="#基于规则" class="headerlink" title="基于规则"></a>基于规则</h3><p>可通过预定义逻辑捕获在流程中做出的决策（包括数据解释）。这样带来的结果是，异常率要么很低，要么包含在业务逻辑中。</p><h3 id="可自动化和-或重复性流程"><a href="#可自动化和-或重复性流程" class="headerlink" title="可自动化和&#x2F;或重复性流程"></a>可自动化和&#x2F;或重复性流程</h3><p>我们可以区分4种类型的流程：<br>手动非重复性流程：由人工执行且每次执行该流程时都有不同的流程步骤<br>手动重复性流程：由用户执行，并且每次至少有部分相同的流程步骤<br>半自动化重复性流程：其中一些重复的步骤已经实现自动化（使用宏、Outlook 规则等）<br>自动化流程：已使用除 RPA 之外的其他技术实现自动化的流程<br>由于异常率高或无法集成到业务逻辑中的因素，仍然需要手动执行或非重复性的流程并非自动化的理想选择。</p><h3 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h3><p>流程中的输入应采用电子形式且易于读取，或者可以使用与 RPA 相关的技术（例如 OCR）进行读取。预定义字段的发票就是很好的例子。</p><h3 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h3><p>在一定时期内相同且在接下来的几个月内预计不会发生任何变化的流程适合自动化，前提是它们也符合另一个标准。</p><h2 id="自动化的复杂性"><a href="#自动化的复杂性" class="headerlink" title="自动化的复杂性"></a>自动化的复杂性</h2><p>这套标准用于确定实现流程自动化的难度：</p><h3 id="界面数量"><a href="#界面数量" class="headerlink" title="界面数量"></a>界面数量</h3><p>RPA的工作原理是，通过对机器人进行编程，使其可以在界面级别执行任务（当界面更改时，机器人必须学习逻辑）。界面数量越多，在实现流程自动化之前必须捕获和配置的元素就越多。</p><h3 id="应用程序的类型"><a href="#应用程序的类型" class="headerlink" title="应用程序的类型"></a>应用程序的类型</h3><p>有些应用程序较易实现自动化（例如 Office套件或浏览器），而有些则需要大量工作才能实现自动化（例如大型机）。随着应用程序的差异越大，界面数量也会随之增加（参见上一点）。</p><h3 id="业务逻辑场景"><a href="#业务逻辑场景" class="headerlink" title="业务逻辑场景"></a>业务逻辑场景</h3><p>自动化的复杂性随着业务逻辑中决策点的数量而增加。基本上，每个决策点乘二即可得出场景数量。</p><h3 id="输入的类型和数量"><a href="#输入的类型和数量" class="headerlink" title="输入的类型和数量"></a>输入的类型和数量</h3><p>如前所述，需要使用标准输入。但在某些情况下，必须为将受到自动化影响的所有供应商配置一个标准输入（例如发票）。此外，非标准输入可以分为不同的复杂性等级，其中自由文本是最复杂的。</p><h2 id="评估自动化潜力"><a href="#评估自动化潜力" class="headerlink" title="评估自动化潜力"></a>评估自动化潜力</h2><h3 id="不使用RPA"><a href="#不使用RPA" class="headerlink" title="不使用RPA"></a>不使用RPA</h3><p>频繁变化、系统环境多变且需要执行多个手动（甚至非数字）操作的流程。</p><h3 id="半自动化"><a href="#半自动化" class="headerlink" title="半自动化"></a>半自动化</h3><p>可以分解为可明确自动化的步骤和仍需手动执行的步骤（例如验证或使用物理安全性令牌）的流程。</p><h3 id="高成本RPA"><a href="#高成本RPA" class="headerlink" title="高成本RPA"></a>高成本RPA</h3><p>数字化程度较高并且可以实现自动化的流程，但需要使用一些复杂的技术（例如 OCR）或需要具备高级编程技能。</p><h3 id="零接触自动化"><a href="#零接触自动化" class="headerlink" title="零接触自动化"></a>零接触自动化</h3><p>涉及高度静态的系统和流程环境的数字化流程，这些流程很容易就能分解为指令并且可以定义简单的触发器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着科技的发展，RPA（Robotic Process Automation）流程自动化已经成为企业提升效率，降低成本的重要工具。我们需要理解RPA的基本概念和特性。RPA是一种可以模拟和复制人类在应用程序中执行的重复任务的技术，它可以24&amp;#x2F;7不间断工作，不需要休息，也不需要假期。这种特性使得RPA非常适合处理大量的、重复的、规则化的任务。&lt;br&gt;那么那些场景或需求合适使用自动化呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA办公自动化" scheme="https://longchao012.github.io/tags/RPA%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hello World For LongChao</title>
    <link href="https://longchao012.github.io/2022/07/15/hello-world/"/>
    <id>https://longchao012.github.io/2022/07/15/hello-world/</id>
    <published>2022-07-15T07:23:41.000Z</published>
    <updated>2023-08-23T10:15:26.188Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
