<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://longchao012.github.io/atom.xml" rel="self"/>
  
  <link href="https://longchao012.github.io/"/>
  <updated>2023-08-21T09:47:17.461Z</updated>
  <id>https://longchao012.github.io/</id>
  
  <author>
    <name>龙超小站</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Java的单表100万数据，写入、更新、读取、删除速度的测试验证！</title>
    <link href="https://longchao012.github.io/2022/08/21/%E5%8D%95%E8%A1%A8100%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%86%99%E5%85%A5%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E8%AF%BB%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E9%80%9F%E5%BA%A6%E7%9A%84%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%EF%BC%81/"/>
    <id>https://longchao012.github.io/2022/08/21/%E5%8D%95%E8%A1%A8100%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%86%99%E5%85%A5%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E8%AF%BB%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E9%80%9F%E5%BA%A6%E7%9A%84%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%EF%BC%81/</id>
    <published>2022-08-21T06:39:15.000Z</published>
    <updated>2023-08-21T09:47:17.461Z</updated>
    
    <content type="html"><![CDATA[<p>本文将通过简单干净的实践方式，向读者展示在使用不同连接池以及不使用连接池的情况下，SpringBoot应用程序对接MySQL进行增删改查的性能对比。同时，还将探讨更新和查询时索引字段的关键性。</p><p>在开始之前，让我们先来思考一个问题：一张拥有21个字段的表，存放着100万条数据，会占用多少空间容量？如果这100万条数据在不使用连接池的方式下，以10个并发每条一条插入，需要多长时间？</p><p>根据经验，问题1大约需要350MB左右的空间容量，而问题2可能需要2到3小时的时间。尽管这些数字可能因机器配置而异，但重要的是你可以亲自验证它们。本文将使用ApacheBench对MySQL连接池进行压测，帮助读者更好地了解相关知识。</p><p>通过这个实践，我们可以得出结论：在使用连接池的情况下，SpringBoot应用程序对接MySQL的性能明显优于不使用连接池的情况。无论是插入、删除、更新还是查询操作，连接池都能够显著减少等待时间和资源消耗。</p><p>此外，索引字段在更新和查询时起着关键的作用。合适的索引可以提高查询效率并减少扫描的数据量。因此，在设计数据库结构时，我们应该仔细考虑如何合理地使用索引。</p><p>希望本文能够帮助读者更好地理解SpringBoot应用程序对接MySQL时连接池的重要性以及性能优化的方法。通过实践和实验，我们可以更加深入地了解并应用这些知识。</p><span id="more"></span><p>本文涉及的工程：</p><p>xfg-dev-tech-connection-pool：<a href="https://gitcode.net/KnowledgePlanet/road-map/xfg-dev-tech-connection-pool">https://gitcode.net/KnowledgePlanet/road-map/xfg-dev-tech-connection-pool</a> - 工程内含有环境的安装脚本；mysql-docker-compose.yml、apachebench-docker-compose.yml、road_map_8.0.sql</p><h2 id="一、案例背景"><a href="#一、案例背景" class="headerlink" title="一、案例背景"></a>一、案例背景</h2><p><strong>拿100万订单数据，压到数据库中！</strong></p><p>初始化一个空的数据库表，并向数据库表中写入100万数据。之后在分别不使用连接池和使用不同的连接池(c3p0、dbcp、druid、hikari)写入数据，测试各个连接池的性能。这也能让大家知道，日常我们应该选择哪个连接池。</p><h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><p>因为本章节很偏实操，所以需要大家做下提前安装好 Docker 环境，以便于执行本章节工程中的脚本和代码。可参考别的教程里面 Docker、Portainer 学习安装和使用。<br><img src="/images/MySQL_docker.png" alt="docker安装"><br>1.在 IntelliJ IDEA 打开 xfg-dev-tech-connection-pool 分别点开 mysql-docker-compose、apachebench-docker-compose，之后点击安装即可。<br>2.执行完脚本，你可以得到一份安装好的 MySQL 8.0 并安装了数据库表。另外一份是用于压测使用的 ApacheBench<br>3.连接 MySQL 的工具，推荐使用开源免费的 Sequel Ace</p><h2 id="三、工程说明"><a href="#三、工程说明" class="headerlink" title="三、工程说明"></a>三、工程说明</h2><p>在 xfg-dev-tech-connection-pool 工程中提供了不同连接池的配置和一些非常常用的 SQL 操作，以及提供了对应的接口进行压测使用；</p><table><thead><tr><th>序号</th><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a></td><td>用于缓存数据的接口，拿缓存好的数据压测更新、查询</td></tr><tr><td>2</td><td><a href="http://127.0.0.1:8091/api/mysql/insert">http://127.0.0.1:8091/api/mysql/insert</a></td><td>插入数据接口</td></tr><tr><td>3</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId">http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId</a></td><td>使用索引字段 userId 更新订单状态</td></tr><tr><td>4</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile">http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile</a></td><td>使用无索引字段 userMobile 更新订单状态</td></tr><tr><td>5</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId">http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId</a></td><td>使用索引字段 orderId 更新订单状态</td></tr><tr><td>6</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserId">http://127.0.0.1:8091/api/mysql/selectByUserId</a></td><td>使用索引字段 userId 查询订单</td></tr><tr><td>7</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserMobile">http://127.0.0.1:8091/api/mysql/selectByUserMobile</a></td><td>使用无索引字段 userMobile 查询订单，测试中添加索引</td></tr><tr><td>8</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByOrderId">http://127.0.0.1:8091/api/mysql/selectByOrderId</a></td><td>使用有索引字段 orderId 查询订单</td></tr><tr><td>9</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId">http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId</a></td><td>区分度高的索引字段在前，区分度低的索引字段在后</td></tr><tr><td>10</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId">http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId</a></td><td>区分度低的索引字段在前，区分度高的索引字段在后</td></tr></tbody></table><p>具体代码实现可以直接对照工程来看，以及按需添加SQL语句进行性能压测验证。</p><h2 id="四、库表语句"><a href="#四、库表语句" class="headerlink" title="四、库表语句"></a>四、库表语句</h2><p>SQL：xfg-dev-tech-connection-pool&#x2F;docs&#x2F;sql&#x2F;road_map_8.0.sql<br><img src="/images/MySQL_User_order.png" alt="User表结构"><br>这是本节所需要测试的一个订单表和测试前所建的索引字段。以及初始化了100万数据，占用350M空间。<br>接下来，我们就可以做测试验证了。</p><h2 id="五、压测指令"><a href="#五、压测指令" class="headerlink" title="五、压测指令"></a>五、压测指令</h2><p>ApacheBench 官网教程：<a href="https://httpd.apache.org/docs/2.4/programs/ab.html">https://httpd.apache.org/docs/2.4/programs/ab.html</a><br><img src="/images/ApacheBench%E5%AE%98%E7%BD%91%E6%95%99%E7%A8%8B.png" alt="ApacheBench官网教程"><br>常用的如：<br><code>ab -c 20 -n 1000</code><br><a href="http://127.0.0.1:8091/hi">http://127.0.0.1:8091/hi</a> - 20个并发1000次</p><h2 id="六、压测验证"><a href="#六、压测验证" class="headerlink" title="六、压测验证"></a>六、压测验证</h2><p>首先在测试前，正式测试前，你大概需要花费几十分钟来初始化100万数据。<br>执行脚本；<br><code>ab -c 20 -n 1000000</code><br><a href="http://127.0.0.1:8091/api/mysql/insert">http://127.0.0.1:8091/api/mysql/insert</a> - 如果你在工程中配置了 no-pool 大概要花费几个小时才能跑完，这就使用和不使用连接池的差距。</p><ol><li>连接池比对<br>条件；</li></ol><p>插入1万条数据<br>连接池配置 initialPoolSize&#x3D;5、minPoolSize&#x3D;5、maxPoolSize&#x3D;20<br>此时数据库已经有100万数据，分别用几个链接方式插入数据。hikari 放到最后，它是 SpringBoot 的默认连接池。<br>脚本；<br><code>ab -c 20 -n 10000 http://127.0.0.1:8091/api/mysql/insert</code></p><table><thead><tr><th></th><th>no-pool</th><th>c3p0</th><th>dbcp</th><th>druid</th><th>hikari</th></tr></thead><tbody><tr><td>耗时</td><td>88.990 seconds</td><td>24.228 seconds</td><td>33.656 seconds</td><td>25.971 seconds</td><td>25.002 seconds</td></tr><tr><td>50%</td><td>155ms</td><td>39ms</td><td>60ms</td><td>45ms</td><td>43ms</td></tr><tr><td>80%</td><td>223ms</td><td>61ms</td><td>86ms</td><td>64ms</td><td>64ms</td></tr><tr><td>90%</td><td>291ms</td><td>75ms</td><td>103ms</td><td>75ms</td><td>76ms</td></tr></tbody></table><p>通过对比可以发现，如果不使用连接池，会比使用连接池，要占用更多的时间连接数据库使用数据库。<br>c3p0、hikari 的性能还是非常不错的，dbcp 相对是弱一些的。所以这可以给你在使用连接池时有一个参考。也可以结合你的机器再次进行压测验证。<br>2. 更新对比<br>条件；</p><p>使用接口，向内存加入600条数据。每个测试方式，分别消耗200条。ab -c 10 -n 600 <a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a><br>之后使用无索引字段、有索引但区分度不高的字段以及使用有索引区分度非常好的字段来更新。<br>脚本；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile</span><br><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId</span><br><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>无索引</th><th>有索引-区分度不高</th><th>有索引-区分度很高</th></tr></thead><tbody><tr><td>耗时</td><td>24小时+</td><td>24小时+</td><td>0.432 seconds</td></tr><tr><td>50%</td><td>24小时+</td><td>24小时+</td><td>35ms</td></tr><tr><td>80%</td><td>24小时+</td><td>24小时+</td><td>48ms</td></tr><tr><td></td><td>90%</td><td>24小时+</td><td>24小时+</td></tr></tbody></table><p>无索引的时候；会把整个表的这个记录，全部锁上。那么越执行越慢，最后拖垮数据库。甚至可能1天都执行不完。<br>有索引-区分度不高；几乎是一样的，如果你批量的对一个用户的所有数据都更新，也会锁很多记录。<br>有索引-区分度很高；只要你锁的是自己的一条记录，就与别人没有影响。效率也会非常高。<br>3. 查询对比<br>条件；</p><p>查询100万加的数据库表记录，每次缓存记录5000条数据id；ab -c 10 -n 5000 <a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a><br>userId 有索引、orderId 有索引、userMobie 无索引。<br>每次查询的时候，都要关闭服务重启，避免有缓存干扰结果。<br>脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserMobile</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByOrderId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>无索引</th><th>有索引-区分度不高</th><th>有索引区分度高</th><th>高在前</th><th>低在前</th></tr></thead><tbody><tr><td>耗时</td><td>6小时+</td><td>8.343 seconds</td><td>2.051 seconds</td><td>2.168 seconds</td><td>3.279 seconds</td></tr><tr><td>50%</td><td>7s</td><td>13ms</td><td>7ms</td><td>7ms</td><td>11ms</td></tr><tr><td>80%</td><td>9s</td><td>20ms</td><td>10ms</td><td>11ms</td><td>17ms</td></tr><tr><td>90%</td><td>15s</td><td>26ms</td><td>13ms</td><td>13ms</td><td>22ms</td></tr></tbody></table><p>无索引，还是查询字段的。非常危险。<br>不要在一些区分度不高的字段建索引。当然本案例中，userId 最多也就1000来个用户所产生的1百万数据，这样的情况更适合分库分表。<br>区分度很高的字段，查询效率会非常好。<br>把高区分度的索引字段放在前面，更有利于查询。—— 注意不要测试完上一个，直接测试下一个。有缓存的情况下，会影响对比结果。<br>这就是整个数据库表的压测过程了。如果你有使用的诉求，需要做技术调研，那么一定要做一些这样的压测处理。这样有真实数据才好讲道理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将通过简单干净的实践方式，向读者展示在使用不同连接池以及不使用连接池的情况下，SpringBoot应用程序对接MySQL进行增删改查的性能对比。同时，还将探讨更新和查询时索引字段的关键性。&lt;/p&gt;
&lt;p&gt;在开始之前，让我们先来思考一个问题：一张拥有21个字段的表，存放着100万条数据，会占用多少空间容量？如果这100万条数据在不使用连接池的方式下，以10个并发每条一条插入，需要多长时间？&lt;/p&gt;
&lt;p&gt;根据经验，问题1大约需要350MB左右的空间容量，而问题2可能需要2到3小时的时间。尽管这些数字可能因机器配置而异，但重要的是你可以亲自验证它们。本文将使用ApacheBench对MySQL连接池进行压测，帮助读者更好地了解相关知识。&lt;/p&gt;
&lt;p&gt;通过这个实践，我们可以得出结论：在使用连接池的情况下，SpringBoot应用程序对接MySQL的性能明显优于不使用连接池的情况。无论是插入、删除、更新还是查询操作，连接池都能够显著减少等待时间和资源消耗。&lt;/p&gt;
&lt;p&gt;此外，索引字段在更新和查询时起着关键的作用。合适的索引可以提高查询效率并减少扫描的数据量。因此，在设计数据库结构时，我们应该仔细考虑如何合理地使用索引。&lt;/p&gt;
&lt;p&gt;希望本文能够帮助读者更好地理解SpringBoot应用程序对接MySQL时连接池的重要性以及性能优化的方法。通过实践和实验，我们可以更加深入地了解并应用这些知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL、SpringBoot" scheme="https://longchao012.github.io/tags/MySQL%E3%80%81SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>基于UiBot开发的RPA项目各类银行操作流程(银行流水下载、自动填写付款单等)</title>
    <link href="https://longchao012.github.io/2022/08/16/%E5%9F%BA%E4%BA%8EUiBot%E5%BC%80%E5%8F%91%E7%9A%84RPA%E9%A1%B9%E7%9B%AE%E9%93%B6%E8%A1%8C%E6%B5%81%E6%B0%B4%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
    <id>https://longchao012.github.io/2022/08/16/%E5%9F%BA%E4%BA%8EUiBot%E5%BC%80%E5%8F%91%E7%9A%84RPA%E9%A1%B9%E7%9B%AE%E9%93%B6%E8%A1%8C%E6%B5%81%E6%B0%B4%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B/</id>
    <published>2022-08-16T02:10:22.000Z</published>
    <updated>2023-08-18T01:52:10.622Z</updated>
    
    <content type="html"><![CDATA[<p>基于UiBot开发的RPA项目银行流水下载流程<br>做过很多关于银行相关的RPA项目，本次主要以UIBot这个工具来实施的银行相关RPA项目。使用的UiBot Creator 5.6的版本，后续更新为6.0版本。涉及的银行有中国银行，工商银行，民生银行，光大银行，农业银行等多少银行。有通过C&#x2F;S访问的，也有通过B&#x2F;S访问的。客户方面都没有做太多的限制，能满足业务需要即可。开发的周期，看业务需求的范围与数据结构的复杂度。如果有对账，数据转换等需求的项目可能时间会相对长一点，如果只是单纯的下载流水或填写付款单等待，那基本会很快，时间可以控制在一到两周以内。<br>目前为止。接受到的需求主要有以下几种：<br>1.流水查询(一般会跟着有有自动对账需求)<br>2.付款单填写<br>总体来说，就是资金的借与贷的变化。除此无它！</p><p>那么我们开发的过程中可能会遇到什么问题呢？</p><span id="more"></span>)<h2 id="开发过程中可能会遇到的问题"><a href="#开发过程中可能会遇到的问题" class="headerlink" title="开发过程中可能会遇到的问题"></a>开发过程中可能会遇到的问题</h2><h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>做银行相关的项目，其中最重要的也是客户最关心的就是安全性问题，就以目前的项目来说，安全性其它不太用顾虑。因为如果是查流水，没有太多的资金的上担忧，只是简单的查。而且数据也不是那么容易泄漏的，主要是有三个方面的防护<br>1.物理性的防护，通过保护电脑与主机还有Ukey(主要)，在使用的时候才插入Ukey即可。<br>2.登录密码的防护，可以把密码写入到Window的凭证中，通过UiBot内置的组件来读取，开发人员也不知道这个密码是什么。<br>3.严密的保存交易密码。RPA流程不会涉及到交易密码，也不建议把交易密码暴露出来让RPA机器人使用。</p><h3 id="需求中的问题"><a href="#需求中的问题" class="headerlink" title="需求中的问题"></a>需求中的问题</h3><p>主要是个别客户的对账的过程复杂，需要考虑的因素特别多，对账时候的数据非标准数据，需要很多的数据转换。这其中的过程遇到很多的困难。<br>同时，有时候客户自身对需求的细节也会判定不足，导致开发过程中进行不下去，项目周末延长。</p><h3 id="银行系统的限制问题"><a href="#银行系统的限制问题" class="headerlink" title="银行系统的限制问题"></a>银行系统的限制问题</h3><p>银行系统会监测你的行为还有不允许有远程之类的操作。不能让远程控制输入密码。可以调用驱动级的键盘输入解决问题。部分银行的系统的C&#x2F;S端元素的布局是比较混乱的，元素明明在A点，坐标却是偏到了天边的B点，而很多的控件或元素都是无法获取到对应的元素坐标。不知道是出于安全还是其它方面的考虑。这个没有太好的解决办法，只能一点点的适配与调节。而相比B&#x2F;S端这种情况就会好很多，但是很多客户的电脑配置都不太好，而且银行对浏览器的支持也是强差人意。只能根据每个客户做相对应的调整与配置。</p><h3 id="现场运行环境问题"><a href="#现场运行环境问题" class="headerlink" title="现场运行环境问题"></a>现场运行环境问题</h3><p>环境问题大部分是性能问题，有的客户的电脑是很破旧的电脑，有的客户的电脑还运行着Windows7或Windows XP。实在是太难啦。这个没什么解决的办法，只能尽量的沟通协调，不行就让RPA流程慢下来，通过不断的试错慢慢的适配比较差的电脑环境。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于UiBot开发的RPA项目银行流水下载流程&lt;br&gt;做过很多关于银行相关的RPA项目，本次主要以UIBot这个工具来实施的银行相关RPA项目。使用的UiBot Creator 5.6的版本，后续更新为6.0版本。涉及的银行有中国银行，工商银行，民生银行，光大银行，农业银行等多少银行。有通过C&amp;#x2F;S访问的，也有通过B&amp;#x2F;S访问的。客户方面都没有做太多的限制，能满足业务需要即可。开发的周期，看业务需求的范围与数据结构的复杂度。如果有对账，数据转换等需求的项目可能时间会相对长一点，如果只是单纯的下载流水或填写付款单等待，那基本会很快，时间可以控制在一到两周以内。&lt;br&gt;目前为止。接受到的需求主要有以下几种：&lt;br&gt;1.流水查询(一般会跟着有有自动对账需求)&lt;br&gt;2.付款单填写&lt;br&gt;总体来说，就是资金的借与贷的变化。除此无它！&lt;/p&gt;
&lt;p&gt;那么我们开发的过程中可能会遇到什么问题呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA、银行、办公自动化" scheme="https://longchao012.github.io/tags/RPA%E3%80%81%E9%93%B6%E8%A1%8C%E3%80%81%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>我们应该从哪些方面思考公司场景是否适合RPA流程自动化</title>
    <link href="https://longchao012.github.io/2022/07/16/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%80%9D%E8%80%83%E5%85%AC%E5%8F%B8%E5%9C%BA%E6%99%AF%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88RPA%E6%B5%81%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>https://longchao012.github.io/2022/07/16/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%80%9D%E8%80%83%E5%85%AC%E5%8F%B8%E5%9C%BA%E6%99%AF%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88RPA%E6%B5%81%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96/</id>
    <published>2022-07-16T07:23:41.000Z</published>
    <updated>2023-08-18T01:51:44.655Z</updated>
    
    <content type="html"><![CDATA[<p>随着科技的发展，RPA（Robotic Process Automation）流程自动化已经成为企业提升效率，降低成本的重要工具。我们需要理解RPA的基本概念和特性。RPA是一种可以模拟和复制人类在应用程序中执行的重复任务的技术，它可以24&#x2F;7不间断工作，不需要休息，也不需要假期。这种特性使得RPA非常适合处理大量的、重复的、规则化的任务。<br>那么那些场景或需求合适使用自动化呢？</p><span id="more"></span>)<h2 id="流程适合性"><a href="#流程适合性" class="headerlink" title="流程适合性"></a>流程适合性</h2><p>您可以使用以下标准评估流程是否适合自动化：</p><h3 id="基于规则"><a href="#基于规则" class="headerlink" title="基于规则"></a>基于规则</h3><p>可通过预定义逻辑捕获在流程中做出的决策（包括数据解释）。这样带来的结果是，异常率要么很低，要么包含在业务逻辑中。</p><h3 id="可自动化和-或重复性流程"><a href="#可自动化和-或重复性流程" class="headerlink" title="可自动化和&#x2F;或重复性流程"></a>可自动化和&#x2F;或重复性流程</h3><p>我们可以区分4种类型的流程：<br>手动非重复性流程：由人工执行且每次执行该流程时都有不同的流程步骤<br>手动重复性流程：由用户执行，并且每次至少有部分相同的流程步骤<br>半自动化重复性流程：其中一些重复的步骤已经实现自动化（使用宏、Outlook 规则等）<br>自动化流程：已使用除 RPA 之外的其他技术实现自动化的流程<br>由于异常率高或无法集成到业务逻辑中的因素，仍然需要手动执行或非重复性的流程并非自动化的理想选择。</p><h3 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h3><p>流程中的输入应采用电子形式且易于读取，或者可以使用与 RPA 相关的技术（例如 OCR）进行读取。预定义字段的发票就是很好的例子。</p><h3 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h3><p>在一定时期内相同且在接下来的几个月内预计不会发生任何变化的流程适合自动化，前提是它们也符合另一个标准。</p><h2 id="自动化的复杂性"><a href="#自动化的复杂性" class="headerlink" title="自动化的复杂性"></a>自动化的复杂性</h2><p>这套标准用于确定实现流程自动化的难度：</p><h3 id="界面数量"><a href="#界面数量" class="headerlink" title="界面数量"></a>界面数量</h3><p>RPA的工作原理是，通过对机器人进行编程，使其可以在界面级别执行任务（当界面更改时，机器人必须学习逻辑）。界面数量越多，在实现流程自动化之前必须捕获和配置的元素就越多。</p><h3 id="应用程序的类型"><a href="#应用程序的类型" class="headerlink" title="应用程序的类型"></a>应用程序的类型</h3><p>有些应用程序较易实现自动化（例如 Office套件或浏览器），而有些则需要大量工作才能实现自动化（例如大型机）。随着应用程序的差异越大，界面数量也会随之增加（参见上一点）。</p><h3 id="业务逻辑场景"><a href="#业务逻辑场景" class="headerlink" title="业务逻辑场景"></a>业务逻辑场景</h3><p>自动化的复杂性随着业务逻辑中决策点的数量而增加。基本上，每个决策点乘二即可得出场景数量。</p><h3 id="输入的类型和数量"><a href="#输入的类型和数量" class="headerlink" title="输入的类型和数量"></a>输入的类型和数量</h3><p>如前所述，需要使用标准输入。但在某些情况下，必须为将受到自动化影响的所有供应商配置一个标准输入（例如发票）。此外，非标准输入可以分为不同的复杂性等级，其中自由文本是最复杂的。</p><h2 id="评估自动化潜力"><a href="#评估自动化潜力" class="headerlink" title="评估自动化潜力"></a>评估自动化潜力</h2><h3 id="不使用RPA"><a href="#不使用RPA" class="headerlink" title="不使用RPA"></a>不使用RPA</h3><p>频繁变化、系统环境多变且需要执行多个手动（甚至非数字）操作的流程。</p><h3 id="半自动化"><a href="#半自动化" class="headerlink" title="半自动化"></a>半自动化</h3><p>可以分解为可明确自动化的步骤和仍需手动执行的步骤（例如验证或使用物理安全性令牌）的流程。</p><h3 id="高成本RPA"><a href="#高成本RPA" class="headerlink" title="高成本RPA"></a>高成本RPA</h3><p>数字化程度较高并且可以实现自动化的流程，但需要使用一些复杂的技术（例如 OCR）或需要具备高级编程技能。</p><h3 id="零接触自动化"><a href="#零接触自动化" class="headerlink" title="零接触自动化"></a>零接触自动化</h3><p>涉及高度静态的系统和流程环境的数字化流程，这些流程很容易就能分解为指令并且可以定义简单的触发器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着科技的发展，RPA（Robotic Process Automation）流程自动化已经成为企业提升效率，降低成本的重要工具。我们需要理解RPA的基本概念和特性。RPA是一种可以模拟和复制人类在应用程序中执行的重复任务的技术，它可以24&amp;#x2F;7不间断工作，不需要休息，也不需要假期。这种特性使得RPA非常适合处理大量的、重复的、规则化的任务。&lt;br&gt;那么那些场景或需求合适使用自动化呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA、Python、办公自动化" scheme="https://longchao012.github.io/tags/RPA%E3%80%81Python%E3%80%81%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hello World For LongChao</title>
    <link href="https://longchao012.github.io/2022/07/15/hello-world/"/>
    <id>https://longchao012.github.io/2022/07/15/hello-world/</id>
    <published>2022-07-15T07:23:41.000Z</published>
    <updated>2023-08-17T01:46:10.433Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
