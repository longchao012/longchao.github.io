<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://longchao012.github.io/atom.xml" rel="self"/>
  
  <link href="https://longchao012.github.io/"/>
  <updated>2023-08-24T03:54:36.897Z</updated>
  <id>https://longchao012.github.io/</id>
  
  <author>
    <name>龙超小站</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小案例：制作《数据流图》与《业务流程图》</title>
    <link href="https://longchao012.github.io/2022/08/24/%E5%B0%8F%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%B6%E4%BD%9C%E3%80%8A%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E3%80%8B%E4%B8%8E%E3%80%8A%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%8B/"/>
    <id>https://longchao012.github.io/2022/08/24/%E5%B0%8F%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%B6%E4%BD%9C%E3%80%8A%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E3%80%8B%E4%B8%8E%E3%80%8A%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%8B/</id>
    <published>2022-08-24T03:53:12.000Z</published>
    <updated>2023-08-24T03:54:36.897Z</updated>
    
    <content type="html"><![CDATA[<p>数据流图（Data Flow Diagram, DFD）是一种便于用户理解和分析系统数据流程的图形工具，他摆脱了系统和具体内容，精确的在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。</p><span id="more"></span><h2 id="一、数据流图组成部分"><a href="#一、数据流图组成部分" class="headerlink" title="一、数据流图组成部分"></a>一、数据流图组成部分</h2><p><strong>数据流：</strong>是由一组固定成分的数据组成，表示数据的流向，除了流向数据存储或从数据存储流出的数据不必命名外，每个数据流必须要有一个合适的名字，以反映该数据流的含义</p><p><strong>加工：</strong>加工描述了输入数据流到输出数据之间的变换，也就是输入数据流经过什么处理后变成了输出数据</p><p><strong>数据存储：</strong>数据存储表示暂时存储的数据,每个数据存储都有一个名字</p><p><strong>外部实体：</strong>外部实体是存在于软件系统之外的人员或组织</p><h2 id="二、基本图形符号（重点）"><a href="#二、基本图形符号（重点）" class="headerlink" title="二、基本图形符号（重点）"></a>二、基本图形符号（重点）</h2><p>方框：表示数据的源点或终点</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE1.png" alt="数据流图1"><br>圆或椭圆：表示加工</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE2.png" alt="数据流图2"><br>箭头：表示数据流</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE3.png" alt="数据流图3"><br>双杠：表示数据存储</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE4.png" alt="数据流图4"></p><h2 id="三、实战案列"><a href="#三、实战案列" class="headerlink" title="三、实战案列"></a>三、实战案列</h2><p>题目：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE5.png" alt="数据流图5"><br>大家可以看见这个是一个机票预订系统「：黑色的字体都是关键字」，现在让我们试试画出这个数据流图。</p><p><em>航空公司 会根据 航班信息来 安排航班</em></p><p>可以看的出航空公司是一个实体，航班信息是种数据，安排航班是处理这个数据，所以我们得到以下的图。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE6.png" alt="数据流图6"></p><p><em>并将航班信息存储在订票信息中</em></p><p>上面的话可以看见将航班信息存储在订票信息中，得到下图：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE7.png" alt="数据流图7"></p><p><em>旅客订票时，旅客将旅客信息输入该系统</em></p><p>上面的话可以看出有操作了，实体是旅客，操作数据是订票行为，将信息输入该系统（订票）下图：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE8.png" alt="数据流图8"></p><p><em>系统通过旅客信息，在订票信息中查询合适的航班，并返回机票信息</em></p><p>通过上面的看见发现是系统查询并返回系统（注意：订票信息只是把名字放上面去了，没有更改图）</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE9.png" alt="数据流图9"></p><p><em>然后系统根据机票信息，打印机票</em></p><p>上面又有操作，根据机票信息这个数据流来打印机票（操作数据）得下图：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE10.png" alt="数据流图10"></p><p><em>最后将机票信息返回给旅客</em></p><p>这步就是结束了：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE11.png" alt="数据流图11"><br>好了以上就是数据流图的一个小实战，其实画图简单，只要搞清楚了实体的关系联系，基本上都是换汤不换药，轻轻松松~~~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据流图（Data Flow Diagram, DFD）是一种便于用户理解和分析系统数据流程的图形工具，他摆脱了系统和具体内容，精确的在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UML" scheme="https://longchao012.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>基于UiBot的滑动验证码检测实例</title>
    <link href="https://longchao012.github.io/2022/08/23/%E5%9F%BA%E4%BA%8EUiBot%E7%9A%84%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A3%80%E6%B5%8B%E5%AE%9E%E4%BE%8B/"/>
    <id>https://longchao012.github.io/2022/08/23/%E5%9F%BA%E4%BA%8EUiBot%E7%9A%84%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A3%80%E6%B5%8B%E5%AE%9E%E4%BE%8B/</id>
    <published>2022-08-23T09:59:20.000Z</published>
    <updated>2023-08-23T10:14:25.837Z</updated>
    
    <content type="html"><![CDATA[<p>我们在做一些自动化登录的过程中，经常会遇到各种各样的图灵检测。<br><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%811.png" alt="滑块验证1"><br>因为验证码样式多变，而且需要较多命令组合才能完成验证，所以UiBot暂时没有将验证码做为一个命令组件进行预制。难到这样就没办法了吗？</p><span id="more"></span><p>难到这样就没办法了吗？显然不是，我们可以利用RPA连接外部的特性，使用部分coding来解决此问题（使用coding也算一种连接嘛）</p><p>回到上例，一般来说这样的验证码验证有如下流程，我们把他拆分一下可得：</p><p>1、展示完整原图，说明验证方式</p><p>2、鼠标按住滑块，展现出缺陷图</p><p>3、滑动滑块到缺陷部分</p><p>其中，1、2两部我们用眼睛识别，用来测算距离，第3步用鼠标移动用来填补距离，基于这个逻辑，我们同样把整个验证的实现拆分成2个大步，那么第一步是算滑动距离，第二步就是根据滑动距离进行滑动了，下面我们根据实例来一步步进行分解实现。</p><p>实例地址：<a href="https://www.chinapay.com/index.jsp%EF%BC%88%E9%93%B6%E8%81%94%E7%9A%84%E7%99%BB%E5%BD%95%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%9A%8F%E4%BE%BF%E8%BE%93%E5%85%A5%E5%8F%AF%E8%A7%A6%E5%8F%91%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%EF%BC%89">https://www.chinapay.com/index.jsp（银联的登录地址，用户名密码随便输入可触发滑动验证）</a></p><p>要得到完整距离，首先我们要得到无缺口图和有缺口图2张图片，其中有缺口的图片需要将鼠标移到滑块上并按住才会出现，当然这也很好解决，我们可以直接使用UiBot获取这两张图，获取的方式如下：</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%812.png" alt="滑块验证2"></p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;1.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br><span class="line">Mouse.Hover(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;isleaf&quot;:&quot;1&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:3&#125;&#125;,10000,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:0,&quot;iDelayBefore&quot;:0,&quot;bSetForeground&quot;:true,&quot;sCursorPosition&quot;:&quot;Center&quot;,&quot;iCursorOffsetX&quot;:0,&quot;iCursorOffsetY&quot;:0,&quot;sKeyModifiers&quot;:[],&quot;sSimulate&quot;:&quot;simulate&quot;&#125;)</span><br><span class="line">Mouse.Click(&quot;left&quot;, &quot;down&quot;, [])</span><br><span class="line">Delay(600)</span><br><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;2.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%813.png" alt="滑块验证3"></p><p>得到两张图后我们需要测算滑动距离，如何测算呢？我们可以比对上图，发现除了缺口以外其他部分基本和原图一致（有部分干扰块，但是问题不大，因为色深不够而且水平距离不一致，我们可以通过后面的算法把他滤过），所以实际上我们只需要抓住起始点和缺陷部分的特征既可算出两者直接的距离，这里我们可以通过python进行图像处理实现，具体实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image  </span><br><span class="line">import PIL.ImageChops as imagechops</span><br><span class="line">from PIL import Image, ImageDraw,ImageFont</span><br><span class="line">import random</span><br><span class="line">def CalcDistance(srcImg,distImg):</span><br><span class="line">    im1 = Image.open(srcImg)</span><br><span class="line">    im2 = Image.open(distImg)</span><br><span class="line">    #得出两图不一致的地方</span><br><span class="line">    diff=imagechops.difference(im1, im2)</span><br><span class="line">    draw =ImageDraw.Draw(diff)</span><br><span class="line">    #通过颜色处理清除干扰块</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor[0]&gt;=100 or pixelColor[1]&gt;=100 or pixelColor[2]&gt;=100:</span><br><span class="line">                draw.line((x, y, x, y),(255,255,255,255))</span><br><span class="line">            else:</span><br><span class="line">                draw.line((x, y, x, y),(0,0,0,0))</span><br><span class="line">    # #清理完可以show一下，查看清理完之后的黑白化效果</span><br><span class="line">    # diff.show()</span><br><span class="line">    #找第一个块中的参照点</span><br><span class="line">    firsetPoint=[0,0]</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                firsetPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if firsetPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # 往后跳50找第二个块中的参照点，50是矩形宽度</span><br><span class="line">    secondPoint=[0,0]</span><br><span class="line">    for x in range(firsetPoint[0]+50,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                secondPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if secondPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # #画两条线看看位置是否标注正确，仅用于调试</span><br><span class="line">    # draw.line((firsetPoint[0], firsetPoint[1], firsetPoint[0]+20, firsetPoint[1]),(6,255,9,0))</span><br><span class="line">    # draw.line((secondPoint[0], secondPoint[1], secondPoint[0]+20, secondPoint[1]),(9,8,255,0))</span><br><span class="line">    # diff.show()</span><br><span class="line">    diffPixel=secondPoint[0]-firsetPoint[0]</span><br><span class="line">    print(diffPixel)</span><br></pre></td></tr></table></figure><p>经过上述处理后，前文的图会被处理为下图的样子，并算出两块直接的一个距离</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%814.png" alt="滑块验证4"></p><p>得到距离，接下来我们需要驱动鼠标进行滑动，这些在UiBot里面都有相应的命令可以直接使用，在第一次处理这个验证码时，我天真的以为到算出距离就已经结束，没想到实际上滑动验证码的难点恰恰是滑动轨迹的模拟。滑动验证码在滑动轨迹上同样加入了人机测验，就算本例的解决方式也只有60%的成功率(两块相隔距离较长的情况下成功率更高)。话不多说，下面直接放轨迹的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def GetStacks(distance):</span><br><span class="line">    distance += 20</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    匀加速\减速运行</span><br><span class="line">        v = v0 + a * t</span><br><span class="line">    位移:</span><br><span class="line">    s = v * t + 0.5 * a * (t**2)</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 初速度</span><br><span class="line">    v0 = 0</span><br><span class="line">    # 加减速度列表</span><br><span class="line">    a_list = [3, 4, 5]</span><br><span class="line">    # 时间</span><br><span class="line">    t = 0.2</span><br><span class="line">    # 初始位置</span><br><span class="line">    s = 0</span><br><span class="line">    # 向前滑动轨迹</span><br><span class="line">    forward_stacks = []</span><br><span class="line">    mid = distance * 3 / 5</span><br><span class="line">    while s &lt; distance:</span><br><span class="line">        if s &lt; mid:</span><br><span class="line">            a = a_list[random.randint(0, 2)]</span><br><span class="line">        else:</span><br><span class="line">            a = -a_list[random.randint(0, 2)]</span><br><span class="line">        v = v0</span><br><span class="line">        stack = v * t + 0.5 * a * (t ** 2)</span><br><span class="line">        # 每次拿到的位移</span><br><span class="line">        stack = round(stack)</span><br><span class="line">        s += stack</span><br><span class="line">        v0 = v + a * t</span><br><span class="line">        forward_stacks.append(stack)</span><br><span class="line">    back_stacks = [-1, -1, -2, -3, -2, -3, -2, -2, -3, -1]</span><br><span class="line">    return &#123;&#x27;forward_stacks&#x27;: forward_stacks, &#x27;back_stacks&#x27;: back_stacks</span><br></pre></td></tr></table></figure><p>上述轨迹实现，逻辑是模拟人以加速度的形式进行增速滑动，为了骗过人机检测，特意还有个回滑的操作，而后将轨迹以相对位移数组的形式进行返回，结合我们之前距离的测算，可以得到一个完整的python文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image  </span><br><span class="line">import PIL.ImageChops as imagechops</span><br><span class="line">from PIL import Image, ImageDraw,ImageFont</span><br><span class="line">import random</span><br><span class="line">def CalcDistance(srcImg,distImg):</span><br><span class="line">    im1 = Image.open(srcImg)</span><br><span class="line">    im2 = Image.open(distImg)</span><br><span class="line">    #得出两图不一致的地方</span><br><span class="line">    diff=imagechops.difference(im1, im2)</span><br><span class="line">    draw =ImageDraw.Draw(diff)</span><br><span class="line">    #通过颜色处理清除干扰块</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor[0]&gt;=100 or pixelColor[1]&gt;=100 or pixelColor[2]&gt;=100:</span><br><span class="line">                draw.line((x, y, x, y),(255,255,255,255))</span><br><span class="line">            else:</span><br><span class="line">                draw.line((x, y, x, y),(0,0,0,0))</span><br><span class="line">    # #清理完可以show一下，查看清理完之后的黑白化效果</span><br><span class="line">    # diff.show()</span><br><span class="line">    #找第一个块中的参照点</span><br><span class="line">    firsetPoint=[0,0]</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                firsetPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if firsetPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # 往后跳50找第二个块中的参照点，50是矩形宽度</span><br><span class="line">    secondPoint=[0,0]</span><br><span class="line">    for x in range(firsetPoint[0]+50,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                secondPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if secondPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # #画两条线看看位置是否标注正确，仅用于调试</span><br><span class="line">    # draw.line((firsetPoint[0], firsetPoint[1], firsetPoint[0]+20, firsetPoint[1]),(6,255,9,0))</span><br><span class="line">    # draw.line((secondPoint[0], secondPoint[1], secondPoint[0]+20, secondPoint[1]),(9,8,255,0))</span><br><span class="line">    # diff.show()</span><br><span class="line">    diffPixel=secondPoint[0]-firsetPoint[0]</span><br><span class="line">    return GetStacks(diffPixel)</span><br><span class="line">    </span><br><span class="line">def GetStacks(distance):</span><br><span class="line">    distance += 20</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    匀加速\减速运行</span><br><span class="line">        v = v0 + a * t</span><br><span class="line">    位移:</span><br><span class="line">    s = v * t + 0.5 * a * (t**2)</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 初速度</span><br><span class="line">    v0 = 0</span><br><span class="line">    # 加减速度列表</span><br><span class="line">    a_list = [3, 4, 5]</span><br><span class="line">    # 时间</span><br><span class="line">    t = 0.2</span><br><span class="line">    # 初始位置</span><br><span class="line">    s = 0</span><br><span class="line">    # 向前滑动轨迹</span><br><span class="line">    forward_stacks = []</span><br><span class="line">    mid = distance * 3 / 5</span><br><span class="line">    while s &lt; distance:</span><br><span class="line">        if s &lt; mid:</span><br><span class="line">            a = a_list[random.randint(0, 2)]</span><br><span class="line">        else:</span><br><span class="line">            a = -a_list[random.randint(0, 2)]</span><br><span class="line">        v = v0</span><br><span class="line">        stack = v * t + 0.5 * a * (t ** 2)</span><br><span class="line">        # 每次拿到的位移</span><br><span class="line">        stack = round(stack)</span><br><span class="line">        s += stack</span><br><span class="line">        v0 = v + a * t</span><br><span class="line">        forward_stacks.append(stack)</span><br><span class="line">    back_stacks = [-1, -1, -2, -3, -2, -3, -2, -2, -3, -1]</span><br><span class="line">    return &#123;&#x27;forward_stacks&#x27;: forward_stacks, &#x27;back_stacks&#x27;: back_stacks&#125;</span><br></pre></td></tr></table></figure><p>现在剩下的工作是将这个文件给UiBot进行使用。我们将上面的文件保存成CrackGEE.py，放到UiBot Creator的安装目录下的 extend\python下面（可参考：<a href="https://forum.uibot.com.cn/thread-51.htm%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8UiBot%E9%87%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%9A">https://forum.uibot.com.cn/thread-51.htm），然后在UiBot里面添加如下代码：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Import CrackGEE</span><br><span class="line">#icon(&quot;@res:dp3vobi1-353k-q9mp-q5oh-nicth66fv4ag.png&quot;)</span><br><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;1.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br><span class="line">#icon(&quot;@res:sod4iqf0-l79e-a7hu-n4rm-hom2l8pgvv4k.png&quot;)</span><br><span class="line">Mouse.Hover(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;isleaf&quot;:&quot;1&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:3&#125;&#125;,10000,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:0,&quot;iDelayBefore&quot;:0,&quot;bSetForeground&quot;:true,&quot;sCursorPosition&quot;:&quot;Center&quot;,&quot;iCursorOffsetX&quot;:0,&quot;iCursorOffsetY&quot;:0,&quot;sKeyModifiers&quot;:[],&quot;sSimulate&quot;:&quot;simulate&quot;&#125;)</span><br><span class="line">Mouse.Click(&quot;left&quot;, &quot;down&quot;, [])</span><br><span class="line">Delay(600)</span><br><span class="line">#icon(&quot;@res:dp3vobi1-353k-q9mp-q5oh-nicth66fv4ag.png&quot;)</span><br><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;2.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br><span class="line">dim 点列表=[]</span><br><span class="line">点列表=CrackGEE.CalcDistance(&quot;1.png&quot;,&quot;2.png&quot;)</span><br><span class="line">TracePrint(点列表)</span><br><span class="line">Dim 正向移动=点列表[&quot;forward_stacks&quot;]</span><br><span class="line">Dim 回移=点列表[&quot;back_stacks&quot;]</span><br><span class="line">For Each value In 正向移动</span><br><span class="line"> Mouse.Move(value, 0, true)</span><br><span class="line">Delay(12)</span><br><span class="line">Next</span><br><span class="line">For Each value In 回移</span><br><span class="line"> Mouse.Move(value, 0, true)</span><br><span class="line">Delay(34)</span><br><span class="line">Next</span><br><span class="line">Delay(200)</span><br><span class="line">Mouse.Click(&quot;left&quot;, &quot;up&quot;, [])</span><br></pre></td></tr></table></figure><p>视图:</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%815.png" alt="滑块验证5"></p><p>在使用chrome打开银联网站,随便输入用户名密码，呼出验证，停留在如下图所示地方：</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%816.png" alt="滑块验证6"></p><p>点击UiBot Creator的运行，即可看到效果。<br><video src="/images/滑块验证7.mp4" controls="controls">您的浏览器不支持播放该视频！</video></p><p>本例权当抛砖引玉，实际上在短距离的比对计算还有滑动轨迹上面还有不小的提升空间，有兴趣的大神可以进一步进行扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在做一些自动化登录的过程中，经常会遇到各种各样的图灵检测。&lt;br&gt;&lt;img src=&quot;/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%811.png&quot; alt=&quot;滑块验证1&quot;&gt;&lt;br&gt;因为验证码样式多变，而且需要较多命令组合才能完成验证，所以UiBot暂时没有将验证码做为一个命令组件进行预制。难到这样就没办法了吗？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA" scheme="https://longchao012.github.io/tags/RPA/"/>
    
  </entry>
  
  <entry>
    <title>基于Java的单表100万数据，写入、更新、读取、删除速度的测试验证！</title>
    <link href="https://longchao012.github.io/2022/08/21/%E5%8D%95%E8%A1%A8100%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%86%99%E5%85%A5%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E8%AF%BB%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E9%80%9F%E5%BA%A6%E7%9A%84%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%EF%BC%81/"/>
    <id>https://longchao012.github.io/2022/08/21/%E5%8D%95%E8%A1%A8100%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%86%99%E5%85%A5%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E8%AF%BB%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E9%80%9F%E5%BA%A6%E7%9A%84%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%EF%BC%81/</id>
    <published>2022-08-21T06:39:15.000Z</published>
    <updated>2023-08-21T09:47:17.461Z</updated>
    
    <content type="html"><![CDATA[<p>本文将通过简单干净的实践方式，向读者展示在使用不同连接池以及不使用连接池的情况下，SpringBoot应用程序对接MySQL进行增删改查的性能对比。同时，还将探讨更新和查询时索引字段的关键性。</p><p>在开始之前，让我们先来思考一个问题：一张拥有21个字段的表，存放着100万条数据，会占用多少空间容量？如果这100万条数据在不使用连接池的方式下，以10个并发每条一条插入，需要多长时间？</p><p>根据经验，问题1大约需要350MB左右的空间容量，而问题2可能需要2到3小时的时间。尽管这些数字可能因机器配置而异，但重要的是你可以亲自验证它们。本文将使用ApacheBench对MySQL连接池进行压测，帮助读者更好地了解相关知识。</p><p>通过这个实践，我们可以得出结论：在使用连接池的情况下，SpringBoot应用程序对接MySQL的性能明显优于不使用连接池的情况。无论是插入、删除、更新还是查询操作，连接池都能够显著减少等待时间和资源消耗。</p><p>此外，索引字段在更新和查询时起着关键的作用。合适的索引可以提高查询效率并减少扫描的数据量。因此，在设计数据库结构时，我们应该仔细考虑如何合理地使用索引。</p><p>希望本文能够帮助读者更好地理解SpringBoot应用程序对接MySQL时连接池的重要性以及性能优化的方法。通过实践和实验，我们可以更加深入地了解并应用这些知识。</p><span id="more"></span><p>本文涉及的工程：</p><p>xfg-dev-tech-connection-pool：<a href="https://gitcode.net/KnowledgePlanet/road-map/xfg-dev-tech-connection-pool">https://gitcode.net/KnowledgePlanet/road-map/xfg-dev-tech-connection-pool</a> - 工程内含有环境的安装脚本；mysql-docker-compose.yml、apachebench-docker-compose.yml、road_map_8.0.sql</p><h2 id="一、案例背景"><a href="#一、案例背景" class="headerlink" title="一、案例背景"></a>一、案例背景</h2><p><strong>拿100万订单数据，压到数据库中！</strong></p><p>初始化一个空的数据库表，并向数据库表中写入100万数据。之后在分别不使用连接池和使用不同的连接池(c3p0、dbcp、druid、hikari)写入数据，测试各个连接池的性能。这也能让大家知道，日常我们应该选择哪个连接池。</p><h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><p>因为本章节很偏实操，所以需要大家做下提前安装好 Docker 环境，以便于执行本章节工程中的脚本和代码。可参考别的教程里面 Docker、Portainer 学习安装和使用。<br><img src="/images/MySQL_docker.png" alt="docker安装"><br>1.在 IntelliJ IDEA 打开 xfg-dev-tech-connection-pool 分别点开 mysql-docker-compose、apachebench-docker-compose，之后点击安装即可。<br>2.执行完脚本，你可以得到一份安装好的 MySQL 8.0 并安装了数据库表。另外一份是用于压测使用的 ApacheBench<br>3.连接 MySQL 的工具，推荐使用开源免费的 Sequel Ace</p><h2 id="三、工程说明"><a href="#三、工程说明" class="headerlink" title="三、工程说明"></a>三、工程说明</h2><p>在 xfg-dev-tech-connection-pool 工程中提供了不同连接池的配置和一些非常常用的 SQL 操作，以及提供了对应的接口进行压测使用；</p><table><thead><tr><th>序号</th><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a></td><td>用于缓存数据的接口，拿缓存好的数据压测更新、查询</td></tr><tr><td>2</td><td><a href="http://127.0.0.1:8091/api/mysql/insert">http://127.0.0.1:8091/api/mysql/insert</a></td><td>插入数据接口</td></tr><tr><td>3</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId">http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId</a></td><td>使用索引字段 userId 更新订单状态</td></tr><tr><td>4</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile">http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile</a></td><td>使用无索引字段 userMobile 更新订单状态</td></tr><tr><td>5</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId">http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId</a></td><td>使用索引字段 orderId 更新订单状态</td></tr><tr><td>6</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserId">http://127.0.0.1:8091/api/mysql/selectByUserId</a></td><td>使用索引字段 userId 查询订单</td></tr><tr><td>7</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserMobile">http://127.0.0.1:8091/api/mysql/selectByUserMobile</a></td><td>使用无索引字段 userMobile 查询订单，测试中添加索引</td></tr><tr><td>8</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByOrderId">http://127.0.0.1:8091/api/mysql/selectByOrderId</a></td><td>使用有索引字段 orderId 查询订单</td></tr><tr><td>9</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId">http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId</a></td><td>区分度高的索引字段在前，区分度低的索引字段在后</td></tr><tr><td>10</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId">http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId</a></td><td>区分度低的索引字段在前，区分度高的索引字段在后</td></tr></tbody></table><p>具体代码实现可以直接对照工程来看，以及按需添加SQL语句进行性能压测验证。</p><h2 id="四、库表语句"><a href="#四、库表语句" class="headerlink" title="四、库表语句"></a>四、库表语句</h2><p>SQL：xfg-dev-tech-connection-pool&#x2F;docs&#x2F;sql&#x2F;road_map_8.0.sql<br><img src="/images/MySQL_User_order.png" alt="User表结构"><br>这是本节所需要测试的一个订单表和测试前所建的索引字段。以及初始化了100万数据，占用350M空间。<br>接下来，我们就可以做测试验证了。</p><h2 id="五、压测指令"><a href="#五、压测指令" class="headerlink" title="五、压测指令"></a>五、压测指令</h2><p>ApacheBench 官网教程：<a href="https://httpd.apache.org/docs/2.4/programs/ab.html">https://httpd.apache.org/docs/2.4/programs/ab.html</a><br><img src="/images/ApacheBench%E5%AE%98%E7%BD%91%E6%95%99%E7%A8%8B.png" alt="ApacheBench官网教程"><br>常用的如：<br><code>ab -c 20 -n 1000</code><br><a href="http://127.0.0.1:8091/hi">http://127.0.0.1:8091/hi</a> - 20个并发1000次</p><h2 id="六、压测验证"><a href="#六、压测验证" class="headerlink" title="六、压测验证"></a>六、压测验证</h2><p>首先在测试前，正式测试前，你大概需要花费几十分钟来初始化100万数据。<br>执行脚本；<br><code>ab -c 20 -n 1000000</code><br><a href="http://127.0.0.1:8091/api/mysql/insert">http://127.0.0.1:8091/api/mysql/insert</a> - 如果你在工程中配置了 no-pool 大概要花费几个小时才能跑完，这就使用和不使用连接池的差距。</p><ol><li>连接池比对<br>条件；</li></ol><p>插入1万条数据<br>连接池配置 initialPoolSize&#x3D;5、minPoolSize&#x3D;5、maxPoolSize&#x3D;20<br>此时数据库已经有100万数据，分别用几个链接方式插入数据。hikari 放到最后，它是 SpringBoot 的默认连接池。<br>脚本；<br><code>ab -c 20 -n 10000 http://127.0.0.1:8091/api/mysql/insert</code></p><table><thead><tr><th></th><th>no-pool</th><th>c3p0</th><th>dbcp</th><th>druid</th><th>hikari</th></tr></thead><tbody><tr><td>耗时</td><td>88.990 seconds</td><td>24.228 seconds</td><td>33.656 seconds</td><td>25.971 seconds</td><td>25.002 seconds</td></tr><tr><td>50%</td><td>155ms</td><td>39ms</td><td>60ms</td><td>45ms</td><td>43ms</td></tr><tr><td>80%</td><td>223ms</td><td>61ms</td><td>86ms</td><td>64ms</td><td>64ms</td></tr><tr><td>90%</td><td>291ms</td><td>75ms</td><td>103ms</td><td>75ms</td><td>76ms</td></tr></tbody></table><p>通过对比可以发现，如果不使用连接池，会比使用连接池，要占用更多的时间连接数据库使用数据库。<br>c3p0、hikari 的性能还是非常不错的，dbcp 相对是弱一些的。所以这可以给你在使用连接池时有一个参考。也可以结合你的机器再次进行压测验证。<br>2. 更新对比<br>条件；</p><p>使用接口，向内存加入600条数据。每个测试方式，分别消耗200条。ab -c 10 -n 600 <a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a><br>之后使用无索引字段、有索引但区分度不高的字段以及使用有索引区分度非常好的字段来更新。<br>脚本；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile</span><br><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId</span><br><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>无索引</th><th>有索引-区分度不高</th><th>有索引-区分度很高</th></tr></thead><tbody><tr><td>耗时</td><td>24小时+</td><td>24小时+</td><td>0.432 seconds</td></tr><tr><td>50%</td><td>24小时+</td><td>24小时+</td><td>35ms</td></tr><tr><td>80%</td><td>24小时+</td><td>24小时+</td><td>48ms</td></tr><tr><td></td><td>90%</td><td>24小时+</td><td>24小时+</td></tr></tbody></table><p>无索引的时候；会把整个表的这个记录，全部锁上。那么越执行越慢，最后拖垮数据库。甚至可能1天都执行不完。<br>有索引-区分度不高；几乎是一样的，如果你批量的对一个用户的所有数据都更新，也会锁很多记录。<br>有索引-区分度很高；只要你锁的是自己的一条记录，就与别人没有影响。效率也会非常高。<br>3. 查询对比<br>条件；</p><p>查询100万加的数据库表记录，每次缓存记录5000条数据id；ab -c 10 -n 5000 <a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a><br>userId 有索引、orderId 有索引、userMobie 无索引。<br>每次查询的时候，都要关闭服务重启，避免有缓存干扰结果。<br>脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserMobile</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByOrderId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>无索引</th><th>有索引-区分度不高</th><th>有索引区分度高</th><th>高在前</th><th>低在前</th></tr></thead><tbody><tr><td>耗时</td><td>6小时+</td><td>8.343 seconds</td><td>2.051 seconds</td><td>2.168 seconds</td><td>3.279 seconds</td></tr><tr><td>50%</td><td>7s</td><td>13ms</td><td>7ms</td><td>7ms</td><td>11ms</td></tr><tr><td>80%</td><td>9s</td><td>20ms</td><td>10ms</td><td>11ms</td><td>17ms</td></tr><tr><td>90%</td><td>15s</td><td>26ms</td><td>13ms</td><td>13ms</td><td>22ms</td></tr></tbody></table><p>无索引，还是查询字段的。非常危险。<br>不要在一些区分度不高的字段建索引。当然本案例中，userId 最多也就1000来个用户所产生的1百万数据，这样的情况更适合分库分表。<br>区分度很高的字段，查询效率会非常好。<br>把高区分度的索引字段放在前面，更有利于查询。—— 注意不要测试完上一个，直接测试下一个。有缓存的情况下，会影响对比结果。<br>这就是整个数据库表的压测过程了。如果你有使用的诉求，需要做技术调研，那么一定要做一些这样的压测处理。这样有真实数据才好讲道理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将通过简单干净的实践方式，向读者展示在使用不同连接池以及不使用连接池的情况下，SpringBoot应用程序对接MySQL进行增删改查的性能对比。同时，还将探讨更新和查询时索引字段的关键性。&lt;/p&gt;
&lt;p&gt;在开始之前，让我们先来思考一个问题：一张拥有21个字段的表，存放着100万条数据，会占用多少空间容量？如果这100万条数据在不使用连接池的方式下，以10个并发每条一条插入，需要多长时间？&lt;/p&gt;
&lt;p&gt;根据经验，问题1大约需要350MB左右的空间容量，而问题2可能需要2到3小时的时间。尽管这些数字可能因机器配置而异，但重要的是你可以亲自验证它们。本文将使用ApacheBench对MySQL连接池进行压测，帮助读者更好地了解相关知识。&lt;/p&gt;
&lt;p&gt;通过这个实践，我们可以得出结论：在使用连接池的情况下，SpringBoot应用程序对接MySQL的性能明显优于不使用连接池的情况。无论是插入、删除、更新还是查询操作，连接池都能够显著减少等待时间和资源消耗。&lt;/p&gt;
&lt;p&gt;此外，索引字段在更新和查询时起着关键的作用。合适的索引可以提高查询效率并减少扫描的数据量。因此，在设计数据库结构时，我们应该仔细考虑如何合理地使用索引。&lt;/p&gt;
&lt;p&gt;希望本文能够帮助读者更好地理解SpringBoot应用程序对接MySQL时连接池的重要性以及性能优化的方法。通过实践和实验，我们可以更加深入地了解并应用这些知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL、SpringBoot" scheme="https://longchao012.github.io/tags/MySQL%E3%80%81SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>基于UiBot开发的RPA项目各类银行操作流程(银行流水下载、自动填写付款单等)</title>
    <link href="https://longchao012.github.io/2022/08/16/%E5%9F%BA%E4%BA%8EUiBot%E5%BC%80%E5%8F%91%E7%9A%84RPA%E9%A1%B9%E7%9B%AE%E9%93%B6%E8%A1%8C%E6%B5%81%E6%B0%B4%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
    <id>https://longchao012.github.io/2022/08/16/%E5%9F%BA%E4%BA%8EUiBot%E5%BC%80%E5%8F%91%E7%9A%84RPA%E9%A1%B9%E7%9B%AE%E9%93%B6%E8%A1%8C%E6%B5%81%E6%B0%B4%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B/</id>
    <published>2022-08-16T02:10:22.000Z</published>
    <updated>2023-08-23T10:14:57.368Z</updated>
    
    <content type="html"><![CDATA[<p>基于UiBot开发的RPA项目银行流水下载流程<br>做过很多关于银行相关的RPA项目，本次主要以UIBot这个工具来实施的银行相关RPA项目。使用的UiBot Creator 5.6的版本，后续更新为6.0版本。涉及的银行有中国银行，工商银行，民生银行，光大银行，农业银行等多少银行。有通过C&#x2F;S访问的，也有通过B&#x2F;S访问的。客户方面都没有做太多的限制，能满足业务需要即可。开发的周期，看业务需求的范围与数据结构的复杂度。如果有对账，数据转换等需求的项目可能时间会相对长一点，如果只是单纯的下载流水或填写付款单等待，那基本会很快，时间可以控制在一到两周以内。<br>目前为止。接受到的需求主要有以下几种：<br>1.流水查询(一般会跟着有有自动对账需求)<br>2.付款单填写<br>总体来说，就是资金的借与贷的变化。除此无它！</p><p>那么我们开发的过程中可能会遇到什么问题呢？</p><span id="more"></span><h2 id="开发过程中可能会遇到的问题"><a href="#开发过程中可能会遇到的问题" class="headerlink" title="开发过程中可能会遇到的问题"></a>开发过程中可能会遇到的问题</h2><h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>做银行相关的项目，其中最重要的也是客户最关心的就是安全性问题，就以目前的项目来说，安全性其它不太用顾虑。因为如果是查流水，没有太多的资金的上担忧，只是简单的查。而且数据也不是那么容易泄漏的，主要是有三个方面的防护<br>1.物理性的防护，通过保护电脑与主机还有Ukey(主要)，在使用的时候才插入Ukey即可。<br>2.登录密码的防护，可以把密码写入到Window的凭证中，通过UiBot内置的组件来读取，开发人员也不知道这个密码是什么。<br>3.严密的保存交易密码。RPA流程不会涉及到交易密码，也不建议把交易密码暴露出来让RPA机器人使用。</p><h3 id="需求中的问题"><a href="#需求中的问题" class="headerlink" title="需求中的问题"></a>需求中的问题</h3><p>主要是个别客户的对账的过程复杂，需要考虑的因素特别多，对账时候的数据非标准数据，需要很多的数据转换。这其中的过程遇到很多的困难。<br>同时，有时候客户自身对需求的细节也会判定不足，导致开发过程中进行不下去，项目周末延长。</p><h3 id="银行系统的限制问题"><a href="#银行系统的限制问题" class="headerlink" title="银行系统的限制问题"></a>银行系统的限制问题</h3><p>银行系统会监测你的行为还有不允许有远程之类的操作。不能让远程控制输入密码。可以调用驱动级的键盘输入解决问题。部分银行的系统的C&#x2F;S端元素的布局是比较混乱的，元素明明在A点，坐标却是偏到了天边的B点，而很多的控件或元素都是无法获取到对应的元素坐标。不知道是出于安全还是其它方面的考虑。这个没有太好的解决办法，只能一点点的适配与调节。而相比B&#x2F;S端这种情况就会好很多，但是很多客户的电脑配置都不太好，而且银行对浏览器的支持也是强差人意。只能根据每个客户做相对应的调整与配置。</p><h3 id="现场运行环境问题"><a href="#现场运行环境问题" class="headerlink" title="现场运行环境问题"></a>现场运行环境问题</h3><p>环境问题大部分是性能问题，有的客户的电脑是很破旧的电脑，有的客户的电脑还运行着Windows7或Windows XP。实在是太难啦。这个没什么解决的办法，只能尽量的沟通协调，不行就让RPA流程慢下来，通过不断的试错慢慢的适配比较差的电脑环境。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于UiBot开发的RPA项目银行流水下载流程&lt;br&gt;做过很多关于银行相关的RPA项目，本次主要以UIBot这个工具来实施的银行相关RPA项目。使用的UiBot Creator 5.6的版本，后续更新为6.0版本。涉及的银行有中国银行，工商银行，民生银行，光大银行，农业银行等多少银行。有通过C&amp;#x2F;S访问的，也有通过B&amp;#x2F;S访问的。客户方面都没有做太多的限制，能满足业务需要即可。开发的周期，看业务需求的范围与数据结构的复杂度。如果有对账，数据转换等需求的项目可能时间会相对长一点，如果只是单纯的下载流水或填写付款单等待，那基本会很快，时间可以控制在一到两周以内。&lt;br&gt;目前为止。接受到的需求主要有以下几种：&lt;br&gt;1.流水查询(一般会跟着有有自动对账需求)&lt;br&gt;2.付款单填写&lt;br&gt;总体来说，就是资金的借与贷的变化。除此无它！&lt;/p&gt;
&lt;p&gt;那么我们开发的过程中可能会遇到什么问题呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA、银行、办公自动化" scheme="https://longchao012.github.io/tags/RPA%E3%80%81%E9%93%B6%E8%A1%8C%E3%80%81%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>我们应该从哪些方面思考公司场景是否适合RPA流程自动化</title>
    <link href="https://longchao012.github.io/2022/07/16/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%80%9D%E8%80%83%E5%85%AC%E5%8F%B8%E5%9C%BA%E6%99%AF%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88RPA%E6%B5%81%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>https://longchao012.github.io/2022/07/16/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%80%9D%E8%80%83%E5%85%AC%E5%8F%B8%E5%9C%BA%E6%99%AF%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88RPA%E6%B5%81%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96/</id>
    <published>2022-07-16T07:23:41.000Z</published>
    <updated>2023-08-23T10:15:08.044Z</updated>
    
    <content type="html"><![CDATA[<p>随着科技的发展，RPA（Robotic Process Automation）流程自动化已经成为企业提升效率，降低成本的重要工具。我们需要理解RPA的基本概念和特性。RPA是一种可以模拟和复制人类在应用程序中执行的重复任务的技术，它可以24&#x2F;7不间断工作，不需要休息，也不需要假期。这种特性使得RPA非常适合处理大量的、重复的、规则化的任务。<br>那么那些场景或需求合适使用自动化呢？</p><span id="more"></span><h2 id="流程适合性"><a href="#流程适合性" class="headerlink" title="流程适合性"></a>流程适合性</h2><p>您可以使用以下标准评估流程是否适合自动化：</p><h3 id="基于规则"><a href="#基于规则" class="headerlink" title="基于规则"></a>基于规则</h3><p>可通过预定义逻辑捕获在流程中做出的决策（包括数据解释）。这样带来的结果是，异常率要么很低，要么包含在业务逻辑中。</p><h3 id="可自动化和-或重复性流程"><a href="#可自动化和-或重复性流程" class="headerlink" title="可自动化和&#x2F;或重复性流程"></a>可自动化和&#x2F;或重复性流程</h3><p>我们可以区分4种类型的流程：<br>手动非重复性流程：由人工执行且每次执行该流程时都有不同的流程步骤<br>手动重复性流程：由用户执行，并且每次至少有部分相同的流程步骤<br>半自动化重复性流程：其中一些重复的步骤已经实现自动化（使用宏、Outlook 规则等）<br>自动化流程：已使用除 RPA 之外的其他技术实现自动化的流程<br>由于异常率高或无法集成到业务逻辑中的因素，仍然需要手动执行或非重复性的流程并非自动化的理想选择。</p><h3 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h3><p>流程中的输入应采用电子形式且易于读取，或者可以使用与 RPA 相关的技术（例如 OCR）进行读取。预定义字段的发票就是很好的例子。</p><h3 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h3><p>在一定时期内相同且在接下来的几个月内预计不会发生任何变化的流程适合自动化，前提是它们也符合另一个标准。</p><h2 id="自动化的复杂性"><a href="#自动化的复杂性" class="headerlink" title="自动化的复杂性"></a>自动化的复杂性</h2><p>这套标准用于确定实现流程自动化的难度：</p><h3 id="界面数量"><a href="#界面数量" class="headerlink" title="界面数量"></a>界面数量</h3><p>RPA的工作原理是，通过对机器人进行编程，使其可以在界面级别执行任务（当界面更改时，机器人必须学习逻辑）。界面数量越多，在实现流程自动化之前必须捕获和配置的元素就越多。</p><h3 id="应用程序的类型"><a href="#应用程序的类型" class="headerlink" title="应用程序的类型"></a>应用程序的类型</h3><p>有些应用程序较易实现自动化（例如 Office套件或浏览器），而有些则需要大量工作才能实现自动化（例如大型机）。随着应用程序的差异越大，界面数量也会随之增加（参见上一点）。</p><h3 id="业务逻辑场景"><a href="#业务逻辑场景" class="headerlink" title="业务逻辑场景"></a>业务逻辑场景</h3><p>自动化的复杂性随着业务逻辑中决策点的数量而增加。基本上，每个决策点乘二即可得出场景数量。</p><h3 id="输入的类型和数量"><a href="#输入的类型和数量" class="headerlink" title="输入的类型和数量"></a>输入的类型和数量</h3><p>如前所述，需要使用标准输入。但在某些情况下，必须为将受到自动化影响的所有供应商配置一个标准输入（例如发票）。此外，非标准输入可以分为不同的复杂性等级，其中自由文本是最复杂的。</p><h2 id="评估自动化潜力"><a href="#评估自动化潜力" class="headerlink" title="评估自动化潜力"></a>评估自动化潜力</h2><h3 id="不使用RPA"><a href="#不使用RPA" class="headerlink" title="不使用RPA"></a>不使用RPA</h3><p>频繁变化、系统环境多变且需要执行多个手动（甚至非数字）操作的流程。</p><h3 id="半自动化"><a href="#半自动化" class="headerlink" title="半自动化"></a>半自动化</h3><p>可以分解为可明确自动化的步骤和仍需手动执行的步骤（例如验证或使用物理安全性令牌）的流程。</p><h3 id="高成本RPA"><a href="#高成本RPA" class="headerlink" title="高成本RPA"></a>高成本RPA</h3><p>数字化程度较高并且可以实现自动化的流程，但需要使用一些复杂的技术（例如 OCR）或需要具备高级编程技能。</p><h3 id="零接触自动化"><a href="#零接触自动化" class="headerlink" title="零接触自动化"></a>零接触自动化</h3><p>涉及高度静态的系统和流程环境的数字化流程，这些流程很容易就能分解为指令并且可以定义简单的触发器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着科技的发展，RPA（Robotic Process Automation）流程自动化已经成为企业提升效率，降低成本的重要工具。我们需要理解RPA的基本概念和特性。RPA是一种可以模拟和复制人类在应用程序中执行的重复任务的技术，它可以24&amp;#x2F;7不间断工作，不需要休息，也不需要假期。这种特性使得RPA非常适合处理大量的、重复的、规则化的任务。&lt;br&gt;那么那些场景或需求合适使用自动化呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA、Python、办公自动化" scheme="https://longchao012.github.io/tags/RPA%E3%80%81Python%E3%80%81%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hello World For LongChao</title>
    <link href="https://longchao012.github.io/2022/07/15/hello-world/"/>
    <id>https://longchao012.github.io/2022/07/15/hello-world/</id>
    <published>2022-07-15T07:23:41.000Z</published>
    <updated>2023-08-23T10:15:26.188Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
