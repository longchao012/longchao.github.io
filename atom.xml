<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://longchao012.github.io/atom.xml" rel="self"/>
  
  <link href="https://longchao012.github.io/"/>
  <updated>2023-09-04T06:00:12.568Z</updated>
  <id>https://longchao012.github.io/</id>
  
  <author>
    <name>龙超小站</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python入门的19个基础语法</title>
    <link href="https://longchao012.github.io/2022/09/02/Python%E5%85%A5%E9%97%A8%E7%9A%8419%E4%B8%AA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://longchao012.github.io/2022/09/02/Python%E5%85%A5%E9%97%A8%E7%9A%8419%E4%B8%AA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-09-02T03:40:06.000Z</published>
    <updated>2023-09-04T06:00:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>Python简单易学，但又博大精深。</p><p>许多人号称精通Python，却不会写Pythonic的代码，对很多常用包的使用也并不熟悉。<br>ps:Pythonic是指代码遵循Python社区的惯例，并以其预期的方式使用该语言。Pythonic的代码不仅仅是语法正确，而是充分利用Python语言的特性来产生清晰、简洁和可维护的代码 。</p><p>学海无涯，我们先来了解一些Python中最基本的内容。</p><span id="more"></span><ul><li><p>Python的特点</p><ul><li><p>解释型语言，无需编译即可运行</p></li><li><p>提供了交互式命令行</p></li><li><p>基于对象的编程思想</p></li><li><p>跨平台和良好的兼容性，在Windows、Mac、Linux上都可运行</p></li><li><p>简单好用而且功能强大</p></li></ul></li><li><h2 id="01-中文编码"><a href="#01-中文编码" class="headerlink" title="01 中文编码"></a>01 中文编码</h2></li></ul><p>很多同学在打开数据时会遇上乱码问题，其原因是字符集的编码问题。Linux和Mac默认的编码集是UTF8，而Windows则是ASCII。如果数据编码的字符集，和你使用Python进行处理时所用的字符集不同，则会出现乱码问题。</p><p>另外，我个人的习惯是在Python代码的头部加入以下内容，其中第二行声明了使用UTF8字符集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding:utf8</span><br></pre></td></tr></table></figure><ul><li><h2 id="02-变量"><a href="#02-变量" class="headerlink" title="02 变量"></a>02 变量</h2></li></ul><p>Python中的变量可以看作是一个个容器，里面存放着我们需要使用到的值。</p><p>Python对变量名的要求和其他语言一样：可以包括英文、数字以及下划线，但不能以数字开头，区分大小写。 当然我推荐，变量名用纯英文就很好，并且取一些有意义的名称，便于自己理解每个变量的作用。</p><p>Python是一门弱类型的语言，在使用变量时无需声明其类型。Python中的变量包括以下几类：数值、字符串、列表、元组、字典。</p><ul><li><h2 id="03-数值"><a href="#03-数值" class="headerlink" title="03 数值"></a>03 数值</h2></li></ul><p>数值包括整型和浮点型，分别对应整数和浮点数，后者精度更高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 整型</span><br><span class="line">a = 1</span><br><span class="line"># 浮点型</span><br><span class="line">b = 2.1</span><br><span class="line">print a, b</span><br></pre></td></tr></table></figure><ul><li><h2 id="04-字符串"><a href="#04-字符串" class="headerlink" title="04 字符串"></a>04 字符串</h2></li></ul><p>字符串也就是我们经常接触到的文本，可以往里面放任意长度的内容，用单引号或双引号括起来。应当注意，中文以及中文符号只能出现在字符串內，如果在下面第三行中使用了中文输入法的逗号 ，Python将报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c =  Hello </span><br><span class="line">d =  你好 </span><br><span class="line">print c, d</span><br></pre></td></tr></table></figure><p>使用 + 可以拼接两个字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print c + d</span><br></pre></td></tr></table></figure><p>使用 len() 可以得到字符串的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print len( Hello World )</span><br></pre></td></tr></table></figure><p>使用切片可以访问字符串中的某个字符或某个片段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 位置下标从0开始</span><br><span class="line">c =  Hello World </span><br><span class="line"># 打印结果为H，下标为0表示第一个字符</span><br><span class="line">print c[0]</span><br><span class="line"># 打印结果为d，下标为负数表示从后往前数</span><br><span class="line"># 所以-1表示倒数第一个字符</span><br><span class="line">print c[-1]</span><br><span class="line"># 使用:返回一个片段，冒号前后分别为开始下标和结束下标</span><br><span class="line"># 包括开始下标，但不包括结束下标</span><br><span class="line"># 因此c[1:5]表示，返回下标从1到4的片段，即第二个到第五个字符</span><br><span class="line">print c[1:5]</span><br><span class="line"># 冒号前后的下标同样可以使用负数</span><br><span class="line"># 或者不提供，表示从最左端开始或一直到最右端</span><br><span class="line">print c[1:-1], c[:5], c[3:]</span><br></pre></td></tr></table></figure><ul><li><h2 id="05-列表"><a href="#05-列表" class="headerlink" title="05 列表"></a>05 列表</h2></li></ul><p>列表好比一条队伍，里面依次存放着多个变量。列表和字符串类似，但字符串中的每个元素都是字符，而列表中的每个元素可以是任意类型的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用[]定义一个空列表，使用append()向列表尾部添加一个元素</span><br><span class="line"># 如果要添加到首部，就用prepend()好了</span><br><span class="line">a = []</span><br><span class="line">a.append(1)</span><br><span class="line">a.append(2.1)</span><br><span class="line">a.append( Hello )</span><br><span class="line">print a</span><br></pre></td></tr></table></figure><p>使用 len() 可以获得列表的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print len(a)</span><br></pre></td></tr></table></figure><p>列表元素的按下标访问和赋值等操作，和字符串都是类似的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print a[1], a[-1]</span><br><span class="line">a[1] = 100</span><br><span class="line">print a</span><br></pre></td></tr></table></figure><p>使用 del 删除列表中的某个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del a[0]print a</span><br></pre></td></tr></table></figure><ul><li><h2 id="06-元组"><a href="#06-元组" class="headerlink" title="06 元组"></a>06 元组</h2></li></ul><p>元组和列表类似，唯一的不同是元组中的元素在初始化之后不能再更改，因此可以理解成一个只读的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 使用()定义一个元组a = (1, 2.1,  Hello )# 尝试修改元组中的元素会报错a[0] = 100</span><br></pre></td></tr></table></figure><ul><li><h2 id="07-字典"><a href="#07-字典" class="headerlink" title="07 字典"></a>07 字典</h2></li></ul><p>字典是一种极为重要的变量类型，使用一个key来访问相应的value，即一种键值对的数据形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 使用&#123;&#125;定义一个字典a = &#123;&#125;# 使用key来赋值valuea[ k1 ] = 1a[ k2 ] = 2.1a[ k3 ] =  Hello</span><br></pre></td></tr></table></figure><p>所以能够总结出字典和列表的不同。列表中的元素是有序对等的，所以是用下标来赋值和访问，而字典中的元素是无序的，所以是用key来操作相应value。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 使用&#123;&#125;定义一个字典a = &#123;&#125;# 使用key来赋值valuea[ k1 ] = 1a[ k2 ] = 2.1a[ k3 ] =  Hello</span><br></pre></td></tr></table></figure><p>使用 has_key() 判断字典中是否有某个key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print di.has_key( k4 )</span><br></pre></td></tr></table></figure><p>如果访问不存在的key，Python将会报错。在赋值的时候，如果key已经存在，则会用新的value覆盖已有的value。</p><ul><li><h2 id="08-注释"><a href="#08-注释" class="headerlink" title="08 注释"></a>08 注释</h2></li></ul><p>被注释的代码将不会运行，可以看作是写给自己和其他程序猿阅读的一些笔记和说明，提高代码可读性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 这里是单行注释   这里是很多行注释</span><br></pre></td></tr></table></figure><p>在Sublime中，选中需要注释的内容，按Ctrl+&#x2F;即可完成注释。</p><ul><li><h2 id="09-保留字符"><a href="#09-保留字符" class="headerlink" title="09 保留字符"></a>09 保留字符</h2></li></ul><p>在Python中，有一些字符串具有某些特定功能，如 import 、 class 等。我们在选择变量名时，应注意避开这些保留字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以下变量赋值将报错</span><br><span class="line">import = 1</span><br></pre></td></tr></table></figure><ul><li><h2 id="10-行和缩进"><a href="#10-行和缩进" class="headerlink" title="10 行和缩进"></a>10 行和缩进</h2></li></ul><p>在Python中，代码块的边界不是通过大括号等符号进行显式划分，而是通过行的缩进实现的。连续相同缩进水平的代码处于同一个代码块，在使用 for、while、if 、try等语法时需要注意每行代码的缩进。</p><ul><li><h2 id="11-运算符"><a href="#11-运算符" class="headerlink" title="11 运算符"></a>11 运算符</h2></li></ul><p>运算符的作用是根据已有的变量生成新的变量，主要有以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">算术运算符：+，-，*，/，%，即加、减、乘、除、取余</span><br><span class="line"></span><br><span class="line">比较运算符：==，!=，&gt;，&lt;，&gt;=，&lt;=，即等于、不等于、大于、小于、大于等于、小于等于</span><br><span class="line"></span><br><span class="line">赋值运算符：=，+=，-=，*=，/=，%=，即赋值、加赋值、减赋值、乘赋值、除赋值、取余赋值</span><br><span class="line"></span><br><span class="line">逻辑运算符：and，or，not，即与、或、非</span><br><span class="line"></span><br><span class="line">a = 1b = 2print a + bprint a == b# 等价于 a = a + 3a += 3print ac = Trued = Falseprint c and d</span><br></pre></td></tr></table></figure><ul><li><h2 id="12-条件"><a href="#12-条件" class="headerlink" title="12 条件"></a>12 条件</h2></li></ul><p>在写代码的时候，往往需要根据某些条件进行判断，并根据判断结果执行不同的分支代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line"># 单个条件</span><br><span class="line">if a == 1:</span><br><span class="line">    print 11111</span><br><span class="line"># 处理条件不成立的分支</span><br><span class="line">if a == 2:</span><br><span class="line">    print 22222</span><br><span class="line">else:</span><br><span class="line">    print 33333</span><br><span class="line"># 多个条件，加多少个都可以</span><br><span class="line">if a == 1:</span><br><span class="line">    print 11111</span><br><span class="line">elif a == 2:</span><br><span class="line">    print 22222</span><br><span class="line">else:    </span><br><span class="line">print 33333</span><br></pre></td></tr></table></figure><p>需要注意的是，但凡出现了 if 和 elif ，就需要加上相应的条件判断，并且注意代码的缩进。在Sublime中输入if会出现相应的提示，可以方便地补全代码，在换行时光标也会自动跳到合适的缩进处。</p><ul><li><h2 id="13-循环"><a href="#13-循环" class="headerlink" title="13 循环"></a>13 循环</h2></li></ul><p>如果需要打印从1到100的100个数，肯定不会傻傻地写100行print代码，而是会用循环来处理类似的重复性工作。</p><ul><li><h2 id="14-while-循环"><a href="#14-while-循环" class="headerlink" title="14 while 循环"></a>14 while 循环</h2></li></ul><p>while 循环的思想是，只要某一条件成立，就不断执行循环体里的代码，直到条件不再成立。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag = 1while flag &lt; 10:</span><br><span class="line">    print flag    </span><br><span class="line"># 一定要记得在循环体里修改条件变量    </span><br><span class="line"># 否则可能导致死循环</span><br><span class="line">    flag += 1</span><br></pre></td></tr></table></figure><ul><li><h2 id="15-for-循环"><a href="#15-for-循环" class="headerlink" title="15 for 循环"></a>15 for 循环</h2></li></ul><p>for 循环的循环次数一般是事先预知的，将一个标志变量从某个起始值迭代到某个终止值后即结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># x从0开始，一直到9结束</span><br><span class="line">for x in xrange(0, 10):</span><br><span class="line">    print x</span><br></pre></td></tr></table></figure><p>可以用 for 循环方便地遍历列表和字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2.1,  Hello ]</span><br><span class="line">dict = &#123; k1 : 1,  k2 : 2.1,  k3 :  Hello &#125;</span><br><span class="line"># 遍历列表，这里的item只是一个临时变量，取别的名称也行</span><br><span class="line">for item in li:</span><br><span class="line">    print item</span><br><span class="line"># 遍历字典的全部key，这里的key也只是一个临时变量，名称不重要</span><br><span class="line">for key in dict.keys():</span><br><span class="line">    print key</span><br><span class="line"># 遍历字典的全部value，这里的value也只是一个临时变量，名称不重要</span><br><span class="line">for value in dict.values():</span><br><span class="line">    print value</span><br><span class="line"># 同时遍历key和value</span><br><span class="line">for key, value in dict.items():</span><br><span class="line">    print key, value</span><br></pre></td></tr></table></figure><ul><li><h2 id="16-循环控制"><a href="#16-循环控制" class="headerlink" title="16 循环控制"></a>16 循环控制</h2></li></ul><p>循环控制主要包括三种：pass 、 continue 、 break 。</p><p>pass 表示什么也不做，只是占一行代码的位置；continue 表示立即退出本轮循环，继续执行后续轮循环；break 表示立即推出循环，后续循环也不再执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for x in xrange(0, 10):</span><br><span class="line">    if x == 5:</span><br><span class="line">pass</span><br><span class="line">    else:</span><br><span class="line">print x</span><br><span class="line">for x in xrange(0, 10):</span><br><span class="line">    if x == 5:</span><br><span class="line">continue</span><br><span class="line">    print x</span><br><span class="line">for x in xrange(0, 10):</span><br><span class="line">    if x == 5:</span><br><span class="line">break</span><br><span class="line">print x</span><br></pre></td></tr></table></figure><ul><li><h2 id="17-时间"><a href="#17-时间" class="headerlink" title="17 时间"></a>17 时间</h2></li></ul><p>在处理数据时，很多地方都会涉及到时间，例如数据产生的时间。先介绍一下时间戳的概念，时间戳指的是从1970年1月1日0时0分0秒开始，到某一时刻所经历的秒数，可以是整数或者小数，后者的精度更高。</p><p>为什么需要时间戳这样的一个概念？因为对于同一个时刻，不同人的描述可能不同，毕竟文本的形式千变万化，而时间戳使得时间的表达得到了统一，每个时刻只能用唯一的整数或浮点数来表示，同时也便于计算时间差这样的处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 来看一下当前时刻的时间戳吧</span><br><span class="line">import timet = time.time()</span><br><span class="line">print t, type(t)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于时间戳，最常用的处理便是时间戳和时间文本之间的转换，例如将 2016年10月1日 10时0分0秒 转为时间戳。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"># 时间文本转时间戳，精确到秒</span><br><span class="line">a =  2016-10-01 10:00:00 </span><br><span class="line">a = int(time.mktime(time.strptime(a, %Y-%m-%d %H:%M:%S )))</span><br><span class="line">print a</span><br><span class="line"># 时间戳转时间文本</span><br><span class="line">b = int(time.time())</span><br><span class="line">b = time.strftime( %Y-%m-%d %H:%M:%S , time.localtime(b))</span><br><span class="line">print b</span><br></pre></td></tr></table></figure><p>其中， %Y 、 %m 等都是时间字段，前者表示四位的年份，后者表示两位的月份。</p><p>文件</p><p>文件操作包括向文件中写内容，以及从文件中读内容，使用 open() 打开一个文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 写文件</span><br><span class="line"># 重新写模式，打开文件时会将文件内容清空</span><br><span class="line">fw = open( data.txt ,  w )</span><br><span class="line"># 追加写模式，打开文件后保留原始内容，继续写入</span><br><span class="line">for x in xrange(0, 10):</span><br><span class="line">    # 将整数转成文本再写入</span><br><span class="line">    fw.write(str(x))</span><br><span class="line">    # 也可以每次写入之后换行，为转义字符，表示换行    </span><br><span class="line"># fw.write(str(x) +   )</span><br><span class="line">fw.close()</span><br><span class="line"># 读文件</span><br><span class="line">fr = open( data.txt ,  r )</span><br><span class="line"># 一行一行地读，line只是个临时变量，取别的名称也行</span><br><span class="line">for line in fr:</span><br><span class="line">    print line</span><br><span class="line">    # 如果每行后面有换行，可以将换行符去掉，使内容更紧凑</span><br><span class="line">    # strip()可以去掉字符串两端的空白字符    </span><br><span class="line"># print line.strip()</span><br><span class="line">fr.close()</span><br></pre></td></tr></table></figure><ul><li><h2 id="18-异常"><a href="#18-异常" class="headerlink" title="18 异常"></a>18 异常</h2></li></ul><p>Python代码中可能会出现一些可以预知的问题，例如字典访问的key不存在。</p><p>如果不加处理，发生问题的时候Python便会报错并退出，可能之前跑了很久又要重头再来。因此，我们需要对可能出现的异常进行捕捉和处理。异常的结构由 try 、except 、 else 、 finally 四部分组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try:    </span><br><span class="line"># 尝试执行这些代码    </span><br><span class="line">print 1 / 0except </span><br><span class="line">Exception, e:    </span><br><span class="line"># 如果出现异常就进行处理    </span><br><span class="line"># e为出现的异常类型    </span><br><span class="line">print eelse:    </span><br><span class="line"># try里的代码没有出错    </span><br><span class="line"># 可以执行后续工作了    </span><br><span class="line">print  没有出错 </span><br><span class="line">finally:    </span><br><span class="line"># 无论是否出错，都会执行的代码    </span><br><span class="line">print &quot;一定会执行&quot;</span><br></pre></td></tr></table></figure><ul><li><h2 id="19-函数"><a href="#19-函数" class="headerlink" title="19 函数"></a>19 函数</h2></li></ul><p>函数的作用是代码模块化，将可重用的代码封装成一个函数，这样在需要使用的时候就只需调用写好的函数即可，而不用重新写一遍代码。</p><p>函数的使用包括两个部分，函数的定义和函数的调用。除此之外，函数可以有一个或多个参数，参数之间以逗号分开，为函数的功能提供更多的灵活性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义函数</span><br><span class="line">def hello(name1, name2):</span><br><span class="line">    print  Hello  + name1 + name2</span><br><span class="line"># 调用函数</span><br><span class="line">hello(Python,JavaScri)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python简单易学，但又博大精深。&lt;/p&gt;
&lt;p&gt;许多人号称精通Python，却不会写Pythonic的代码，对很多常用包的使用也并不熟悉。&lt;br&gt;ps:Pythonic是指代码遵循Python社区的惯例，并以其预期的方式使用该语言。Pythonic的代码不仅仅是语法正确，而是充分利用Python语言的特性来产生清晰、简洁和可维护的代码 。&lt;/p&gt;
&lt;p&gt;学海无涯，我们先来了解一些Python中最基本的内容。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://longchao012.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>几个新的常用Python库，旧的可以淘汰了</title>
    <link href="https://longchao012.github.io/2022/08/31/%E5%87%A0%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B8%B8%E7%94%A8Python%E5%BA%93%EF%BC%8C%E6%97%A7%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%B7%98%E6%B1%B0%E4%BA%86/"/>
    <id>https://longchao012.github.io/2022/08/31/%E5%87%A0%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B8%B8%E7%94%A8Python%E5%BA%93%EF%BC%8C%E6%97%A7%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%B7%98%E6%B1%B0%E4%BA%86/</id>
    <published>2022-08-31T02:56:14.000Z</published>
    <updated>2023-09-04T03:03:00.264Z</updated>
    
    <content type="html"><![CDATA[<p>随着每个 Python 版本的发布，都会添加新模块，并引入新的更好的做事方式，虽然我们都习惯了使用好的旧 Python 库和某些做事方式，但现在也时候升级并利用新的和改进的模块及其特性了。</p><span id="more"></span><p><strong>Pathlib 而不是 OS</strong><br>pathlib 绝对是 Python 标准库中最近添加的更大的内容之一， 自 Python 3.4 以来，它一直是标准库的一部分，但很多人仍然使用 os 模块进行文件系统操作。</p><p>然而，pathlib 与旧的 os.path 相比具有许多优点 - 虽然 os 模块以原始字符串格式表示路径，但 pathlib 使用面向对象的样式，这使得它更具可读性和编写自然：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pathlib import Path</span><br><span class="line">import os.path</span><br><span class="line"></span><br><span class="line"># 老方式</span><br><span class="line">two_dirs_up = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"></span><br><span class="line"># 新方式，可读性强</span><br><span class="line">two_dirs_up = Path(__file__).resolve().parent.parent</span><br></pre></td></tr></table></figure><p>路径被视为对象而不是字符串这一事实也使得可以创建一次对象，然后查找其属性或对其进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">readme = Path(&quot;README.md&quot;).resolve()</span><br><span class="line"></span><br><span class="line">print(f&quot;Absolute path: &#123;readme.absolute()&#125;&quot;)</span><br><span class="line"># Absolute path: /home/martin/some/path/README.md</span><br><span class="line">print(f&quot;File name: &#123;readme.name&#125;&quot;)</span><br><span class="line"># File name: README.md</span><br><span class="line">print(f&quot;Path root: &#123;readme.root&#125;&quot;)</span><br><span class="line"># Path root: /</span><br><span class="line">print(f&quot;Parent directory: &#123;readme.parent&#125;&quot;)</span><br><span class="line"># Parent directory: /home/martin/some/path</span><br><span class="line">print(f&quot;File extension: &#123;readme.suffix&#125;&quot;)</span><br><span class="line"># File extension: .md</span><br><span class="line">print(f&quot;Is it absolute: &#123;readme.is_absolute()&#125;&quot;)</span><br><span class="line"># Is it absolute: True</span><br></pre></td></tr></table></figure><p>我最喜欢 pathlib 的一个特性是可以使用 &#x2F;（“除法”）运算符来连接路径：</p><p># Operators:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">etc = Path(&#x27;/etc&#x27;)</span><br><span class="line"></span><br><span class="line">joined = etc / &quot;cron.d&quot; / &quot;anacron&quot;</span><br><span class="line">print(f&quot;Exists? - &#123;joined.exists()&#125;&quot;)</span><br><span class="line"># Exists? - True</span><br></pre></td></tr></table></figure><p>重要的是要注意 pathlib 只是替代 os.path 而不是整个 os 模块， 它还包括 glob 模块的功能，因此如果你习惯于将 os.path 与 glob.glob 结合使用，那么你可以完全用pathlib替代它们。</p><p>在上面的片段中，我们展示了一些方便的路径操作和对象属性，但 pathlib 还包括你习惯于 os.path 的所有方法，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(f&quot;Working directory: &#123;Path.cwd()&#125;&quot;)  # same as os.getcwd()</span><br><span class="line"># Working directory: /home/martin/some/path</span><br><span class="line">Path.mkdir(Path.cwd() / &quot;new_dir&quot;, exist_ok=True)  # same as os.makedirs()</span><br><span class="line">print(Path(&quot;README.md&quot;).resolve())  # same as os.path.abspath()</span><br><span class="line"># /home/martin/some/path/README.md</span><br><span class="line">print(Path.home())  # same as os.path.expanduser()</span><br><span class="line"># /home/martin</span><br></pre></td></tr></table></figure><p>有关 os.path 函数到 pathlib 中新函数的完整映射，请参阅 官方文档。</p><p><strong>Secrets 而不是 OS</strong><br>说到 os 模块，你应该停止使用的另一部分是 os.urandom。相反，你应该使用自 Python 3.6 以来可用的新秘密模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 老方式:</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">length = 64</span><br><span class="line"></span><br><span class="line">value = os.urandom(length)</span><br><span class="line">print(f&quot;Bytes: &#123;value&#125;&quot;)</span><br><span class="line"># Bytes: b&#x27;\xfa\xf3...\xf2\x1b\xf5\xb6&#x27;</span><br><span class="line">print(f&quot;Hex: &#123;value.hex()&#125;&quot;)</span><br><span class="line"># Hex: faf3cc656370e31a938e7...33d9b023c3c24f1bf5</span><br><span class="line"></span><br><span class="line"># 新方式:</span><br><span class="line">import secrets</span><br><span class="line"></span><br><span class="line">value = secrets.token_bytes(length)</span><br><span class="line">print(f&quot;Bytes: &#123;value&#125;&quot;)</span><br><span class="line"># Bytes: b&#x27;U\xe9n\x87...\x85&gt;\x04j:\xb0&#x27;</span><br><span class="line">value = secrets.token_hex(length)</span><br><span class="line">print(f&quot;Hex: &#123;value&#125;&quot;)</span><br><span class="line"># Hex: fb5dd85e7d73f7a08b8e3...4fd9f95beb08d77391</span><br></pre></td></tr></table></figure><p>使用 os.urandom 实际上并不是这里的问题，引入secrets模块的原因是因为人们使用随机模块来生成密码等，即使随机模块不产生密码安全令牌。</p><p>根据文档，随机模块不应用于安全目的， 你应该使用 secrets 或 os.urandom，但 secrets 模块绝对更可取，因为它比较新，并且包含一些用于十六进制令牌的实用程序&#x2F;便利方法以及 URL 安全令牌。</p><p><strong>Zoneinfo 而不是 pytz</strong><br>在 Python 3.9 之前，没有用于时区操作的内置库，所以每个人都在使用 pytz，但现在我们在标准库中有 zoneinfo，所以是时候切换了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">import pytz  # pip install pytz</span><br><span class="line"></span><br><span class="line">dt = datetime(2022, 6, 4)</span><br><span class="line">nyc = pytz.timezone(&quot;America/New_York&quot;)</span><br><span class="line"></span><br><span class="line">localized = nyc.localize(dt)</span><br><span class="line">print(f&quot;Datetime: &#123;localized&#125;, Timezone: &#123;localized.tzname()&#125;, TZ Info: &#123;localized.tzinfo&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 新方式:</span><br><span class="line">from zoneinfo import ZoneInfo</span><br><span class="line"></span><br><span class="line">nyc = ZoneInfo(&quot;America/New_York&quot;)</span><br><span class="line">localized = datetime(2022, 6, 4, tzinfo=nyc)</span><br><span class="line">print(f&quot;Datetime: &#123;localized&#125;, Timezone: &#123;localized.tzname()&#125;, TZ Info: &#123;localized.tzinfo&#125;&quot;)</span><br><span class="line"># Datetime: 2022-06-04 00:00:00-04:00, Timezone: EDT, TZ Info: America/New_York</span><br></pre></td></tr></table></figure><p>datetime 模块将所有时区操作委托给抽象基类 datetime.tzinfo， 这个抽象基类需要一个具体的实现——在引入这个很可能来自 pytz 的模块之前。现在我们在标准库中有 zoneinfo，我们可以使用它。</p><p>然而，使用 zoneinfo 有一个警告——它假定系统上有可用的时区数据，UNIX 系统就是这种情况， 如果你的系统没有时区数据，那么你应该使用 tzdata 包，它是由 CPython 核心开发人员维护的第一方库，其中包含 IANA 时区数据库。</p><p><strong>Dataclasses</strong><br>Python 3.7 的一个重要补充是 dataclasses 包，它是 namedtuple 的替代品。</p><p>你可能想知道为什么需要替换 namedtuple？以下是你应该考虑切换到数据类的一些原因：</p><p>1、它可以是可变的<br>2、默认提供 repr、eq、init、hash 魔术方法，<br>3、允许指定默认值，<br>4、支持继承。此外，数据类还支持 frozen 和 slots（从 3.10 开始）属性以提供与命名元组的特征奇偶校验。<br>切换真的不应该太难，因为你只需要更改定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 老方式:</span><br><span class="line"># from collections import namedtuple</span><br><span class="line">from typing import NamedTuple</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">User = NamedTuple(&quot;User&quot;, [(&quot;name&quot;, str), (&quot;surname&quot;, str), (&quot;password&quot;, bytes)])</span><br><span class="line"></span><br><span class="line">u = User(&quot;John&quot;, &quot;Doe&quot;, b&#x27;tfeL+uD...\xd2&#x27;)</span><br><span class="line">print(f&quot;Size: &#123;sys.getsizeof(u)&#125;&quot;)</span><br><span class="line"># Size: 64</span><br><span class="line"></span><br><span class="line"># 新方式:</span><br><span class="line">from dataclasses import dataclass</span><br><span class="line"></span><br><span class="line">@dataclass()</span><br><span class="line">class User:</span><br><span class="line">   name: str</span><br><span class="line">   surname: str</span><br><span class="line">   password: bytes</span><br><span class="line"></span><br><span class="line">u = User(&quot;John&quot;, &quot;Doe&quot;, b&#x27;tfeL+uD...\xd2&#x27;)</span><br><span class="line"></span><br><span class="line">print(u)</span><br><span class="line"># User(name=&#x27;John&#x27;, surname=&#x27;Doe&#x27;, password=b&#x27;tfeL+uD...\xd2&#x27;)</span><br><span class="line"></span><br><span class="line">print(f&quot;Size: &#123;sys.getsizeof(u)&#125;, &#123;sys.getsizeof(u) + sys.getsizeof(vars(u))&#125;&quot;)</span><br><span class="line"># Size: 48, 152</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们还包含了大小比较，因为这是 namedtuple 和数据类之间的较大差异之一，如上所见，命名元组的大小要小得多，这是由于数据类使用 dict 来表示属性。</p><p>至于速度比较，除非你计划创建数百万个实例，否则属性的访问时间应该基本相同，或者不够重要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line"></span><br><span class="line">setup = &#x27;&#x27;&#x27;</span><br><span class="line">from typing import NamedTuple</span><br><span class="line">User = NamedTuple(&quot;User&quot;, [(&quot;name&quot;, str), (&quot;surname&quot;, str), (&quot;password&quot;, bytes)])</span><br><span class="line">u = User(&quot;John&quot;, &quot;Doe&quot;, b&#x27;&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">print(f&quot;Access speed: &#123;min(timeit.repeat(&#x27;u.name&#x27;, setup=setup, number=10000000))&#125;&quot;)</span><br><span class="line"># Access speed: 0.16838401100540068</span><br><span class="line"></span><br><span class="line">setup = &#x27;&#x27;&#x27;</span><br><span class="line">from dataclasses import dataclass</span><br><span class="line"></span><br><span class="line">@dataclass(slots=True)</span><br><span class="line">class User:</span><br><span class="line">  name: str</span><br><span class="line">  surname: str</span><br><span class="line">  password: bytes</span><br><span class="line"></span><br><span class="line">u = User(&quot;John&quot;, &quot;Doe&quot;, b&#x27;&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">print(f&quot;Access speed: &#123;min(timeit.repeat(&#x27;u.name&#x27;, setup=setup, number=10000000))&#125;&quot;)</span><br><span class="line"># Access speed: 0.17728697300481144</span><br></pre></td></tr></table></figure><p>如果以上内容说服了你打算切换到数据类，请尽快尝试吧</p><p>相反，如果你不想切换并且出于某种原因真的想使用命名元组，那么你至少应该使用键入模块而不是collections中的 NamedTuple：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 不好方式的:</span><br><span class="line">from collections import namedtuple</span><br><span class="line">Point = namedtuple(&quot;Point&quot;, [&quot;x&quot;, &quot;y&quot;])</span><br><span class="line"></span><br><span class="line"># 更好的方式:</span><br><span class="line">from typing import NamedTuple</span><br><span class="line">class Point(NamedTuple):</span><br><span class="line">    x: float</span><br><span class="line">    y: float</span><br></pre></td></tr></table></figure><p>最后，如果你既不使用 namedtuple 也不使用数据类，你可能需要考虑直接使用 Pydantic。</p><p><strong>Proper Logging 而不是 print</strong><br>这不是标准库的最新添加，但值得使用 - 你应该使用正确的日志记录而不是打印语句， 如果你在本地调试问题，则可以使用 print，但对于任何无需用户干预即可运行的生产就绪程序，正确的日志记录是必须的。</p><p>特别是考虑到设置 Python 日志记录非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(</span><br><span class="line">    filename=&#x27;application.log&#x27;,</span><br><span class="line">    level=logging.WARNING,</span><br><span class="line">    format=&#x27;[%(asctime)s] &#123;%(pathname)s:%(lineno)d&#125; %(levelname)s - %(message)s&#x27;,</span><br><span class="line">    datefmt=&#x27;%H:%M:%S&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logging.error(&quot;Some serious error occurred.&quot;)</span><br><span class="line"># [12:52:35] &#123;&lt;stdin&gt;:1&#125; ERROR - Some serious error occurred.</span><br><span class="line">logging.warning(&#x27;Some warning.&#x27;)</span><br><span class="line"># [12:52:35] &#123;&lt;stdin&gt;:1&#125; WARNING - Some warning.</span><br></pre></td></tr></table></figure><p>与打印语句相比，上面的简单配置将为你提供卓越的调试体验， 最重要的是，你可以进一步自定义日志库以记录到不同的位置、更改日志级别、自动轮换日志等。</p><p><strong>f-strings 而不是 format</strong><br>Python 包含很多格式化字符串的方法，包括 C 样式格式化、f 字符串、模板字符串或 .format 函数， 不过，其中之一 - f-strings - 格式化的字符串文字 ， 它们写起来更自然，可读性更强，并且是前面提到的选项中最快的。</p><p>因此，我认为没有必要争论或解释为什么要使用它们，然而，在某些情况下不能使用 f 字符串：</p><p>使用 % 格式的唯一原因是用于记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">things = &quot;something happened...&quot;</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.error(&quot;Message: %s&quot;, things)  # 评估内部记录器方法</span><br><span class="line">logger.error(f&quot;Message: &#123;things&#125;&quot;)  # 立即评估</span><br></pre></td></tr></table></figure><p>在上面的示例中，如果你使用 f 字符串，则表达式将立即计算，而使用 C 样式格式，替换将被推迟到实际需要时，这对于消息分组很重要，其中具有相同模板的所有消息都可以记录为一个， 这不适用于 f 字符串，因为模板在传递给记录器之前填充了数据。</p><p>此外，有些事情是 f-strings 根本无法做到的， 例如在运行时填充模板 - 即动态格式 - 这就是 f-strings 被称为文字字符串格式的原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 动态设置模板及其参数</span><br><span class="line">def func(tpl: str, param1: str, param2: str) -&gt; str:</span><br><span class="line">    return tpl.format(param=param1, param2=param2)</span><br><span class="line"></span><br><span class="line">some_template = &quot;First template: &#123;param1&#125;, &#123;param2&#125;&quot;</span><br><span class="line">another_template = &quot;Other template: &#123;param1&#125; and &#123;param2&#125;&quot;</span><br><span class="line">print(func(some_template, &quot;Hello&quot;, &quot;World&quot;))</span><br><span class="line">print(func(another_template, &quot;Hello&quot;, &quot;Python&quot;))</span><br><span class="line"></span><br><span class="line"># 动态重用具有不同参数的相同模板.</span><br><span class="line">inputs = [&quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;]</span><br><span class="line">template = &quot;Here&#x27;s some dynamic value: &#123;value&#125;&quot;</span><br><span class="line"></span><br><span class="line">for value in inputs:</span><br><span class="line">    print(template.format(value=value))</span><br></pre></td></tr></table></figure><p>最重要的是，尽可能使用 f 字符串，因为它们更具可读性和更高性能，但请注意，在某些情况下仍然首选和&#x2F;或需要其他格式样式。</p><p><strong>Tomllib 而不是 tomli</strong><br>TOML 是一种广泛使用的配置格式，对于 Python 的工具和生态系统尤其重要，因为它用于 pyproject.toml 配置文件， 到目前为止，你必须使用外部库来管理 TOML 文件，但是从 Python 3.11 开始，将有一个名为 tomllib 的内置库，它基于 toml 包。</p><p>所以，一旦你切换到 Python 3.11，你应该养成使用 import tomllib 而不是 import tomli 的习惯。少了一种需要担心的依赖！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># import tomli as tomllib</span><br><span class="line">import tomllib</span><br><span class="line"></span><br><span class="line">with open(&quot;pyproject.toml&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    config = tomllib.load(f)</span><br><span class="line">    print(config)</span><br><span class="line">    # &#123;&#x27;project&#x27;: &#123;&#x27;authors&#x27;: [&#123;&#x27;email&#x27;: &#x27;contact@martinheinz.dev&#x27;,</span><br><span class="line">    #                           &#x27;name&#x27;: &#x27;Martin Heinz&#x27;&#125;],</span><br><span class="line">    #              &#x27;dependencies&#x27;: [&#x27;flask&#x27;, &#x27;requests&#x27;],</span><br><span class="line">    #              &#x27;description&#x27;: &#x27;Example Package&#x27;,</span><br><span class="line">    #              &#x27;name&#x27;: &#x27;some-app&#x27;,</span><br><span class="line">    #              &#x27;version&#x27;: &#x27;0.1.0&#x27;&#125;&#125;</span><br><span class="line"></span><br><span class="line">toml_string = &quot;&quot;&quot;</span><br><span class="line">[project]</span><br><span class="line">name = &quot;another-app&quot;</span><br><span class="line">description = &quot;Example Package&quot;</span><br><span class="line">version = &quot;0.1.1&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">config = tomllib.loads(toml_string)</span><br><span class="line">print(config)</span><br><span class="line"># &#123;&#x27;project&#x27;: &#123;&#x27;name&#x27;: &#x27;another-app&#x27;, &#x27;description&#x27;: &#x27;Example Package&#x27;, &#x27;version&#x27;: &#x27;0.1.1&#x27;&#125;&#125;</span><br><span class="line">Setuptools 而不是  distutils</span><br></pre></td></tr></table></figure><p>最后一个更像是弃用通知：</p><p>由于 Distutils 已弃用，因此同样不鼓励使用任何来自 distutils 的函数或对象，Setuptools 旨在替换或弃用所有此类用途。</p><p>是时候告别 distutils 包并切换到 setuptools 了，setuptools 文档提供了有关如何替换 distutils 用法的指导， 除此之外，PEP 632 还为 setuptools 未涵盖的部分 distutils 提供迁移建议。</p><p><strong>总结</strong><br>每个新的 Python 版本都会带来新的特性，因此我建议你查看 Python 发行说明中的“新模块”、“不推荐使用的模块”和“已删除的模块”部分，这是了解 Python 标准重大变化的好方法 ， 通过这种方式，你可以不断地将新功能和最佳实践整合到你的项目中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着每个 Python 版本的发布，都会添加新模块，并引入新的更好的做事方式，虽然我们都习惯了使用好的旧 Python 库和某些做事方式，但现在也时候升级并利用新的和改进的模块及其特性了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://longchao012.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python中常用的 pip 命令</title>
    <link href="https://longchao012.github.io/2022/08/28/Python%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%20pip%20%E5%91%BD%E4%BB%A4/"/>
    <id>https://longchao012.github.io/2022/08/28/Python%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%20pip%20%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-28T02:30:39.000Z</published>
    <updated>2023-09-04T02:54:40.888Z</updated>
    
    <content type="html"><![CDATA[<p>相信对于大多数熟悉Python的人来说，一定都听说并且使用过pip这个工具，但是对它的了解可能还不一定是非常的透彻，今天就来为大家介绍几个使用pip的小技巧，相信对大家以后管理和使用Python当中的标准库会有帮助。</p><span id="more"></span><p><strong><center> 安装 </center></strong><br>当然在Python 3.4版本之后以及Python 2.7.9版本之后，官网的安装包当中就已经自带了pip，用户直接在安装完Python之后就可以直接使用，要是使用由virtualenv或者pyvenv创建的虚拟环境，那么pip也是被默认安装的</p><p>如果是需要自己另外安装pip包的，在已经配置好Python的环境当中运行下面这个命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py -m ensurepip --upgrade </span><br></pre></td></tr></table></figure><p>另外一种方式是从官网上(<a href="https://bootstrap.pypa.io/get-pip.py)%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BDget-pip.py%E8%84%9A%E6%9C%AC%EF%BC%8C%E7%84%B6%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8Cpython">https://bootstrap.pypa.io/get-pip.py)直接下载get-pip.py脚本，然后直接运行python</a> get-pip.py脚本即可</p><p>如何使用<br>安装后，在命令行中输入pip，然后按下回车，就会出现下图所示的使用说明：</p><p><img src="/images/pip1.png" alt="pip1"><br>升级<br>要是你觉得自己的pip版本有点低，想要升级一下的话，在命令行中输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pip</span><br></pre></td></tr></table></figure><p>安装某个版本的包<br>如果打算用pip来安装第三方的包，用的是以下的命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package-name</span><br></pre></td></tr></table></figure><p>例如我们想要安装指定版本的第三方的包，例如安装3.4.1版本的matplotlib，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib==3.4.1</span><br></pre></td></tr></table></figure><p>卸载或者是更新包<br>要是你打算想要卸载某个包，该要输入的命令行是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall package_name</span><br></pre></td></tr></table></figure><p>而如果打算更新某个包，对应的命令行是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade package_name</span><br></pre></td></tr></table></figure><p># 或者是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U package_name</span><br></pre></td></tr></table></figure><p>查看某个包的信息<br>可以通过以下的这个命令行来查看指定包的信息，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show -f requests</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Name: requests</span><br><span class="line">Version: 2.24.0</span><br><span class="line">Summary: Python HTTP for Humans.</span><br><span class="line">Home-page: https://requests.readthedocs.io</span><br><span class="line">Author: Kenneth Reitz</span><br><span class="line">Author-email: me@kennethreitz.org</span><br><span class="line">License: Apache 2.0</span><br><span class="line">Location: c:\users\pc120\pycharmprojects\pythonproject1\venv\lib\site-packages</span><br><span class="line">Requires: certifi, chardet, idna, urllib3</span><br><span class="line">Required-by: etelemetry, gTTS, pandas-datareader, pandas-profiling, pyler, pywhatkit, pyxnat, streamlit, tushare, wikipedia, yfinance</span><br><span class="line">Files:</span><br><span class="line">  requests-2.24.0.dist-info\DESCRIPTION.rst</span><br><span class="line">  requests-2.24.0.dist-info\INSTALLER</span><br><span class="line">  .......</span><br></pre></td></tr></table></figure><p>查看需要被升级的包<br>我们需要查看一下现有的这些包中，哪些是需要是被升级的，可以用下面这行命令行来查看，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list -o</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Package    Version Latest Type</span><br><span class="line">---------- ------- ------ -----</span><br><span class="line">docutils   0.15.2  0.18.1 wheel</span><br><span class="line">PyYAML     5.4.1   6.0    wheel</span><br><span class="line">rsa        4.7.2   4.8    wheel</span><br><span class="line">setuptools 56.0.0  62.1.0 wheel</span><br></pre></td></tr></table></figure><p>查看兼容问题<br>在下载安装一些标准库的时候，需要考虑到兼容问题，一些标准库的安装可能需要依赖其他的标准库，会存在版本相冲突等问题，我们先用下面这条命令行来检查一下是否会有冲突的问题存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip check package_name</span><br></pre></td></tr></table></figure><p>当然要是我们不指定是哪个标准库的话，会检查现在已经安装的所有包中的是否存在版本冲突等问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip check</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yfinance 0.1.70 has requirement requests&gt;=2.26, but you have requests 2.24.0.</span><br><span class="line">selenium 4.1.0 has requirement urllib3[secure]~=1.26, but you have urllib3 1.25.11.</span><br></pre></td></tr></table></figure><p>指定国内源来安装<br>我们要是感觉到安装的速度有点慢，可以指定国内的源来安装某个包，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.douban.com/simple/ package_name</span><br></pre></td></tr></table></figure><p>国内源有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">华中理工大学：http://pypi.hustunique.com/</span><br><span class="line">山东理工大学：http://pypi.sdutlinux.org/ </span><br><span class="line">豆瓣：http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure><p>下载包但是不安装<br>要是我们想要下载某个包到指定的路径下，命令行如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip download package_name -d &quot;某个路径&quot;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip download requests -d &quot;.&quot;</span><br></pre></td></tr></table></figure><p>就是在当前的目录下下载requests模块以及其他所要依赖的模块</p><p>批量安装软件包<br>我们一般在看到别人的项目时，都会包含一个requirements.txt文件，里面包含了一些Python项目当中需要用到的第三方库</p><p><img src="/images/pip2.png" alt="pip2"><br>要生成这种txt文件，需要这么来做</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p>而如果我们需要来批量安装第三方库，在命令行中输入以下这个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;相信对于大多数熟悉Python的人来说，一定都听说并且使用过pip这个工具，但是对它的了解可能还不一定是非常的透彻，今天就来为大家介绍几个使用pip的小技巧，相信对大家以后管理和使用Python当中的标准库会有帮助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://longchao012.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>几种好用的数据迁移工具</title>
    <link href="https://longchao012.github.io/2022/08/26/%E5%87%A0%E7%A7%8D%E5%A5%BD%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%B7%A5%E5%85%B7/"/>
    <id>https://longchao012.github.io/2022/08/26/%E5%87%A0%E7%A7%8D%E5%A5%BD%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%B7%A5%E5%85%B7/</id>
    <published>2022-08-26T01:15:01.000Z</published>
    <updated>2023-09-04T02:30:55.914Z</updated>
    
    <content type="html"><![CDATA[<p>市面上有那么多的ETL数据迁移工具，我们可以用哪些？</p><p>ETL(是Extract-Transform-Load的缩写，即数据抽取、转换、装载的过程)，对于企业应用来说，我们经常会遇到各种数据的处理、转换、迁移的场景。</p><p>今天特地给大家汇总了一些目前市面上比较常用的ETL数据迁移工具，希望对大家有所帮助。</p><span id="more"></span><h2 id="1-Kettle"><a href="#1-Kettle" class="headerlink" title="1.Kettle"></a>1.Kettle</h2><p><strong>Kettle</strong>是一款国外开源的<strong>ETL</strong>工具，纯<strong>Java</strong>编写，绿色无需安装，数据抽取高效稳定(数据迁移工具)。</p><p>Kettle 中有两种脚本文件，transformation 和 job，transformation 完成针对数据的基础转换，job 则完成整个工作流的控制。</p><p>Kettle 中文名称叫水壶，该项目的主程序员 MATT 希望把各种数据放到一个壶里，然后以一种指定的格式流出。<br><img src="/images/ETL1.png" alt="ETL1"></p><p>Kettle 这个 ETL 工具集，它允许你管理来自不同数据库的数据，通过提供一个图形化的用户环境来描述你想做什么，而不是你想怎么做。</p><p><img src="/images/ETL2.png" alt="ETL2"></p><ul><li><p>Kettle 家族目前包括 4 个产品：Spoon、Pan、CHEF、Kitchen。</p><ul><li>SPOON：允许你通过图形界面来设计 ETL 转换过程（Transformation）。</li><li>PAN：允许你批量运行由 Spoon 设计的 ETL 转换 (例如使用一个时间调度器)。Pan 是一个后台执行的程序，没有图形界面。</li><li>CHEF：允许你创建任务（Job）。任务通过允许每个转换，任务，脚本等等，更有利于自动化更新数据仓库的复杂工作。任务通过允许每个转换，任务，脚本等等。任务将会被检查，看看是否正确地运行了。</li><li>KITCHEN：允许你批量使用由 Chef 设计的任务 (例如使用一个时间调度器)。KITCHEN 也是一个后台运行的程序。</li></ul></li></ul><h2 id="2-Datax"><a href="#2-Datax" class="headerlink" title="2.Datax"></a>2.Datax</h2><p><strong>DataX</strong>是阿里云 DataWorks数据集成的开源版本，在阿里巴巴集团内被广泛使用的离线数据同步工具&#x2F;平台。</p><p>DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能。</p><p><img src="/images/ETL3.png" alt="ETL3"><br>设计理念：为了解决异构数据源同步问题，DataX将复杂的网状的同步链路变成了星型数据链路，DataX作为中间传输载体负责连接各种数据源。当需要接入一个新的数据源的时候，只需要将此数据源对接到DataX，便能跟已有的数据源做到无缝数据同步。</p><p>当前使用现状：DataX在阿里巴巴集团内被广泛使用，承担了所有大数据的离线同步业务，并已持续稳定运行了6年之久。目前每天完成同步8w多道作业，每日传输数据量超过300TB。</p><p>DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader&#x2F;Writer插件，纳入到整个同步框架中。</p><p><img src="/images/ETL4.png" alt="ETL4"><br>DataX 3.0 开源版本支持单机多线程模式完成同步作业运行，本小节按一个DataX作业生命周期的时序图，从整体架构设计非常简要说明DataX各个模块相互关系。<br><img src="/images/ETL5.png" alt="ETL5"></p><ul><li>DataX 3.0六大核心优势：<ul><li>可靠的数据质量监控</li><li>丰富的数据转换功能</li><li>精准的速度控制</li><li>强劲的同步性能</li><li>健壮的容错机制</li><li>极简的使用体验</li></ul></li></ul><h2 id="3-DataPipeline"><a href="#3-DataPipeline" class="headerlink" title="3.DataPipeline"></a>3.DataPipeline</h2><p><strong>DataPipeline</strong>采用基于日志的增量数据获取技术（Log-based Change Data Capture），支持异构数据之间丰富、自动化、准确的语义映射构建，同时满足实时与批量的数据处理。</p><p>可实现 Oracle、IBM DB2、MySQL、MS SQL Server、PostgreSQL、GoldenDB、TDSQL、OceanBase 等数据库准确的增量数据获取。</p><p>平台具备“数据全、传输快、强协同、更敏捷、极稳定、易维护”六大特性。</p><p>在支持传统关系型数据库的基础上，对大数据平台、国产数据库、云原生数据库、API 及对象存储也提供广泛的支持，并在不断扩展。</p><p>DataPipeline 数据融合产品致力于为用户提供企业级数据融合解决方案，为用户提供统一平台同时管理异构数据节点实时同步与批量数据处理任务，在未来还将提供对实时流计算的支持。</p><p>采用分布式集群化部署方式，可水平垂直线性扩展的，保证数据流转稳定高效，让客户专注数据价值释放。</p><p><img src="/images/ETL6.png" alt="ETL6"></p><ul><li><p><strong>产品特点：</strong></p><ul><li><strong>全面的数据节点支持</strong>：支持关系型数据库、NoSQL数据库、国产数据库、数据仓库、大数据平台、云存储、API等多种数据节点类型，可自定义数据节点。</li><li><strong>高性能实时处理</strong>：针对不同数据节点类型提供TB级吞吐量、秒级低延迟的增量数据处理能力，加速企业各类场景的数据流转。</li><li><strong>分层管理降本增效</strong>：采用“数据节点注册、数据链路配置、数据任务构建、系统资源分配”的分层管理模式，企业级平台的建设周期从三到六个月减少为一周。</li><li><strong>无代码敏捷管理</strong>：提供限制配置与策略配置两大类十余种高级配置，包括灵活的数据对象映射关系，数据融合任务的研发交付时间从2周减少为5分钟。</li><li><strong>极稳定高可靠</strong>：采用分布式架构，所有组件均支持高可用，提供丰富容错策略，应对上下游的结构变化、数据错误、网络故障等突发情况，可以保证系统业务连续性要求。</li><li><strong>全链路数据可观测</strong>：配备容器、应用、线程、业务四级监控体系，全景驾驶舱守护任务稳定运行。自动化运维体系，灵活扩缩容，合理管理和分配系统资源。</li></ul></li></ul><h2 id="4-Talend"><a href="#4-Talend" class="headerlink" title="4.Talend"></a>4.Talend</h2><p>Talend (踏蓝) 是第一家针对的数据集成工具市场的 ETL (数据的提取 Extract、传输 Transform、载入 Load) 开源软件供应商。</p><p><img src="/images/ETL7.png" alt="ETL7"><br>Talend 以它的技术和商业双重模式为 ETL 服务提供了一个全新的远景。它打破了传统的独有封闭服务，提供了一个针对所有规模的公司的公开的，创新的，强大的灵活的软件解决方案。</p><h2 id="5-DataStage"><a href="#5-DataStage" class="headerlink" title="5.DataStage"></a>5.DataStage</h2><p>DataStage，即IBM WebSphere DataStage，是一套专门对多种操作数据源的数据抽取、转换和维护过程进行简化和自动化，并将其输入数据集市或数据仓库目标数据库的集成工具，可以从多个不同的业务系统中，从多个平台的数据源中抽取数据，完成转换和清洗，装载到各种系统里面。</p><p>其中每步都可以在图形化工具里完成，同样可以灵活地被外部系统调度，提供专门的设计工具来设计转换规则和清洗规则等，实现了增量抽取、任务调度等多种复杂而实用的功能。其中简单的数据转换可以通过在界面上拖拉操作和调用一些 DataStage 预定义转换函数来实现，复杂转换可以通过编写脚本或结合其他语言的扩展来实现，并且 DataStage 提供调试环境，可以极大提高开发和调试抽取、转换程序的效率。</p><ul><li><p><strong>Datastage 操作界面</strong><br><img src="/images/ETL8.png" alt="ETL8"></p><ul><li>对元数据的支持：Datastage 是自己管理 Metadata，不依赖任何数据库。</li><li>参数控制：Datastage 可以对每个 job 设定参数，并且可以 job 内部引用这个参数名。</li><li>数据质量：Datastage 有配套用的 ProfileStage 和 QualityStage 保证数据质量。</li><li>定制开发：提供抽取、转换插件的定制，Datastage 内嵌一种类 BASIC 语言，可以写一段批处理程序来增加灵活性。</li><li>修改维护：提供图形化界面。这样的好处是直观、傻瓜式的；不好的地方就是改动还是比较费事（特别是批量化的修改）。</li></ul></li><li><p>Datastage 包含四大部件：</p><ul><li>Administrator：新建或者删除项目，设置项目的公共属性，比如权限。</li><li>Designer：连接到指定的项目上进行 Job 的设计；</li><li>Director：负责 Job 的运行，监控等。例如设置设计好的 Job 的调度时间。</li><li>Manager：进行 Job 的备份等 Job 的管理工作。</li></ul></li></ul><h2 id="6-Sqoop"><a href="#6-Sqoop" class="headerlink" title="6.Sqoop"></a>6.Sqoop</h2><p>Sqoop 是 Cloudera 公司创造的一个数据同步工具，现在已经完全开源了。</p><p>目前已经是 hadoop 生态环境中数据迁移的首选 Sqoop 是一个用来将 Hadoop 和关系型数据库中的数据相互转移的工具，可以将一个关系型数据库（例如 ：MySQL ,Oracle ,Postgres 等）中的数据导入到 Hadoop 的 HDFS 中，也可以将 HDFS 的数据导入到关系型数据库中。</p><p><img src="/images/ETL9.png" alt="ETL9"><br>他将我们传统的关系型数据库 | 文件型数据库 | 企业数据仓库 同步到我们的 hadoop 生态集群中。</p><p>同时也可以将 hadoop 生态集群中的数据导回到传统的关系型数据库 | 文件型数据库 | 企业数据仓库中。</p><p>那么 Sqoop 如何抽取数据呢?<br><img src="/images/ETL10.png" alt="ETL10"></p><p>1.首先 Sqoop 去 rdbms 抽取元数据。<br>2.当拿到元数据之后将任务切成多个任务分给多个 map。<br>3.然后再由每个 map 将自己的任务完成之后输出到文件。</p><h2 id="7-FineDataLink"><a href="#7-FineDataLink" class="headerlink" title="7.FineDataLink"></a>7.FineDataLink</h2><p>FineDataLink是国内做的比较好的ETL工具，FineDataLink是一站式的数据处理平台，具备高效的数据同步功能，可以实现实时数据传输、数据调度、数据治理等各类复杂组合场景的能力，提供数据汇聚、研发、治理等功能。</p><p>FDL拥有低代码优势，通过简单的拖拽交互就能实现ETL全流程。<br><img src="/images/ETL11.png" alt="ETL11"><br>FineDataLink——中国领先的低代码&#x2F;高时效数据集成产品，能过为企业提供一站式的数据服务，通过快速连接、高时效融合多种数据，提供低代码Data API敏捷发布平台，帮助企业解决数据孤岛难题，有效提升企业数据价值。</p><h2 id="8-canal"><a href="#8-canal" class="headerlink" title="8.canal"></a>8.canal</h2><p>canal [kə’næl]，译意为水道&#x2F;管道&#x2F;沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。<br><img src="/images/ETL12.png" alt="ETL12"><br>早期阿里巴巴因为杭州和美国双机房部署，存在跨机房同步的业务需求，实现方式主要是基于业务 trigger 获取增量变更。从 2010 年开始，业务逐步尝试数据库日志解析获取增量变更进行同步，由此衍生出了大量的数据库增量订阅和消费业务。</p><ul><li><p><strong>基于日志增量订阅和消费的业务包括：</strong></p><ul><li>数据库镜像</li><li>数据库实时备份</li><li>索引构建和实时维护(拆分异构索引、倒排索引等)</li><li>业务 cache 刷新</li><li>带业务逻辑的增量数据处理</li></ul></li><li><p><strong>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x。</strong></p></li></ul><p><img src="/images/ETL13.png" alt="ETL13"><br>    + MySQL master 将数据变更写入二进制日志( binary log, 其中记录叫做二进制日志事件binary log events，可以通过 show binlog events 进行查看)。<br>    + MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)。<br>    + MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据。</p><ul><li><p><strong>canal 工作原理：</strong></p><ul><li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</li><li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</li><li>canal 解析 binary log 对象(原始为 byte 流)</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;市面上有那么多的ETL数据迁移工具，我们可以用哪些？&lt;/p&gt;
&lt;p&gt;ETL(是Extract-Transform-Load的缩写，即数据抽取、转换、装载的过程)，对于企业应用来说，我们经常会遇到各种数据的处理、转换、迁移的场景。&lt;/p&gt;
&lt;p&gt;今天特地给大家汇总了一些目前市面上比较常用的ETL数据迁移工具，希望对大家有所帮助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据迁移工具" scheme="https://longchao012.github.io/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>小案例：制作《数据流图》与《业务流程图》</title>
    <link href="https://longchao012.github.io/2022/08/24/%E5%B0%8F%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%B6%E4%BD%9C%E3%80%8A%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E3%80%8B%E4%B8%8E%E3%80%8A%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%8B/"/>
    <id>https://longchao012.github.io/2022/08/24/%E5%B0%8F%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%B6%E4%BD%9C%E3%80%8A%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E3%80%8B%E4%B8%8E%E3%80%8A%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%8B/</id>
    <published>2022-08-24T03:53:12.000Z</published>
    <updated>2023-08-24T03:54:36.897Z</updated>
    
    <content type="html"><![CDATA[<p>数据流图（Data Flow Diagram, DFD）是一种便于用户理解和分析系统数据流程的图形工具，他摆脱了系统和具体内容，精确的在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。</p><span id="more"></span><h2 id="一、数据流图组成部分"><a href="#一、数据流图组成部分" class="headerlink" title="一、数据流图组成部分"></a>一、数据流图组成部分</h2><p><strong>数据流：</strong>是由一组固定成分的数据组成，表示数据的流向，除了流向数据存储或从数据存储流出的数据不必命名外，每个数据流必须要有一个合适的名字，以反映该数据流的含义</p><p><strong>加工：</strong>加工描述了输入数据流到输出数据之间的变换，也就是输入数据流经过什么处理后变成了输出数据</p><p><strong>数据存储：</strong>数据存储表示暂时存储的数据,每个数据存储都有一个名字</p><p><strong>外部实体：</strong>外部实体是存在于软件系统之外的人员或组织</p><h2 id="二、基本图形符号（重点）"><a href="#二、基本图形符号（重点）" class="headerlink" title="二、基本图形符号（重点）"></a>二、基本图形符号（重点）</h2><p>方框：表示数据的源点或终点</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE1.png" alt="数据流图1"><br>圆或椭圆：表示加工</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE2.png" alt="数据流图2"><br>箭头：表示数据流</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE3.png" alt="数据流图3"><br>双杠：表示数据存储</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE4.png" alt="数据流图4"></p><h2 id="三、实战案列"><a href="#三、实战案列" class="headerlink" title="三、实战案列"></a>三、实战案列</h2><p>题目：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE5.png" alt="数据流图5"><br>大家可以看见这个是一个机票预订系统「：黑色的字体都是关键字」，现在让我们试试画出这个数据流图。</p><p><em>航空公司 会根据 航班信息来 安排航班</em></p><p>可以看的出航空公司是一个实体，航班信息是种数据，安排航班是处理这个数据，所以我们得到以下的图。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE6.png" alt="数据流图6"></p><p><em>并将航班信息存储在订票信息中</em></p><p>上面的话可以看见将航班信息存储在订票信息中，得到下图：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE7.png" alt="数据流图7"></p><p><em>旅客订票时，旅客将旅客信息输入该系统</em></p><p>上面的话可以看出有操作了，实体是旅客，操作数据是订票行为，将信息输入该系统（订票）下图：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE8.png" alt="数据流图8"></p><p><em>系统通过旅客信息，在订票信息中查询合适的航班，并返回机票信息</em></p><p>通过上面的看见发现是系统查询并返回系统（注意：订票信息只是把名字放上面去了，没有更改图）</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE9.png" alt="数据流图9"></p><p><em>然后系统根据机票信息，打印机票</em></p><p>上面又有操作，根据机票信息这个数据流来打印机票（操作数据）得下图：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE10.png" alt="数据流图10"></p><p><em>最后将机票信息返回给旅客</em></p><p>这步就是结束了：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE11.png" alt="数据流图11"><br>好了以上就是数据流图的一个小实战，其实画图简单，只要搞清楚了实体的关系联系，基本上都是换汤不换药，轻轻松松~~~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据流图（Data Flow Diagram, DFD）是一种便于用户理解和分析系统数据流程的图形工具，他摆脱了系统和具体内容，精确的在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UML" scheme="https://longchao012.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>基于UiBot的滑动验证码检测实例</title>
    <link href="https://longchao012.github.io/2022/08/23/%E5%9F%BA%E4%BA%8EUiBot%E7%9A%84%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A3%80%E6%B5%8B%E5%AE%9E%E4%BE%8B/"/>
    <id>https://longchao012.github.io/2022/08/23/%E5%9F%BA%E4%BA%8EUiBot%E7%9A%84%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A3%80%E6%B5%8B%E5%AE%9E%E4%BE%8B/</id>
    <published>2022-08-23T09:59:20.000Z</published>
    <updated>2023-08-23T10:14:25.837Z</updated>
    
    <content type="html"><![CDATA[<p>我们在做一些自动化登录的过程中，经常会遇到各种各样的图灵检测。<br><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%811.png" alt="滑块验证1"><br>因为验证码样式多变，而且需要较多命令组合才能完成验证，所以UiBot暂时没有将验证码做为一个命令组件进行预制。难到这样就没办法了吗？</p><span id="more"></span><p>难到这样就没办法了吗？显然不是，我们可以利用RPA连接外部的特性，使用部分coding来解决此问题（使用coding也算一种连接嘛）</p><p>回到上例，一般来说这样的验证码验证有如下流程，我们把他拆分一下可得：</p><p>1、展示完整原图，说明验证方式</p><p>2、鼠标按住滑块，展现出缺陷图</p><p>3、滑动滑块到缺陷部分</p><p>其中，1、2两部我们用眼睛识别，用来测算距离，第3步用鼠标移动用来填补距离，基于这个逻辑，我们同样把整个验证的实现拆分成2个大步，那么第一步是算滑动距离，第二步就是根据滑动距离进行滑动了，下面我们根据实例来一步步进行分解实现。</p><p>实例地址：<a href="https://www.chinapay.com/index.jsp%EF%BC%88%E9%93%B6%E8%81%94%E7%9A%84%E7%99%BB%E5%BD%95%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E9%9A%8F%E4%BE%BF%E8%BE%93%E5%85%A5%E5%8F%AF%E8%A7%A6%E5%8F%91%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%EF%BC%89">https://www.chinapay.com/index.jsp（银联的登录地址，用户名密码随便输入可触发滑动验证）</a></p><p>要得到完整距离，首先我们要得到无缺口图和有缺口图2张图片，其中有缺口的图片需要将鼠标移到滑块上并按住才会出现，当然这也很好解决，我们可以直接使用UiBot获取这两张图，获取的方式如下：</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%812.png" alt="滑块验证2"></p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;1.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br><span class="line">Mouse.Hover(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;isleaf&quot;:&quot;1&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:3&#125;&#125;,10000,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:0,&quot;iDelayBefore&quot;:0,&quot;bSetForeground&quot;:true,&quot;sCursorPosition&quot;:&quot;Center&quot;,&quot;iCursorOffsetX&quot;:0,&quot;iCursorOffsetY&quot;:0,&quot;sKeyModifiers&quot;:[],&quot;sSimulate&quot;:&quot;simulate&quot;&#125;)</span><br><span class="line">Mouse.Click(&quot;left&quot;, &quot;down&quot;, [])</span><br><span class="line">Delay(600)</span><br><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;2.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%813.png" alt="滑块验证3"></p><p>得到两张图后我们需要测算滑动距离，如何测算呢？我们可以比对上图，发现除了缺口以外其他部分基本和原图一致（有部分干扰块，但是问题不大，因为色深不够而且水平距离不一致，我们可以通过后面的算法把他滤过），所以实际上我们只需要抓住起始点和缺陷部分的特征既可算出两者直接的距离，这里我们可以通过python进行图像处理实现，具体实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image  </span><br><span class="line">import PIL.ImageChops as imagechops</span><br><span class="line">from PIL import Image, ImageDraw,ImageFont</span><br><span class="line">import random</span><br><span class="line">def CalcDistance(srcImg,distImg):</span><br><span class="line">    im1 = Image.open(srcImg)</span><br><span class="line">    im2 = Image.open(distImg)</span><br><span class="line">    #得出两图不一致的地方</span><br><span class="line">    diff=imagechops.difference(im1, im2)</span><br><span class="line">    draw =ImageDraw.Draw(diff)</span><br><span class="line">    #通过颜色处理清除干扰块</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor[0]&gt;=100 or pixelColor[1]&gt;=100 or pixelColor[2]&gt;=100:</span><br><span class="line">                draw.line((x, y, x, y),(255,255,255,255))</span><br><span class="line">            else:</span><br><span class="line">                draw.line((x, y, x, y),(0,0,0,0))</span><br><span class="line">    # #清理完可以show一下，查看清理完之后的黑白化效果</span><br><span class="line">    # diff.show()</span><br><span class="line">    #找第一个块中的参照点</span><br><span class="line">    firsetPoint=[0,0]</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                firsetPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if firsetPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # 往后跳50找第二个块中的参照点，50是矩形宽度</span><br><span class="line">    secondPoint=[0,0]</span><br><span class="line">    for x in range(firsetPoint[0]+50,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                secondPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if secondPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # #画两条线看看位置是否标注正确，仅用于调试</span><br><span class="line">    # draw.line((firsetPoint[0], firsetPoint[1], firsetPoint[0]+20, firsetPoint[1]),(6,255,9,0))</span><br><span class="line">    # draw.line((secondPoint[0], secondPoint[1], secondPoint[0]+20, secondPoint[1]),(9,8,255,0))</span><br><span class="line">    # diff.show()</span><br><span class="line">    diffPixel=secondPoint[0]-firsetPoint[0]</span><br><span class="line">    print(diffPixel)</span><br></pre></td></tr></table></figure><p>经过上述处理后，前文的图会被处理为下图的样子，并算出两块直接的一个距离</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%814.png" alt="滑块验证4"></p><p>得到距离，接下来我们需要驱动鼠标进行滑动，这些在UiBot里面都有相应的命令可以直接使用，在第一次处理这个验证码时，我天真的以为到算出距离就已经结束，没想到实际上滑动验证码的难点恰恰是滑动轨迹的模拟。滑动验证码在滑动轨迹上同样加入了人机测验，就算本例的解决方式也只有60%的成功率(两块相隔距离较长的情况下成功率更高)。话不多说，下面直接放轨迹的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def GetStacks(distance):</span><br><span class="line">    distance += 20</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    匀加速\减速运行</span><br><span class="line">        v = v0 + a * t</span><br><span class="line">    位移:</span><br><span class="line">    s = v * t + 0.5 * a * (t**2)</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 初速度</span><br><span class="line">    v0 = 0</span><br><span class="line">    # 加减速度列表</span><br><span class="line">    a_list = [3, 4, 5]</span><br><span class="line">    # 时间</span><br><span class="line">    t = 0.2</span><br><span class="line">    # 初始位置</span><br><span class="line">    s = 0</span><br><span class="line">    # 向前滑动轨迹</span><br><span class="line">    forward_stacks = []</span><br><span class="line">    mid = distance * 3 / 5</span><br><span class="line">    while s &lt; distance:</span><br><span class="line">        if s &lt; mid:</span><br><span class="line">            a = a_list[random.randint(0, 2)]</span><br><span class="line">        else:</span><br><span class="line">            a = -a_list[random.randint(0, 2)]</span><br><span class="line">        v = v0</span><br><span class="line">        stack = v * t + 0.5 * a * (t ** 2)</span><br><span class="line">        # 每次拿到的位移</span><br><span class="line">        stack = round(stack)</span><br><span class="line">        s += stack</span><br><span class="line">        v0 = v + a * t</span><br><span class="line">        forward_stacks.append(stack)</span><br><span class="line">    back_stacks = [-1, -1, -2, -3, -2, -3, -2, -2, -3, -1]</span><br><span class="line">    return &#123;&#x27;forward_stacks&#x27;: forward_stacks, &#x27;back_stacks&#x27;: back_stacks</span><br></pre></td></tr></table></figure><p>上述轨迹实现，逻辑是模拟人以加速度的形式进行增速滑动，为了骗过人机检测，特意还有个回滑的操作，而后将轨迹以相对位移数组的形式进行返回，结合我们之前距离的测算，可以得到一个完整的python文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image  </span><br><span class="line">import PIL.ImageChops as imagechops</span><br><span class="line">from PIL import Image, ImageDraw,ImageFont</span><br><span class="line">import random</span><br><span class="line">def CalcDistance(srcImg,distImg):</span><br><span class="line">    im1 = Image.open(srcImg)</span><br><span class="line">    im2 = Image.open(distImg)</span><br><span class="line">    #得出两图不一致的地方</span><br><span class="line">    diff=imagechops.difference(im1, im2)</span><br><span class="line">    draw =ImageDraw.Draw(diff)</span><br><span class="line">    #通过颜色处理清除干扰块</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor[0]&gt;=100 or pixelColor[1]&gt;=100 or pixelColor[2]&gt;=100:</span><br><span class="line">                draw.line((x, y, x, y),(255,255,255,255))</span><br><span class="line">            else:</span><br><span class="line">                draw.line((x, y, x, y),(0,0,0,0))</span><br><span class="line">    # #清理完可以show一下，查看清理完之后的黑白化效果</span><br><span class="line">    # diff.show()</span><br><span class="line">    #找第一个块中的参照点</span><br><span class="line">    firsetPoint=[0,0]</span><br><span class="line">    for x in range(0,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                firsetPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if firsetPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # 往后跳50找第二个块中的参照点，50是矩形宽度</span><br><span class="line">    secondPoint=[0,0]</span><br><span class="line">    for x in range(firsetPoint[0]+50,260):</span><br><span class="line">        for y in range(0,116):</span><br><span class="line">            pixelColor=diff.getpixel((x,y))</span><br><span class="line">            if pixelColor!=(0,0,0,0):</span><br><span class="line">                secondPoint=[x,y]</span><br><span class="line">                break</span><br><span class="line">        if secondPoint!=[0,0]:</span><br><span class="line">            break</span><br><span class="line">    # #画两条线看看位置是否标注正确，仅用于调试</span><br><span class="line">    # draw.line((firsetPoint[0], firsetPoint[1], firsetPoint[0]+20, firsetPoint[1]),(6,255,9,0))</span><br><span class="line">    # draw.line((secondPoint[0], secondPoint[1], secondPoint[0]+20, secondPoint[1]),(9,8,255,0))</span><br><span class="line">    # diff.show()</span><br><span class="line">    diffPixel=secondPoint[0]-firsetPoint[0]</span><br><span class="line">    return GetStacks(diffPixel)</span><br><span class="line">    </span><br><span class="line">def GetStacks(distance):</span><br><span class="line">    distance += 20</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    匀加速\减速运行</span><br><span class="line">        v = v0 + a * t</span><br><span class="line">    位移:</span><br><span class="line">    s = v * t + 0.5 * a * (t**2)</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 初速度</span><br><span class="line">    v0 = 0</span><br><span class="line">    # 加减速度列表</span><br><span class="line">    a_list = [3, 4, 5]</span><br><span class="line">    # 时间</span><br><span class="line">    t = 0.2</span><br><span class="line">    # 初始位置</span><br><span class="line">    s = 0</span><br><span class="line">    # 向前滑动轨迹</span><br><span class="line">    forward_stacks = []</span><br><span class="line">    mid = distance * 3 / 5</span><br><span class="line">    while s &lt; distance:</span><br><span class="line">        if s &lt; mid:</span><br><span class="line">            a = a_list[random.randint(0, 2)]</span><br><span class="line">        else:</span><br><span class="line">            a = -a_list[random.randint(0, 2)]</span><br><span class="line">        v = v0</span><br><span class="line">        stack = v * t + 0.5 * a * (t ** 2)</span><br><span class="line">        # 每次拿到的位移</span><br><span class="line">        stack = round(stack)</span><br><span class="line">        s += stack</span><br><span class="line">        v0 = v + a * t</span><br><span class="line">        forward_stacks.append(stack)</span><br><span class="line">    back_stacks = [-1, -1, -2, -3, -2, -3, -2, -2, -3, -1]</span><br><span class="line">    return &#123;&#x27;forward_stacks&#x27;: forward_stacks, &#x27;back_stacks&#x27;: back_stacks&#125;</span><br></pre></td></tr></table></figure><p>现在剩下的工作是将这个文件给UiBot进行使用。我们将上面的文件保存成CrackGEE.py，放到UiBot Creator的安装目录下的 extend\python下面（可参考：<a href="https://forum.uibot.com.cn/thread-51.htm%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8UiBot%E9%87%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%9A">https://forum.uibot.com.cn/thread-51.htm），然后在UiBot里面添加如下代码：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Import CrackGEE</span><br><span class="line">#icon(&quot;@res:dp3vobi1-353k-q9mp-q5oh-nicth66fv4ag.png&quot;)</span><br><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;1.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br><span class="line">#icon(&quot;@res:sod4iqf0-l79e-a7hu-n4rm-hom2l8pgvv4k.png&quot;)</span><br><span class="line">Mouse.Hover(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;isleaf&quot;:&quot;1&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:3&#125;&#125;,10000,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:0,&quot;iDelayBefore&quot;:0,&quot;bSetForeground&quot;:true,&quot;sCursorPosition&quot;:&quot;Center&quot;,&quot;iCursorOffsetX&quot;:0,&quot;iCursorOffsetY&quot;:0,&quot;sKeyModifiers&quot;:[],&quot;sSimulate&quot;:&quot;simulate&quot;&#125;)</span><br><span class="line">Mouse.Click(&quot;left&quot;, &quot;down&quot;, [])</span><br><span class="line">Delay(600)</span><br><span class="line">#icon(&quot;@res:dp3vobi1-353k-q9mp-q5oh-nicth66fv4ag.png&quot;)</span><br><span class="line">UiElement.ScreenShot(&#123;&quot;wnd&quot;:[&#123;&quot;cls&quot;:&quot;Chrome_WidgetWin_1&quot;,&quot;title&quot;:&quot;*&quot;,&quot;app&quot;:&quot;chrome&quot;&#125;,&#123;&quot;cls&quot;:&quot;Chrome_RenderWidgetHostHWND&quot;,&quot;title&quot;:&quot;Chrome Legacy Window&quot;&#125;],&quot;html&quot;:&#123;&quot;tagName&quot;:&quot;DIV&quot;,&quot;attrMap&quot;:&#123;&quot;tag&quot;:&quot;DIV&quot;,&quot;aaname&quot;:&quot;加载中...&quot;,&quot;css-selector&quot;:&quot;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;div&quot;&#125;,&quot;index&quot;:0&#125;&#125;,&quot;2.png&quot;,&quot;content&quot;,&#123;&quot;bContinueOnError&quot;:false,&quot;iDelayAfter&quot;:300,&quot;iDelayBefore&quot;:200&#125;)</span><br><span class="line">dim 点列表=[]</span><br><span class="line">点列表=CrackGEE.CalcDistance(&quot;1.png&quot;,&quot;2.png&quot;)</span><br><span class="line">TracePrint(点列表)</span><br><span class="line">Dim 正向移动=点列表[&quot;forward_stacks&quot;]</span><br><span class="line">Dim 回移=点列表[&quot;back_stacks&quot;]</span><br><span class="line">For Each value In 正向移动</span><br><span class="line"> Mouse.Move(value, 0, true)</span><br><span class="line">Delay(12)</span><br><span class="line">Next</span><br><span class="line">For Each value In 回移</span><br><span class="line"> Mouse.Move(value, 0, true)</span><br><span class="line">Delay(34)</span><br><span class="line">Next</span><br><span class="line">Delay(200)</span><br><span class="line">Mouse.Click(&quot;left&quot;, &quot;up&quot;, [])</span><br></pre></td></tr></table></figure><p>视图:</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%815.png" alt="滑块验证5"></p><p>在使用chrome打开银联网站,随便输入用户名密码，呼出验证，停留在如下图所示地方：</p><p><img src="/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%816.png" alt="滑块验证6"></p><p>点击UiBot Creator的运行，即可看到效果。<br><video src="/images/滑块验证7.mp4" controls="controls">您的浏览器不支持播放该视频！</video></p><p>本例权当抛砖引玉，实际上在短距离的比对计算还有滑动轨迹上面还有不小的提升空间，有兴趣的大神可以进一步进行扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在做一些自动化登录的过程中，经常会遇到各种各样的图灵检测。&lt;br&gt;&lt;img src=&quot;/images/%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%811.png&quot; alt=&quot;滑块验证1&quot;&gt;&lt;br&gt;因为验证码样式多变，而且需要较多命令组合才能完成验证，所以UiBot暂时没有将验证码做为一个命令组件进行预制。难到这样就没办法了吗？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA" scheme="https://longchao012.github.io/tags/RPA/"/>
    
  </entry>
  
  <entry>
    <title>基于Java的单表100万数据，写入、更新、读取、删除速度的测试验证！</title>
    <link href="https://longchao012.github.io/2022/08/21/%E5%8D%95%E8%A1%A8100%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%86%99%E5%85%A5%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E8%AF%BB%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E9%80%9F%E5%BA%A6%E7%9A%84%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%EF%BC%81/"/>
    <id>https://longchao012.github.io/2022/08/21/%E5%8D%95%E8%A1%A8100%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%86%99%E5%85%A5%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E8%AF%BB%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E9%80%9F%E5%BA%A6%E7%9A%84%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%EF%BC%81/</id>
    <published>2022-08-21T06:39:15.000Z</published>
    <updated>2023-08-21T09:47:17.461Z</updated>
    
    <content type="html"><![CDATA[<p>本文将通过简单干净的实践方式，向读者展示在使用不同连接池以及不使用连接池的情况下，SpringBoot应用程序对接MySQL进行增删改查的性能对比。同时，还将探讨更新和查询时索引字段的关键性。</p><p>在开始之前，让我们先来思考一个问题：一张拥有21个字段的表，存放着100万条数据，会占用多少空间容量？如果这100万条数据在不使用连接池的方式下，以10个并发每条一条插入，需要多长时间？</p><p>根据经验，问题1大约需要350MB左右的空间容量，而问题2可能需要2到3小时的时间。尽管这些数字可能因机器配置而异，但重要的是你可以亲自验证它们。本文将使用ApacheBench对MySQL连接池进行压测，帮助读者更好地了解相关知识。</p><p>通过这个实践，我们可以得出结论：在使用连接池的情况下，SpringBoot应用程序对接MySQL的性能明显优于不使用连接池的情况。无论是插入、删除、更新还是查询操作，连接池都能够显著减少等待时间和资源消耗。</p><p>此外，索引字段在更新和查询时起着关键的作用。合适的索引可以提高查询效率并减少扫描的数据量。因此，在设计数据库结构时，我们应该仔细考虑如何合理地使用索引。</p><p>希望本文能够帮助读者更好地理解SpringBoot应用程序对接MySQL时连接池的重要性以及性能优化的方法。通过实践和实验，我们可以更加深入地了解并应用这些知识。</p><span id="more"></span><p>本文涉及的工程：</p><p>xfg-dev-tech-connection-pool：<a href="https://gitcode.net/KnowledgePlanet/road-map/xfg-dev-tech-connection-pool">https://gitcode.net/KnowledgePlanet/road-map/xfg-dev-tech-connection-pool</a> - 工程内含有环境的安装脚本；mysql-docker-compose.yml、apachebench-docker-compose.yml、road_map_8.0.sql</p><h2 id="一、案例背景"><a href="#一、案例背景" class="headerlink" title="一、案例背景"></a>一、案例背景</h2><p><strong>拿100万订单数据，压到数据库中！</strong></p><p>初始化一个空的数据库表，并向数据库表中写入100万数据。之后在分别不使用连接池和使用不同的连接池(c3p0、dbcp、druid、hikari)写入数据，测试各个连接池的性能。这也能让大家知道，日常我们应该选择哪个连接池。</p><h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><p>因为本章节很偏实操，所以需要大家做下提前安装好 Docker 环境，以便于执行本章节工程中的脚本和代码。可参考别的教程里面 Docker、Portainer 学习安装和使用。<br><img src="/images/MySQL_docker.png" alt="docker安装"><br>1.在 IntelliJ IDEA 打开 xfg-dev-tech-connection-pool 分别点开 mysql-docker-compose、apachebench-docker-compose，之后点击安装即可。<br>2.执行完脚本，你可以得到一份安装好的 MySQL 8.0 并安装了数据库表。另外一份是用于压测使用的 ApacheBench<br>3.连接 MySQL 的工具，推荐使用开源免费的 Sequel Ace</p><h2 id="三、工程说明"><a href="#三、工程说明" class="headerlink" title="三、工程说明"></a>三、工程说明</h2><p>在 xfg-dev-tech-connection-pool 工程中提供了不同连接池的配置和一些非常常用的 SQL 操作，以及提供了对应的接口进行压测使用；</p><table><thead><tr><th>序号</th><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a></td><td>用于缓存数据的接口，拿缓存好的数据压测更新、查询</td></tr><tr><td>2</td><td><a href="http://127.0.0.1:8091/api/mysql/insert">http://127.0.0.1:8091/api/mysql/insert</a></td><td>插入数据接口</td></tr><tr><td>3</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId">http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId</a></td><td>使用索引字段 userId 更新订单状态</td></tr><tr><td>4</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile">http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile</a></td><td>使用无索引字段 userMobile 更新订单状态</td></tr><tr><td>5</td><td><a href="http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId">http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId</a></td><td>使用索引字段 orderId 更新订单状态</td></tr><tr><td>6</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserId">http://127.0.0.1:8091/api/mysql/selectByUserId</a></td><td>使用索引字段 userId 查询订单</td></tr><tr><td>7</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserMobile">http://127.0.0.1:8091/api/mysql/selectByUserMobile</a></td><td>使用无索引字段 userMobile 查询订单，测试中添加索引</td></tr><tr><td>8</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByOrderId">http://127.0.0.1:8091/api/mysql/selectByOrderId</a></td><td>使用有索引字段 orderId 查询订单</td></tr><tr><td>9</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId">http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId</a></td><td>区分度高的索引字段在前，区分度低的索引字段在后</td></tr><tr><td>10</td><td><a href="http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId">http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId</a></td><td>区分度低的索引字段在前，区分度高的索引字段在后</td></tr></tbody></table><p>具体代码实现可以直接对照工程来看，以及按需添加SQL语句进行性能压测验证。</p><h2 id="四、库表语句"><a href="#四、库表语句" class="headerlink" title="四、库表语句"></a>四、库表语句</h2><p>SQL：xfg-dev-tech-connection-pool&#x2F;docs&#x2F;sql&#x2F;road_map_8.0.sql<br><img src="/images/MySQL_User_order.png" alt="User表结构"><br>这是本节所需要测试的一个订单表和测试前所建的索引字段。以及初始化了100万数据，占用350M空间。<br>接下来，我们就可以做测试验证了。</p><h2 id="五、压测指令"><a href="#五、压测指令" class="headerlink" title="五、压测指令"></a>五、压测指令</h2><p>ApacheBench 官网教程：<a href="https://httpd.apache.org/docs/2.4/programs/ab.html">https://httpd.apache.org/docs/2.4/programs/ab.html</a><br><img src="/images/ApacheBench%E5%AE%98%E7%BD%91%E6%95%99%E7%A8%8B.png" alt="ApacheBench官网教程"><br>常用的如：<br><code>ab -c 20 -n 1000</code><br><a href="http://127.0.0.1:8091/hi">http://127.0.0.1:8091/hi</a> - 20个并发1000次</p><h2 id="六、压测验证"><a href="#六、压测验证" class="headerlink" title="六、压测验证"></a>六、压测验证</h2><p>首先在测试前，正式测试前，你大概需要花费几十分钟来初始化100万数据。<br>执行脚本；<br><code>ab -c 20 -n 1000000</code><br><a href="http://127.0.0.1:8091/api/mysql/insert">http://127.0.0.1:8091/api/mysql/insert</a> - 如果你在工程中配置了 no-pool 大概要花费几个小时才能跑完，这就使用和不使用连接池的差距。</p><ol><li>连接池比对<br>条件；</li></ol><p>插入1万条数据<br>连接池配置 initialPoolSize&#x3D;5、minPoolSize&#x3D;5、maxPoolSize&#x3D;20<br>此时数据库已经有100万数据，分别用几个链接方式插入数据。hikari 放到最后，它是 SpringBoot 的默认连接池。<br>脚本；<br><code>ab -c 20 -n 10000 http://127.0.0.1:8091/api/mysql/insert</code></p><table><thead><tr><th></th><th>no-pool</th><th>c3p0</th><th>dbcp</th><th>druid</th><th>hikari</th></tr></thead><tbody><tr><td>耗时</td><td>88.990 seconds</td><td>24.228 seconds</td><td>33.656 seconds</td><td>25.971 seconds</td><td>25.002 seconds</td></tr><tr><td>50%</td><td>155ms</td><td>39ms</td><td>60ms</td><td>45ms</td><td>43ms</td></tr><tr><td>80%</td><td>223ms</td><td>61ms</td><td>86ms</td><td>64ms</td><td>64ms</td></tr><tr><td>90%</td><td>291ms</td><td>75ms</td><td>103ms</td><td>75ms</td><td>76ms</td></tr></tbody></table><p>通过对比可以发现，如果不使用连接池，会比使用连接池，要占用更多的时间连接数据库使用数据库。<br>c3p0、hikari 的性能还是非常不错的，dbcp 相对是弱一些的。所以这可以给你在使用连接池时有一个参考。也可以结合你的机器再次进行压测验证。<br>2. 更新对比<br>条件；</p><p>使用接口，向内存加入600条数据。每个测试方式，分别消耗200条。ab -c 10 -n 600 <a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a><br>之后使用无索引字段、有索引但区分度不高的字段以及使用有索引区分度非常好的字段来更新。<br>脚本；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserMobile</span><br><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByUserId</span><br><span class="line">ab -c 20 -n 200 http://127.0.0.1:8091/api/mysql/updateOrderStatusByOrderId</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>无索引</th><th>有索引-区分度不高</th><th>有索引-区分度很高</th></tr></thead><tbody><tr><td>耗时</td><td>24小时+</td><td>24小时+</td><td>0.432 seconds</td></tr><tr><td>50%</td><td>24小时+</td><td>24小时+</td><td>35ms</td></tr><tr><td>80%</td><td>24小时+</td><td>24小时+</td><td>48ms</td></tr><tr><td></td><td>90%</td><td>24小时+</td><td>24小时+</td></tr></tbody></table><p>无索引的时候；会把整个表的这个记录，全部锁上。那么越执行越慢，最后拖垮数据库。甚至可能1天都执行不完。<br>有索引-区分度不高；几乎是一样的，如果你批量的对一个用户的所有数据都更新，也会锁很多记录。<br>有索引-区分度很高；只要你锁的是自己的一条记录，就与别人没有影响。效率也会非常高。<br>3. 查询对比<br>条件；</p><p>查询100万加的数据库表记录，每次缓存记录5000条数据id；ab -c 10 -n 5000 <a href="http://127.0.0.1:8091/api/mysql/cacheData">http://127.0.0.1:8091/api/mysql/cacheData</a><br>userId 有索引、orderId 有索引、userMobie 无索引。<br>每次查询的时候，都要关闭服务重启，避免有缓存干扰结果。<br>脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserMobile</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByOrderId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByOrderIdAndUserId</span><br><span class="line">ab -c 20 -n 5000 http://127.0.0.1:8091/api/mysql/selectByUserIdAndOrderId</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>无索引</th><th>有索引-区分度不高</th><th>有索引区分度高</th><th>高在前</th><th>低在前</th></tr></thead><tbody><tr><td>耗时</td><td>6小时+</td><td>8.343 seconds</td><td>2.051 seconds</td><td>2.168 seconds</td><td>3.279 seconds</td></tr><tr><td>50%</td><td>7s</td><td>13ms</td><td>7ms</td><td>7ms</td><td>11ms</td></tr><tr><td>80%</td><td>9s</td><td>20ms</td><td>10ms</td><td>11ms</td><td>17ms</td></tr><tr><td>90%</td><td>15s</td><td>26ms</td><td>13ms</td><td>13ms</td><td>22ms</td></tr></tbody></table><p>无索引，还是查询字段的。非常危险。<br>不要在一些区分度不高的字段建索引。当然本案例中，userId 最多也就1000来个用户所产生的1百万数据，这样的情况更适合分库分表。<br>区分度很高的字段，查询效率会非常好。<br>把高区分度的索引字段放在前面，更有利于查询。—— 注意不要测试完上一个，直接测试下一个。有缓存的情况下，会影响对比结果。<br>这就是整个数据库表的压测过程了。如果你有使用的诉求，需要做技术调研，那么一定要做一些这样的压测处理。这样有真实数据才好讲道理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将通过简单干净的实践方式，向读者展示在使用不同连接池以及不使用连接池的情况下，SpringBoot应用程序对接MySQL进行增删改查的性能对比。同时，还将探讨更新和查询时索引字段的关键性。&lt;/p&gt;
&lt;p&gt;在开始之前，让我们先来思考一个问题：一张拥有21个字段的表，存放着100万条数据，会占用多少空间容量？如果这100万条数据在不使用连接池的方式下，以10个并发每条一条插入，需要多长时间？&lt;/p&gt;
&lt;p&gt;根据经验，问题1大约需要350MB左右的空间容量，而问题2可能需要2到3小时的时间。尽管这些数字可能因机器配置而异，但重要的是你可以亲自验证它们。本文将使用ApacheBench对MySQL连接池进行压测，帮助读者更好地了解相关知识。&lt;/p&gt;
&lt;p&gt;通过这个实践，我们可以得出结论：在使用连接池的情况下，SpringBoot应用程序对接MySQL的性能明显优于不使用连接池的情况。无论是插入、删除、更新还是查询操作，连接池都能够显著减少等待时间和资源消耗。&lt;/p&gt;
&lt;p&gt;此外，索引字段在更新和查询时起着关键的作用。合适的索引可以提高查询效率并减少扫描的数据量。因此，在设计数据库结构时，我们应该仔细考虑如何合理地使用索引。&lt;/p&gt;
&lt;p&gt;希望本文能够帮助读者更好地理解SpringBoot应用程序对接MySQL时连接池的重要性以及性能优化的方法。通过实践和实验，我们可以更加深入地了解并应用这些知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL、SpringBoot" scheme="https://longchao012.github.io/tags/MySQL%E3%80%81SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>基于UiBot开发的RPA项目各类银行操作流程(银行流水下载、自动填写付款单等)</title>
    <link href="https://longchao012.github.io/2022/08/16/%E5%9F%BA%E4%BA%8EUiBot%E5%BC%80%E5%8F%91%E7%9A%84RPA%E9%A1%B9%E7%9B%AE%E9%93%B6%E8%A1%8C%E6%B5%81%E6%B0%B4%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
    <id>https://longchao012.github.io/2022/08/16/%E5%9F%BA%E4%BA%8EUiBot%E5%BC%80%E5%8F%91%E7%9A%84RPA%E9%A1%B9%E7%9B%AE%E9%93%B6%E8%A1%8C%E6%B5%81%E6%B0%B4%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B/</id>
    <published>2022-08-16T02:10:22.000Z</published>
    <updated>2023-08-23T10:14:57.368Z</updated>
    
    <content type="html"><![CDATA[<p>基于UiBot开发的RPA项目银行流水下载流程<br>做过很多关于银行相关的RPA项目，本次主要以UIBot这个工具来实施的银行相关RPA项目。使用的UiBot Creator 5.6的版本，后续更新为6.0版本。涉及的银行有中国银行，工商银行，民生银行，光大银行，农业银行等多少银行。有通过C&#x2F;S访问的，也有通过B&#x2F;S访问的。客户方面都没有做太多的限制，能满足业务需要即可。开发的周期，看业务需求的范围与数据结构的复杂度。如果有对账，数据转换等需求的项目可能时间会相对长一点，如果只是单纯的下载流水或填写付款单等待，那基本会很快，时间可以控制在一到两周以内。<br>目前为止。接受到的需求主要有以下几种：<br>1.流水查询(一般会跟着有有自动对账需求)<br>2.付款单填写<br>总体来说，就是资金的借与贷的变化。除此无它！</p><p>那么我们开发的过程中可能会遇到什么问题呢？</p><span id="more"></span><h2 id="开发过程中可能会遇到的问题"><a href="#开发过程中可能会遇到的问题" class="headerlink" title="开发过程中可能会遇到的问题"></a>开发过程中可能会遇到的问题</h2><h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>做银行相关的项目，其中最重要的也是客户最关心的就是安全性问题，就以目前的项目来说，安全性其它不太用顾虑。因为如果是查流水，没有太多的资金的上担忧，只是简单的查。而且数据也不是那么容易泄漏的，主要是有三个方面的防护<br>1.物理性的防护，通过保护电脑与主机还有Ukey(主要)，在使用的时候才插入Ukey即可。<br>2.登录密码的防护，可以把密码写入到Window的凭证中，通过UiBot内置的组件来读取，开发人员也不知道这个密码是什么。<br>3.严密的保存交易密码。RPA流程不会涉及到交易密码，也不建议把交易密码暴露出来让RPA机器人使用。</p><h3 id="需求中的问题"><a href="#需求中的问题" class="headerlink" title="需求中的问题"></a>需求中的问题</h3><p>主要是个别客户的对账的过程复杂，需要考虑的因素特别多，对账时候的数据非标准数据，需要很多的数据转换。这其中的过程遇到很多的困难。<br>同时，有时候客户自身对需求的细节也会判定不足，导致开发过程中进行不下去，项目周末延长。</p><h3 id="银行系统的限制问题"><a href="#银行系统的限制问题" class="headerlink" title="银行系统的限制问题"></a>银行系统的限制问题</h3><p>银行系统会监测你的行为还有不允许有远程之类的操作。不能让远程控制输入密码。可以调用驱动级的键盘输入解决问题。部分银行的系统的C&#x2F;S端元素的布局是比较混乱的，元素明明在A点，坐标却是偏到了天边的B点，而很多的控件或元素都是无法获取到对应的元素坐标。不知道是出于安全还是其它方面的考虑。这个没有太好的解决办法，只能一点点的适配与调节。而相比B&#x2F;S端这种情况就会好很多，但是很多客户的电脑配置都不太好，而且银行对浏览器的支持也是强差人意。只能根据每个客户做相对应的调整与配置。</p><h3 id="现场运行环境问题"><a href="#现场运行环境问题" class="headerlink" title="现场运行环境问题"></a>现场运行环境问题</h3><p>环境问题大部分是性能问题，有的客户的电脑是很破旧的电脑，有的客户的电脑还运行着Windows7或Windows XP。实在是太难啦。这个没什么解决的办法，只能尽量的沟通协调，不行就让RPA流程慢下来，通过不断的试错慢慢的适配比较差的电脑环境。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于UiBot开发的RPA项目银行流水下载流程&lt;br&gt;做过很多关于银行相关的RPA项目，本次主要以UIBot这个工具来实施的银行相关RPA项目。使用的UiBot Creator 5.6的版本，后续更新为6.0版本。涉及的银行有中国银行，工商银行，民生银行，光大银行，农业银行等多少银行。有通过C&amp;#x2F;S访问的，也有通过B&amp;#x2F;S访问的。客户方面都没有做太多的限制，能满足业务需要即可。开发的周期，看业务需求的范围与数据结构的复杂度。如果有对账，数据转换等需求的项目可能时间会相对长一点，如果只是单纯的下载流水或填写付款单等待，那基本会很快，时间可以控制在一到两周以内。&lt;br&gt;目前为止。接受到的需求主要有以下几种：&lt;br&gt;1.流水查询(一般会跟着有有自动对账需求)&lt;br&gt;2.付款单填写&lt;br&gt;总体来说，就是资金的借与贷的变化。除此无它！&lt;/p&gt;
&lt;p&gt;那么我们开发的过程中可能会遇到什么问题呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA、银行、办公自动化" scheme="https://longchao012.github.io/tags/RPA%E3%80%81%E9%93%B6%E8%A1%8C%E3%80%81%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>我们应该从哪些方面思考公司场景是否适合RPA流程自动化</title>
    <link href="https://longchao012.github.io/2022/07/16/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%80%9D%E8%80%83%E5%85%AC%E5%8F%B8%E5%9C%BA%E6%99%AF%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88RPA%E6%B5%81%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>https://longchao012.github.io/2022/07/16/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%80%9D%E8%80%83%E5%85%AC%E5%8F%B8%E5%9C%BA%E6%99%AF%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88RPA%E6%B5%81%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96/</id>
    <published>2022-07-16T07:23:41.000Z</published>
    <updated>2023-08-23T10:15:08.044Z</updated>
    
    <content type="html"><![CDATA[<p>随着科技的发展，RPA（Robotic Process Automation）流程自动化已经成为企业提升效率，降低成本的重要工具。我们需要理解RPA的基本概念和特性。RPA是一种可以模拟和复制人类在应用程序中执行的重复任务的技术，它可以24&#x2F;7不间断工作，不需要休息，也不需要假期。这种特性使得RPA非常适合处理大量的、重复的、规则化的任务。<br>那么那些场景或需求合适使用自动化呢？</p><span id="more"></span><h2 id="流程适合性"><a href="#流程适合性" class="headerlink" title="流程适合性"></a>流程适合性</h2><p>您可以使用以下标准评估流程是否适合自动化：</p><h3 id="基于规则"><a href="#基于规则" class="headerlink" title="基于规则"></a>基于规则</h3><p>可通过预定义逻辑捕获在流程中做出的决策（包括数据解释）。这样带来的结果是，异常率要么很低，要么包含在业务逻辑中。</p><h3 id="可自动化和-或重复性流程"><a href="#可自动化和-或重复性流程" class="headerlink" title="可自动化和&#x2F;或重复性流程"></a>可自动化和&#x2F;或重复性流程</h3><p>我们可以区分4种类型的流程：<br>手动非重复性流程：由人工执行且每次执行该流程时都有不同的流程步骤<br>手动重复性流程：由用户执行，并且每次至少有部分相同的流程步骤<br>半自动化重复性流程：其中一些重复的步骤已经实现自动化（使用宏、Outlook 规则等）<br>自动化流程：已使用除 RPA 之外的其他技术实现自动化的流程<br>由于异常率高或无法集成到业务逻辑中的因素，仍然需要手动执行或非重复性的流程并非自动化的理想选择。</p><h3 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h3><p>流程中的输入应采用电子形式且易于读取，或者可以使用与 RPA 相关的技术（例如 OCR）进行读取。预定义字段的发票就是很好的例子。</p><h3 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h3><p>在一定时期内相同且在接下来的几个月内预计不会发生任何变化的流程适合自动化，前提是它们也符合另一个标准。</p><h2 id="自动化的复杂性"><a href="#自动化的复杂性" class="headerlink" title="自动化的复杂性"></a>自动化的复杂性</h2><p>这套标准用于确定实现流程自动化的难度：</p><h3 id="界面数量"><a href="#界面数量" class="headerlink" title="界面数量"></a>界面数量</h3><p>RPA的工作原理是，通过对机器人进行编程，使其可以在界面级别执行任务（当界面更改时，机器人必须学习逻辑）。界面数量越多，在实现流程自动化之前必须捕获和配置的元素就越多。</p><h3 id="应用程序的类型"><a href="#应用程序的类型" class="headerlink" title="应用程序的类型"></a>应用程序的类型</h3><p>有些应用程序较易实现自动化（例如 Office套件或浏览器），而有些则需要大量工作才能实现自动化（例如大型机）。随着应用程序的差异越大，界面数量也会随之增加（参见上一点）。</p><h3 id="业务逻辑场景"><a href="#业务逻辑场景" class="headerlink" title="业务逻辑场景"></a>业务逻辑场景</h3><p>自动化的复杂性随着业务逻辑中决策点的数量而增加。基本上，每个决策点乘二即可得出场景数量。</p><h3 id="输入的类型和数量"><a href="#输入的类型和数量" class="headerlink" title="输入的类型和数量"></a>输入的类型和数量</h3><p>如前所述，需要使用标准输入。但在某些情况下，必须为将受到自动化影响的所有供应商配置一个标准输入（例如发票）。此外，非标准输入可以分为不同的复杂性等级，其中自由文本是最复杂的。</p><h2 id="评估自动化潜力"><a href="#评估自动化潜力" class="headerlink" title="评估自动化潜力"></a>评估自动化潜力</h2><h3 id="不使用RPA"><a href="#不使用RPA" class="headerlink" title="不使用RPA"></a>不使用RPA</h3><p>频繁变化、系统环境多变且需要执行多个手动（甚至非数字）操作的流程。</p><h3 id="半自动化"><a href="#半自动化" class="headerlink" title="半自动化"></a>半自动化</h3><p>可以分解为可明确自动化的步骤和仍需手动执行的步骤（例如验证或使用物理安全性令牌）的流程。</p><h3 id="高成本RPA"><a href="#高成本RPA" class="headerlink" title="高成本RPA"></a>高成本RPA</h3><p>数字化程度较高并且可以实现自动化的流程，但需要使用一些复杂的技术（例如 OCR）或需要具备高级编程技能。</p><h3 id="零接触自动化"><a href="#零接触自动化" class="headerlink" title="零接触自动化"></a>零接触自动化</h3><p>涉及高度静态的系统和流程环境的数字化流程，这些流程很容易就能分解为指令并且可以定义简单的触发器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着科技的发展，RPA（Robotic Process Automation）流程自动化已经成为企业提升效率，降低成本的重要工具。我们需要理解RPA的基本概念和特性。RPA是一种可以模拟和复制人类在应用程序中执行的重复任务的技术，它可以24&amp;#x2F;7不间断工作，不需要休息，也不需要假期。这种特性使得RPA非常适合处理大量的、重复的、规则化的任务。&lt;br&gt;那么那些场景或需求合适使用自动化呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="RPA、Python、办公自动化" scheme="https://longchao012.github.io/tags/RPA%E3%80%81Python%E3%80%81%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hello World For LongChao</title>
    <link href="https://longchao012.github.io/2022/07/15/hello-world/"/>
    <id>https://longchao012.github.io/2022/07/15/hello-world/</id>
    <published>2022-07-15T07:23:41.000Z</published>
    <updated>2023-08-23T10:15:26.188Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
